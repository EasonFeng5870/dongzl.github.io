<!DOCTYPE html><html lang="zh-cn"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><title>Kafka 是如何解决使用 MQ 中容易出现的一些问题 | 董宗磊的博客--善积跬步，方以千里</title><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><meta name="format-detection" content="telephone=no"><meta name="author" content="[object Object]"><meta name="designer" content="minfive"><meta name="keywords" content="minfive, minfive blog, 前端博客, 前端, 程序员, 前端开发, 全栈开发, node.js, javascript"><meta name="description" content="取法于上，仅得为中；取法于中，故为其下。"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="format-detection" content="telephone=yes"><meta name="mobile-web-app-capable" content="yes"><meta name="robots" content="all"><link rel="canonical" href="https://dongzl.github.io/2020/03/16/13-Solve-MQ-Problem-With-Kafka/index.html"><link rel="icon" type="image/png" href="/img/theme/favicon.ico" sizes="32x32"><link rel="stylesheet" href="/scss/base/index.css"><link rel="alternate" href="/atom.xml" title="董宗磊的博客"><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?e4027971a230b210f4671f485b33846a";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><link rel="stylesheet" href="/scss/views/page/post.css"><link rel="alternate" href="/atom.xml" title="董宗磊的博客" type="application/atom+xml"></head><body ontouchstart><div id="page-loading" class="page page-loading" style="background-image:url(/img/theme/loading.gif)"></div><div id="page" class="page js-hidden"><header class="page__small-header page__header--small"><nav class="page__navbar"><div class="page__container navbar-container"><a class="page__logo" href="/" title="董宗磊的博客" alt="董宗磊的博客"><img src="/img/theme/title.png" alt="董宗磊的博客"></a><nav class="page__nav"><ul class="nav__list clearfix"><li class="nav__item"><a href="/" alt="首页" title="首页">首页</a></li><li class="nav__item"><a href="/archives" alt="归档" title="归档">归档</a></li><li class="nav__item"><a href="/about" alt="关于" title="关于">关于</a></li></ul></nav><button class="page__menu-btn" type="button"><i class="iconfont icon-menu"></i></button></div></nav></header><main class="page__container page__main"><div class="page__content"><article class="page__post"><div class="post__cover"><img src="https://gitee.com/dongzl/article-images/raw/master/cover/kafka_study.png" alt="Kafka 是如何解决使用 MQ 中容易出现的一些问题"></div><header class="post__info"><h1 class="post__title">Kafka 是如何解决使用 MQ 中容易出现的一些问题</h1><div class="post__mark"><div class="mark__block"><i class="mark__icon iconfont icon-write"></i><ul class="mark__list clearfix"><li class="mark__item"><a href="https://www.github.com/dongzl">董宗磊</a></li></ul></div><div class="mark__block"><i class="mark__icon iconfont icon-time"></i><ul class="mark__list clearfix"><li class="mark__item"><span>2020-03-16</span></li></ul></div><div class="mark__block"><i class="mark__icon iconfont icon-tab"></i><ul class="mark__list clearfix"><li class="mark__item"><a href="/tags/Kafka/">Kafka</a></li></ul></div><div class="mark__block"><i class="mark__icon iconfont icon-eye"></i><ul class="mark__list clearfix"><li id="busuanzi_container_page_pv" class="mark__item"><span id="busuanzi_value_page_pv"></span>次</li></ul></div></div></header><div class="post__content"><h2 id="背景描述"><a href="#背景描述" class="headerlink" title="背景描述"></a>背景描述</h2><p>目前，很多的业务系统都会或多或少的使用各种 MQ 消息队列框架，例如：<code>RabbitMQ</code>、<code>Kafka</code>、<code>RocketMQ</code> 等等，使用 MQ 消息队列，可以满足业务系统 <code>解耦</code>、<code>异步</code>、<code>削峰填谷</code> 场景的需要，但是使用 MQ 中也不得不面临一些问题，这些问题总结如下：</p><blockquote><p>1、如何保证消息队列的高可用？<br>2、如何保证消息不被重复消费？（如何保证消息消费的幂等性）<br>3、如何保证消息的可靠传输？（如何处理消息丢失的问题）<br>4、如何保证消息的顺序性？</p></blockquote><p>其实这些问题也是在面试中 MQ 经常被问到的问题，下面我们就总结分析一下，Kafka 中是如何解决上述问题的。</p><h2 id="Kafka-如何保证高可用"><a href="#Kafka-如何保证高可用" class="headerlink" title="Kafka 如何保证高可用"></a>Kafka 如何保证高可用</h2><p>Kafka 的基本架构组成是：由多个 broker 组成一个集群，每个 broker 是一个节点；当创建一个 topic 时，这个 topic 会被划分为多个 partition，每个 partition 可以存在于不同的 broker 上，每个 partition 只存放一部分数据。</p><p>这就是<strong>天然的分布式消息队列</strong>，就是说一个 topic 的数据，是<strong>分散放在多个机器上的，每个机器就放一部分数据</strong>。</p><p>在 Kafka 0.8 版本之前，是没有 HA 机制的，当任何一个 broker 所在节点宕机了，这个 broker 上的 partition 就无法提供读写服务，所以这个版本之前，Kafka 没有什么高可用性可言。</p><p>在 Kafka 0.8 以后，提供了 HA 机制，就是 replica 副本机制。每个 partition 上的数据都会同步到其它机器，形成自己的多个 replica 副本。所有 replica 会选举一个 leader 出来，消息的生产者和消费者都跟这个 leader 打交道，其他 replica 作为 follower。写的时候，leader 会负责把数据同步到所有 follower 上去，读的时候就直接读 leader 上的数据即可。Kafka 负责均匀的将一个 partition 的所有 replica 分布在不同的机器上，这样才可以提高容错性。</p><p>&lt;插入图片&gt; @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</p><p>拥有了 replica 副本机制，如果某个 broker 宕机了，这个 broker 上的 partition 在其他机器上还存在副本。如果这个宕机的 broker 上面有某个 partition 的 leader，那么此时会从其 follower 中重新选举一个新的 leader 出来，这个新的 leader 会继续提供读写服务，这就有达到了所谓的高可用性。</p><p>写数据的时候，生产者只将数据写入 leader 节点，leader 会将数据写入本地磁盘，接着其他 follower 会主动从 leader 来拉取数据，follower 同步好数据了，就会发送 ack 给 leader，leader 收到所有 follower 的 ack 之后，就会返回写成功的消息给生产者。</p><p>消费数据的时候，消费者只会从 leader 节点去读取消息，但是只有当一个消息已经被所有 follower 都同步成功返回 ack 的时候，这个消息才会被消费者读到。</p><p>&lt;插入图片&gt; @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</p><h2 id="使用-Kafka，如何保证消息不被重复消费"><a href="#使用-Kafka，如何保证消息不被重复消费" class="headerlink" title="使用 Kafka，如何保证消息不被重复消费"></a>使用 Kafka，如何保证消息不被重复消费</h2><h3 id="Kafka-在什么场景下会导致消费者消费到重复数据"><a href="#Kafka-在什么场景下会导致消费者消费到重复数据" class="headerlink" title="Kafka 在什么场景下会导致消费者消费到重复数据"></a>Kafka 在什么场景下会导致消费者消费到重复数据</h3><p>Kafka 实际上有个 offset 的概念，就是每个消息写到 partition 里，都会有一个 offset，代表消息的序号，在 consumer 消费了数据之后，<strong>每隔一段时间（定时定期）</strong>，consumer 会把自己消费过的消息的 offset 提交一下，表示<strong>这些消息已经消费过了，如果发生异常，下次我将从上次消费到的 offset 来继续消费</strong>。</p><p>但是这个过程还是会有意外出现，比如 consumer 机器突然宕机，这会导致 consumer 有些消息已经处理了，但是没来得及提交 offset，这个时候重启之后，就会有少数宕机之前会来得及提交 offset 的消息会被再消费一次。</p><h3 id="如何解决消费到重复数据问题"><a href="#如何解决消费到重复数据问题" class="headerlink" title="如何解决消费到重复数据问题"></a>如何解决消费到重复数据问题</h3><p>对于重复消费的问题，我理解对于任何 MQ 消息队列都是无法避免的，所以就需要我们在业务系统进行<strong>重复消费的幂等性</strong>验证，当然也要考虑业务场景需要，比如一个日志采集系统，每天上千万的数据，某条重复数据的影响几乎可以忽略不计，这个时候也是不需要考虑；如果是其他场景，需要保证幂等性，可以从如下几方面考虑：</p><ul><li>如果是写数据库，可以将消息中的某个字段做为数据库唯一约束，在数据处理之前，先根据唯一约束查询一下，判断是否已经消费过；</li><li>如果是写入 Redis，可以直接调用 set 方法，天然具备幂等性；</li><li>在生产者发送每消息的时候，在消息里面加一个全局唯一的 id，类似订单 id 之类的数据，当消费到这个数据之后，先根据这个全局 id 去比如 Redis 里查一下，如果不存在，说明没有消费过，就继续处理，然后这个 id 写 Redis；如果存在，说明已经消费过，消息直接丢弃。</li></ul><h2 id="使用-Kafka，如何保证消息的可靠传输"><a href="#使用-Kafka，如何保证消息的可靠传输" class="headerlink" title="使用 Kafka，如何保证消息的可靠传输"></a>使用 Kafka，如何保证消息的可靠传输</h2><p>对于保证消息的可靠传输，其实就是如何解决消息丢失的问题；那么我们首先需要弄明白消息为什么会丢失，对于一个消息队列，会有 <code>生产者</code>、<code>MQ</code>、<code>消费者</code> 这三个角色，在这三个角色数据处理和传输过程中，都有可能会出现消息丢失，</p><p>&lt;插入图片&gt; @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</p><p>下面我们就结合 Kafka 来分析一下消息丢失的原因以及解决办法：</p><h3 id="消费者异常导致的消息丢失"><a href="#消费者异常导致的消息丢失" class="headerlink" title="消费者异常导致的消息丢失"></a>消费者异常导致的消息丢失</h3><p>消费者可能导致数据丢失的情况是：消费者获取到了这条消息后，还未处理，Kafka 就自动提交了 offset，这时 Kafka 就认为消费者已经处理完这条消息，其实消费者才刚准备处理这条消息，这时如果消费者宕机，那这条消息就丢失了。</p><p>消费者引起消息丢失的主要原因就是消息还未处理完 Kafka 会自动提交了 offset，那么只要关闭自动提交 offset，消费者在处理完之后手动提交 offset，就可以保证消息不会丢失。但是此时需要注意重复消费问题，比如消费者刚处理完，还没提交 offset，这时自己宕机了，此时这条消息肯定会被重复消费一次，这就需要消费者根据实际情况保证幂等性。</p><h3 id="Kafka-导致的消息丢失"><a href="#Kafka-导致的消息丢失" class="headerlink" title="Kafka 导致的消息丢失"></a>Kafka 导致的消息丢失</h3><p>Kafka 导致的数据丢失一个常见的场景就是 Kafka 某个 broker 宕机，，而这个节点正好是某个 partition 的 leader 节点，这时需要重新重新选举该 partition 的 leader。如果该 partition 的 leader 在宕机时刚好还有些数据没有同步到 follower，此时 leader 挂了，在选举某个 follower 成 leader 之后，就会丢失一部分数据。</p><p>对于这个问题，Kafka 可以设置如下 4 个参数，来尽量避免消息丢失：</p><ul><li>给 topic 设置 replication.factor 参数：这个值必须大于 1，要求每个 partition 必须有至少 2 个副本；</li><li>在 Kafka 服务端设置 min.insync.replicas 参数：这个值必须大于 1，这个参数的含义是一个 leader 至少感知到有至少一个 follower 还跟自己保持联系，没掉队，这样才能确保 leader 挂了还有一个 follower 节点。</li><li>在 producer 端设置 acks=all：这个是要求每条数据，必须是写入所有 replica 之后，才能认为是写成功了；</li><li>在 producer 端设置 retries=MAX（很大很大很大的一个值，无限次重试的意思）：这个参数的含义是一旦写入失败，就无限重试，卡在这里了。</li></ul><h3 id="生产者数据传输导致的消息丢失"><a href="#生产者数据传输导致的消息丢失" class="headerlink" title="生产者数据传输导致的消息丢失"></a>生产者数据传输导致的消息丢失</h3><p>对于生产者数据传输导致的数据丢失主常见情况是生产者发送消息给 Kafka，由于网络等原因导致消息丢失，对于这种情况也是通过在 <strong>producer</strong> 端设置 <strong>acks=all</strong> 来处理，这个参数是要求 leader 接收到消息后，需要等到所有的 follower 都同步到了消息之后，才认为本次写成功了。如果没满足这个条件，生产者会自动不断的重试。</p><p><a href="https://mp.weixin.qq.com/s/qttczGROYoqSulzi8FLXww" target="_blank" rel="noopener">面试官问我如何保证Kafka不丢失消息?我哭了！</a></p><h2 id="Kafka-如何保证消息的顺序性"><a href="#Kafka-如何保证消息的顺序性" class="headerlink" title="Kafka 如何保证消息的顺序性"></a>Kafka 如何保证消息的顺序性</h2><p>在某些业务场景下，我们需要保证对于有逻辑关联的多条MQ消息被按顺序处理，比如对于某一条数据，正常处理顺序是<code>新增-更新-删除</code>，最终结果是数据被删除；如果消息没有按序消费，处理顺序可能是<code>删除-新增-更新</code>，最终数据没有被删掉，可能会产生一些逻辑错误。对于如何保证消息的顺序性，主要需要考虑如下两点：</p><ul><li>如何保证消息在 MQ 中顺序性；</li><li>如何保证消费者处理消费的顺序性。</li></ul><h3 id="如何保证消息在-MQ-中顺序性"><a href="#如何保证消息在-MQ-中顺序性" class="headerlink" title="如何保证消息在 MQ 中顺序性"></a>如何保证消息在 MQ 中顺序性</h3><p>对于 Kafka，如果我们创建了一个 topic，默认有三个 partition。生产者在写数据的时候，可以指定一个 key，比如在订单 topic 中我们可以指定订单 id 作为 key，那么相同订单 id 的数据，一定会被分发到同一个 partition 中去，而且这个 partition 中的数据一定是有顺序的。消费者从 partition 中取出来数据的时候，也一定是有顺序的。通过制定 key 的方式首先可以保证在 kafka 内部消息是有序的。</p><h3 id="如何保证消费者处理消费的顺序性"><a href="#如何保证消费者处理消费的顺序性" class="headerlink" title="如何保证消费者处理消费的顺序性"></a>如何保证消费者处理消费的顺序性</h3><p>对于某个 topic 的一个 partition，只能被同组内部的一个 consumer 消费，如果这个 consumer 内部还是单线程处理，那么其实只要保证消息在 MQ 内部是有顺序的就可以保证消费也是有顺序的。但是单线程吞吐量太低，在处理大量 MQ 消息时，我们一般会开启多线程消费机制，那么如何保证消息在多个线程之间是被顺序处理的呢？对于多线程消费我们可以预先设置 N 个内存 Queue，具有相同 key 的数据都放到同一个内存 Queue 中；然后开启 N 个线程，每个线程分别消费一个内存 Queue 的数据即可，这样就能保证顺序性。当然，消息放到内存 Queue 中，有可能还未被处理，consumer 发生宕机，内存 Queue 中的数据会全部丢失，这就转变为上面提到的<strong>如何保证消息的可靠传输</strong>的问题了。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.cnblogs.com/qingyunzong/p/9004703.html" target="_blank" rel="noopener">Kafka学习之路 （三）Kafka的高可用</a></li></ul><div class="post-announce">感谢您的阅读，本文由 <a href="https://dongzl.github.io">董宗磊的博客</a> 版权所有。如若转载，请注明出处：董宗磊的博客（<a href="https://dongzl.github.io/2020/03/16/13-Solve-MQ-Problem-With-Kafka/">https://dongzl.github.io/2020/03/16/13-Solve-MQ-Problem-With-Kafka/</a>）</div><div class="post__prevs"><div class="post__prev"><a href="/2020/03/15/12-MySQL-Master-Slave-Replication/" title="MySQL 主从复制原理及配置"><i class="iconfont icon-prev"></i>MySQL 主从复制原理及配置</a></div><div class="post__prev post__prev--right"><a href="/2020/03/17/14-Redis-HA-Master-Salve/" title="Redis 高可用之主从复制">Redis 高可用之主从复制<i class="iconfont icon-next"></i></a></div></div></div></article><div id="comment-container"></div></div><aside class="page__sidebar"><form id="page-search-from" class="page__search-from" action="/search/"><label class="search-form__item"><input class="input" type="text" name="search" placeholder="Search..."> <i class="iconfont icon-search"></i></label></form><div class="sidebar__block"><h3 class="block__title">简介</h3><p class="block__text">取法于上，仅得为中；取法于中，故为其下。</p></div><div class="sidebar__block"><h3 class="block__title">文章分类</h3><ul class="block-list"><li class="block-list-item"><a class="block-list-link" href="/categories/设计模式/">设计模式</a><span class="block-list-count">4</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/架构设计/">架构设计</a><span class="block-list-count">7</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/架构/">架构</a><span class="block-list-count">1</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/数据结构与算法/">数据结构与算法</a><span class="block-list-count">2</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/数据库/">数据库</a><span class="block-list-count">6</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/其他/">其他</a><span class="block-list-count">4</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/web开发/">web开发</a><span class="block-list-count">3</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/java开发/">java开发</a><span class="block-list-count">5</span></li></ul></div><div class="sidebar__block"><h3 class="block__title">最新文章</h3><ul class="block-list latest-post-list"><li class="latest-post-item"><a href="/2020/04/01/19-CountDownLatch-AQS-Share-Lock/" title="CountDownLatch 基于 AQS 共享锁模式实现原理分析"><div class="item__cover"><img src="https://gitee.com/dongzl/article-images/raw/master/cover/java_study.png" alt="CountDownLatch 基于 AQS 共享锁模式实现原理分析"></div><div class="item__info"><h3 class="item__title">CountDownLatch 基于 AQS 共享锁模式实现原理分析</h3><span class="item__text">2020-04-01</span></div></a></li><li class="latest-post-item"><a href="/2020/03/22/18-Redis-Interview-knowledge/" title="Redis 面试常见问题知识点总结"><div class="item__cover"><img src="https://gitee.com/dongzl/article-images/raw/master/cover/redis_study.png" alt="Redis 面试常见问题知识点总结"></div><div class="item__info"><h3 class="item__title">Redis 面试常见问题知识点总结</h3><span class="item__text">2020-03-22</span></div></a></li><li class="latest-post-item"><a href="/2020/03/21/17-Bloom-Filter-Summary/" title="BloomFilter 实现原理及使用"><div class="item__cover"><img src="/img/theme/blog_work.png" alt="BloomFilter 实现原理及使用"></div><div class="item__info"><h3 class="item__title">BloomFilter 实现原理及使用</h3><span class="item__text">2020-03-21</span></div></a></li><li class="latest-post-item"><a href="/2020/03/19/16-MySQL-Lock-Summary/" title="MySQL 数据库 Lock 知识总结"><div class="item__cover"><img src="https://gitee.com/dongzl/article-images/raw/master/cover/mysql_study.png" alt="MySQL 数据库 Lock 知识总结"></div><div class="item__info"><h3 class="item__title">MySQL 数据库 Lock 知识总结</h3><span class="item__text">2020-03-19</span></div></a></li></ul></div><div class="sidebar__block"><h3 class="block__title">文章标签</h3><ul class="block-list tag-list clearfix"><li class="tag-item"><a class="tag-link" href="/tags/ACID/">ACID</a></li><li class="tag-item"><a class="tag-link" href="/tags/AQS/">AQS</a></li><li class="tag-item"><a class="tag-link" href="/tags/BloomFilter/">BloomFilter</a></li><li class="tag-item"><a class="tag-link" href="/tags/CountDownLatch/">CountDownLatch</a></li><li class="tag-item"><a class="tag-link" href="/tags/EventBus/">EventBus</a></li><li class="tag-item"><a class="tag-link" href="/tags/Full-GC/">Full GC</a></li><li class="tag-item"><a class="tag-link" href="/tags/GRIT/">GRIT</a></li><li class="tag-item"><a class="tag-link" href="/tags/Guava/">Guava</a></li><li class="tag-item"><a class="tag-link" href="/tags/Hash/">Hash</a></li><li class="tag-item"><a class="tag-link" href="/tags/HashMap/">HashMap</a></li><li class="tag-item"><a class="tag-link" href="/tags/Hexo/">Hexo</a></li><li class="tag-item"><a class="tag-link" href="/tags/JSON/">JSON</a></li><li class="tag-item"><a class="tag-link" href="/tags/JVM/">JVM</a></li><li class="tag-item"><a class="tag-link" href="/tags/Kafka/">Kafka</a></li><li class="tag-item"><a class="tag-link" href="/tags/Lock/">Lock</a></li><li class="tag-item"><a class="tag-link" href="/tags/Lombok/">Lombok</a></li><li class="tag-item"><a class="tag-link" href="/tags/MAT/">MAT</a></li><li class="tag-item"><a class="tag-link" href="/tags/MySQL/">MySQL</a></li><li class="tag-item"><a class="tag-link" href="/tags/Observable/">Observable</a></li><li class="tag-item"><a class="tag-link" href="/tags/Observer/">Observer</a></li><li class="tag-item"><a class="tag-link" href="/tags/Redis/">Redis</a></li><li class="tag-item"><a class="tag-link" href="/tags/Redo-log/">Redo log</a></li><li class="tag-item"><a class="tag-link" href="/tags/ShardingSphere/">ShardingSphere</a></li><li class="tag-item"><a class="tag-link" href="/tags/Thread/">Thread</a></li><li class="tag-item"><a class="tag-link" href="/tags/ThreadPoolExecutor/">ThreadPoolExecutor</a></li><li class="tag-item"><a class="tag-link" href="/tags/Undo-log/">Undo log</a></li><li class="tag-item"><a class="tag-link" href="/tags/Wireshark/">Wireshark</a></li><li class="tag-item"><a class="tag-link" href="/tags/ZooKeeper/">ZooKeeper</a></li><li class="tag-item"><a class="tag-link" href="/tags/distributed-transaction/">distributed transaction</a></li><li class="tag-item"><a class="tag-link" href="/tags/hexo/">hexo</a></li><li class="tag-item"><a class="tag-link" href="/tags/synchronized/">synchronized</a></li><li class="tag-item"><a class="tag-link" href="/tags/主从复制/">主从复制</a></li><li class="tag-item"><a class="tag-link" href="/tags/优化/">优化</a></li><li class="tag-item"><a class="tag-link" href="/tags/数学公式/">数学公式</a></li><li class="tag-item"><a class="tag-link" href="/tags/数据库事务/">数据库事务</a></li><li class="tag-item"><a class="tag-link" href="/tags/数据结构/">数据结构</a></li><li class="tag-item"><a class="tag-link" href="/tags/策略模式/">策略模式</a></li><li class="tag-item"><a class="tag-link" href="/tags/算法/">算法</a></li><li class="tag-item"><a class="tag-link" href="/tags/索引/">索引</a></li><li class="tag-item"><a class="tag-link" href="/tags/红黑树/">红黑树</a></li><li class="tag-item"><a class="tag-link" href="/tags/线程池/">线程池</a></li><li class="tag-item"><a class="tag-link" href="/tags/观察者模式/">观察者模式</a></li><li class="tag-item"><a class="tag-link" href="/tags/计算机组成原理/">计算机组成原理</a></li><li class="tag-item"><a class="tag-link" href="/tags/设计原则/">设计原则</a></li><li class="tag-item"><a class="tag-link" href="/tags/设计模式/">设计模式</a></li></ul></div></aside></main><footer class="page__footer"><section class="footer__top"><div class="page__container footer__container"><div class="footer-top__item footer-top__item--2"><h3 class="item__title">关于</h3><div class="item__content"><p class="item__text">本站是基于 Hexo 搭建的静态资源博客，主要用于分享日常学习、生活及工作的一些心得总结，欢迎点击右下角订阅 rss。</p><ul class="footer__contact-info"><li class="contact-info__item"><i class="iconfont icon-address"></i> <span>Beijing, China</span></li><li class="contact-info__item"><i class="iconfont icon-email2"></i> <span>dongzonglei@apache.org</span></li></ul></div></div><div class="footer-top__item footer__image"><img src="/img/theme/qrcode.jpg" alt="logo" title="董宗磊的博客"></div><div class="footer-top__item"><h3 class="item__title">友情链接</h3><div class="item__content"><ul class="footer-top__list"><li class="list-item"><a href="https://mrdear.cn/" title="mrdear" target="_blank">mrdear</a></li><li class="list-item"><a href="https://draveness.me/" title="draveness" target="_blank">draveness</a></li></ul></div></div><div class="footer-top__item"><h3 class="item__title">构建工具</h3><div class="item__content"><ul class="footer-top__list"><li class="list-item"><a href="https://hexo.io/" title="Blog Framework" target="_blank">Hexo</a></li><li class="list-item"><a href="https://github.com/Mrminfive/hexo-theme-skapp" title="hexo-theme-skapp" target="_blank">hexo-theme-skapp</a></li></ul></div></div></div></section><section class="footer__bottom"><div class="page__container footer__container"><p class="footer__copyright">© <a href="https://github.com/Mrminfive/hexo-theme-skapp" target="_blank">Skapp</a> 2017 powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, made by <a href="https://github.com/Mrminfive" target="_blank">minfive</a>.</p><ul class="footer__social-network clearfix"><li class="social-network__item"><a href="https://github.com/dongzl" target="_blank" title="github"><i class="iconfont icon-github"></i></a></li><li class="social-network__item"><a href="mailto:dongzonglei@apache.org" target="_blank" title="email"><i class="iconfont icon-email"></i></a></li><li class="social-network__item"><a href="/atom.xml" target="_blank" title="rss"><i class="iconfont icon-rss"></i></a></li></ul></div></section></footer><div id="back-top" class="back-top back-top--hidden js-hidden"><i class="iconfont icon-top"></i></div></div><script src="/js/common.js"></script><script src="/js/page/post.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script src="/js/md5.min.js"></script><script>var tags=["Kafka"],gitalk=new Gitalk({clientID:"791785cb3bf7b9b5f1ea",clientSecret:"a73d2380b7dba08575e0190989ef017e480c20c9",repo:"dongzl.github.io",owner:"dongzl",admin:["dongzl"],labels:tags,id:new Date(1584363488e3).getTime()>new Date("2018-02-15").getTime()?md5(location.href):location.href});gitalk.render("comment-container")</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></body></html>