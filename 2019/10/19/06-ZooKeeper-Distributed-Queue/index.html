<!DOCTYPE html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">

    

    

    <title>从一个业务场景聊聊 ZooKeeper 队列使用 | 善积跬步 方以千里</title>
    <meta name="author" content="dongzl">
    <meta name="version" content="1.0.0">
    <meta name="keywords" content>
    <meta name="description" content="背景描述目前在做的 APP 客户端有个业务场景，对于登录的新用户需要做一些操作，例如初始化用户账户信息，给该新用户发放一些优惠，比如发放优惠券、赠送经验积分等等。对于这种场景一般很容易想到使用消息队列（MQ），但是考虑到目前的业务场景，每天新增的用户并不多，如果引入专门的消息队列框架（例如：RocketMQ、RabbitMQ）等感觉比较重，意义并不是很大。PS. 一句话需求，新增登录用户模块要实现功能解耦，用户登录与新用户业务逻辑功能分开，想到使用消息队列机制，但是不想引入重量级 MQ ...">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">

    
    <link rel="alternate" href="/atom.xml" title="善积跬步 方以千里" type="application/atom+xml">
    
    
    <link rel="icon" href="/images/favicon.ico">
    

    <link rel="stylesheet" href="/css/style.css"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>
<body>

    <!-- hexo-inject:begin --><!-- hexo-inject:end --><main class="app">
        <header class="header clearfix">
    <div id="nav" class="nav">
    <div class="nav-mobile">
        <button id="open-panel" class="open-panel nav-mobile-item"><i class="icon-documents"></i></button>
        <h1 class="nav-mobile-title nav-mobile-item">善积跬步 方以千里</h1>
        <button id="open-menus" class="open-panel nav-mobile-item"><i class="icon-library"></i></button>
    </div>

    <nav id="nav-inner" class="nav-inner">
        
            <a class="nav-item" href="/">
                <span class="nav-text">首页</span>
            </a>
        
            <a class="nav-item" href="/categories/java">
                <span class="nav-text">Java</span>
            </a>
        
            <a class="nav-item" href="/categories/web">
                <span class="nav-text">web</span>
            </a>
        
            <a class="nav-item" href="/categories/database">
                <span class="nav-text">数据库</span>
            </a>
        
            <a class="nav-item" href="/categories/data-structures-algorithms">
                <span class="nav-text">算法</span>
            </a>
        
            <a class="nav-item" href="/categories/architectural-design">
                <span class="nav-text">架构</span>
            </a>
        
            <a class="nav-item" href="/categories/design-pattern">
                <span class="nav-text">设计模式</span>
            </a>
        
            <a class="nav-item" href="/categories/other">
                <span class="nav-text">其他</span>
            </a>
        
            <a class="nav-item" href="/categories">
                <span class="nav-text">分类</span>
            </a>
        
            <a class="nav-item" href="/tags">
                <span class="nav-text">标签</span>
            </a>
        
            <a class="nav-item" href="/archives">
                <span class="nav-text">归档</span>
            </a>
        
            <a class="nav-item" href="/about">
                <span class="nav-text">关于</span>
            </a>
        
    </nav>
</div>

    <aside id="aside" class="aside">
    <div id="aside-mask" class="aside-mask"></div>
    <div id="aside-inner" class="aside-inner">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit"><i class="icon-search-stroke"></i></button><input type="hidden" name="sitesearch" value="https://dongzl.github.io"></form>

        
        
        
        

        
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#背景描述"><span class="toc-number">1.</span> <span class="toc-text">背景描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ZooKeeper-队列实现原理"><span class="toc-number">2.</span> <span class="toc-text">ZooKeeper 队列实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#生产者"><span class="toc-number">2.1.</span> <span class="toc-text">生产者</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#消费者"><span class="toc-number">2.2.</span> <span class="toc-text">消费者</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Curator-框架队列实现"><span class="toc-number">3.</span> <span class="toc-text">Curator 框架队列实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DistributedQueue"><span class="toc-number">3.1.</span> <span class="toc-text">DistributedQueue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DistributedIdQueue"><span class="toc-number">3.2.</span> <span class="toc-text">DistributedIdQueue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DistributedPriorityQueue"><span class="toc-number">3.3.</span> <span class="toc-text">DistributedPriorityQueue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DistributedDelayQueue"><span class="toc-number">3.4.</span> <span class="toc-text">DistributedDelayQueue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SimpleDistributedQueue"><span class="toc-number">3.5.</span> <span class="toc-text">SimpleDistributedQueue</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#系统实现"><span class="toc-number">4.</span> <span class="toc-text">系统实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#写在最后"><span class="toc-number">5.</span> <span class="toc-text">写在最后</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考文章"><span class="toc-number">6.</span> <span class="toc-text">参考文章</span></a></li></ol>
        
    </div>
</aside>

</header>

        <div id="content" class="content"><article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            从一个业务场景聊聊 ZooKeeper 队列使用
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="https://dongzl.github.io/2019/10/19/06-ZooKeeper-Distributed-Queue/index.html">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2019-10-19T09:03:49.000Z" itemprop="datePublished">2019-10-19</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/Curator/">Curator</a>, <a class="article-tag-link" href="/tags/Distributed-Queue/">Distributed Queue</a>, <a class="article-tag-link" href="/tags/ZooKeeper/">ZooKeeper</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h2 id="背景描述"><a href="#背景描述" class="headerlink" title="背景描述"></a>背景描述</h2><p>目前在做的 APP 客户端有个业务场景，对于登录的新用户需要做一些操作，例如初始化用户账户信息，给该新用户发放一些优惠，比如发放优惠券、赠送经验积分等等。对于这种场景一般很容易想到使用消息队列（MQ），但是考虑到目前的业务场景，每天新增的用户并不多，如果引入专门的消息队列框架（例如：RocketMQ、RabbitMQ）等感觉比较重，意义并不是很大。</p>
<p><strong>PS. 一句话需求，新增登录用户模块要实现功能解耦，用户登录与新用户业务逻辑功能分开，想到使用消息队列机制，但是不想引入重量级 MQ 框架。</strong></p>
<a id="more"></a>
<p>通过调研，发现利用 ZooKeeper + Curator 是可以实现分布式队列类似的效果的，同时预研使用 ZooKeepr + Curator 实现了该功能，这一篇文章对 ZooKeepr + Curator 实现队列机制的一个总结。</p>
<h2 id="ZooKeeper-队列实现原理"><a href="#ZooKeeper-队列实现原理" class="headerlink" title="ZooKeeper 队列实现原理"></a>ZooKeeper 队列实现原理</h2><h3 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h3><p>为了在 ZooKeeper 中实现分布式队列，需要设计一个 ZNode 节点来存放数据，这个节点是<code>队列节点</code>，例如：<code>/app_name/first_login_user</code>。生产者向队列中存放数据，每一个消息数据都是<code>队列节点</code>下的一个新节点，我们称作<code>消息节点</code>。消息节点的命名规则为：queue-xxxx，其中 xxxx 是一个单调递增序列，从 ZooKeeper 内部存储结构来说，其实就是创建<code>持久顺序（PERSISTENT_SEQUENTIAL）</code>类型节点来实现。这样，生产者不断的在队列节点下创建消息节点，消息节点数据存储为：queue-xxxx，这就是生产者端的实现原理。</p>
<h3 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h3><p>消费者从队列中获取数据是通过 <code>getChildren()</code> 方法获取到<code>队列节点</code>中的所有<code>消息节点</code>，然后获取消息节点中存储数据，处理业务逻辑，并删除<code>消息节点</code>。 如果 <code>getChildren()</code> 没有获取到节点数据，说明队列是空的，则消费者进入等待状态，同时调用 <code>getChildren()</code> 方法设置观察者监听队列节点，队列节点发生变化后（消息节点变更），触发监听事件，唤起消费者。</p>
<p><img src="https://raw.githubusercontent.com/dongzl/dongzl.github.io/hexo/blog/source/images/ZooKeeper-Distributed-Queue.png" width="600px"></p>
<h2 id="Curator-框架队列实现"><a href="#Curator-框架队列实现" class="headerlink" title="Curator 框架队列实现"></a>Curator 框架队列实现</h2><h3 id="DistributedQueue"><a href="#DistributedQueue" class="headerlink" title="DistributedQueue"></a>DistributedQueue</h3><blockquote>
<p>Distributed Queue - An implementation of the Distributed Queue ZK recipe. Items put into the queue are guaranteed to be ordered (by means of ZK’s PERSISTENTSEQUENTIAL node). If a single consumer takes items out of the queue, they will be ordered FIFO. If ordering is important, use a LeaderSelector to nominate a single consumer.</p>
</blockquote>
<p><code>Distributed Queue - ZK 的 分布式队列实现。添加到队列中的元素是可以保证顺序性的（通过 ZK 的 PERSISTENT SEQUENTIAL 节点类型实现）。如果只有单一消费者从队列中获取元素，可以保证以 FIFO 顺序消费元素。如果顺序性是非常重要的，可以通过 LeaderSelector 方式只选举出一个消费者。</code></p>
<p>数据存储格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">queue-0000000001</span><br><span class="line">queue-0000000002</span><br><span class="line">queue-0000000003</span><br><span class="line">queue-0000000004</span><br><span class="line">... ...</span><br><span class="line">queue-0000000098</span><br><span class="line">queue-0000000099</span><br><span class="line">queue-0000000100</span><br></pre></td></tr></table></figure></p>
<p>使用方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 核心类</span></span><br><span class="line">org.apache.curator.framework.recipes.queue.DistributedQueue;</span><br><span class="line">org.apache.curator.framework.recipes.queue.QueueBuilder;</span><br><span class="line">org.apache.curator.framework.recipes.queue.QueueConsumer;</span><br><span class="line">org.apache.curator.framework.recipes.queue.QueueSerializer;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Builder 实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">QueueBuilder&lt;T&gt; <span class="title">builder</span><span class="params">(CuratorFramework client, QueueConsumer&lt;T&gt; consumer, QueueSerializer&lt;T&gt; serializer, String queuePath)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parameters:</span><br><span class="line">   client - Curator 客户端</span><br><span class="line">   consumer - 接收消息消费者</span><br><span class="line">   serializer - 元素序列化工具</span><br><span class="line">   queuePath - 存储队列数据路径</span><br><span class="line"></span><br><span class="line"><span class="comment">// DistributedQueue 实现</span></span><br><span class="line">DistributedQueue&lt;String&gt; queue = QueueBuilder.builder(client, consumer, createQueueSerializer(), PATH).buildQueue();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者</span></span><br><span class="line">queue.put(aMessage);</span><br></pre></td></tr></table></figure>
<h3 id="DistributedIdQueue"><a href="#DistributedIdQueue" class="headerlink" title="DistributedIdQueue"></a>DistributedIdQueue</h3><blockquote>
<p>Distributed Id Queue - A version of DistributedQueue that allows IDs to be associated with queue items. Items can then be removed from the queue if needed.</p>
</blockquote>
<p><code>Distributed Id Queue - 允许 ID 与队列元素关联的 DistributedQueue 版本实现。如果有需要可以根据 ID 删除元素。</code></p>
<p>数据存储格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">queue-|id-1|0000000001</span><br><span class="line">queue-|id-2|0000000002</span><br><span class="line">queue-|id-3|0000000003</span><br><span class="line">queue-|id-4|0000000004</span><br><span class="line">... ...</span><br><span class="line">queue-|id-98|0000000098</span><br><span class="line">queue-|id-99|0000000099</span><br><span class="line">queue-|id-100|0000000100</span><br><span class="line"></span><br><span class="line">数据格式：</span><br><span class="line">queue-|itemId|节点顺序</span><br></pre></td></tr></table></figure></p>
<p>使用方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 核心类</span></span><br><span class="line">org.apache.curator.framework.recipes.queue.DistributedIdQueue;</span><br><span class="line">org.apache.curator.framework.recipes.queue.QueueBuilder;</span><br><span class="line">org.apache.curator.framework.recipes.queue.QueueConsumer;</span><br><span class="line">org.apache.curator.framework.recipes.queue.QueueSerializer;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DistributedIdQueue 实现</span></span><br><span class="line">DistributedIdQueue&lt;String&gt; queue = QueueBuilder.builder(client, consumer, createQueueSerializer(), PATH).buildIdQueue();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者</span></span><br><span class="line">queue.put(aMessage, itemId);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以根据 itemId 移除元素</span></span><br><span class="line"><span class="keyword">int</span> numberRemoved = queue.remove(itemId);</span><br></pre></td></tr></table></figure>
<h3 id="DistributedPriorityQueue"><a href="#DistributedPriorityQueue" class="headerlink" title="DistributedPriorityQueue"></a>DistributedPriorityQueue</h3><blockquote>
<p>Distributed Priority Queue - An implementation of the Distributed Priority Queue ZK recipe.</p>
</blockquote>
<p><code>Distributed Priority Queue - 分布式优先级队列的 ZK 实现。</code></p>
<p>数据存储格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">queue-10000001F0000000001</span><br><span class="line">queue-1000000140000000002</span><br><span class="line">queue-10000004F0000000003</span><br><span class="line">queue-10000000F0000000004</span><br><span class="line">... ...</span><br><span class="line">queue-1000000570000000098</span><br><span class="line">queue-10000003C0000000099</span><br><span class="line">queue-10000003C0000000100</span><br><span class="line"></span><br><span class="line">数据格式：</span><br><span class="line">queue-(priority &gt;= 0 ? &quot;1&quot; : &quot;0&quot;) + [(priority &amp; 4294967295L) 16进制] + 节点顺序</span><br></pre></td></tr></table></figure></p>
<p>使用方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 核心类</span></span><br><span class="line">org.apache.curator.framework.recipes.queue.DistributedPriorityQueue;</span><br><span class="line">org.apache.curator.framework.recipes.queue.QueueBuilder;</span><br><span class="line">org.apache.curator.framework.recipes.queue.QueueConsumer;</span><br><span class="line">org.apache.curator.framework.recipes.queue.QueueSerializer;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DistributedPriorityQueue 实现</span></span><br><span class="line">DistributedPriorityQueue&lt;String&gt; queue = QueueBuilder.builder(client, consumer, createQueueSerializer(), PATH).buildPriorityQueue(minItemsBeforeRefresh);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者</span></span><br><span class="line">queue.put(aMessage, priority);</span><br></pre></td></tr></table></figure>
<h3 id="DistributedDelayQueue"><a href="#DistributedDelayQueue" class="headerlink" title="DistributedDelayQueue"></a>DistributedDelayQueue</h3><blockquote>
<p>Distributed Delay Queue - An implementation of a Distributed Delay Queue.</p>
</blockquote>
<p><code>Distributed Delay Queue - 分布式延迟队列实现。</code></p>
<p>数据存储格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">queue-|16DE33C4F8D|0000000001</span><br><span class="line">queue-|16DE33C4F8D|0000000002</span><br><span class="line">queue-|16DE33C4F8D|0000000003</span><br><span class="line">queue-|16DE33C4F8D|0000000004</span><br><span class="line">... ...</span><br><span class="line">queue-|16DE33C4F8E|0000000098</span><br><span class="line">queue-|16DE33C4F8E|0000000099</span><br><span class="line">queue-|16DE33C4F8E|0000000100</span><br><span class="line"></span><br><span class="line">数据格式：</span><br><span class="line">queue-|delayUntilEpoch 8位16进制|节点顺序</span><br></pre></td></tr></table></figure></p>
<p>使用方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 核心类</span></span><br><span class="line">org.apache.curator.framework.recipes.queue.DistributedPriorityQueue;</span><br><span class="line">org.apache.curator.framework.recipes.queue.QueueBuilder;</span><br><span class="line">org.apache.curator.framework.recipes.queue.QueueConsumer;</span><br><span class="line">org.apache.curator.framework.recipes.queue.QueueSerializer;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DistributedPriorityQueue 实现</span></span><br><span class="line">DistributedDelayQueue&lt;String&gt; queue = QueueBuilder.builder(client, consumer, createQueueSerializer(), PATH).buildDelayQueue();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者</span></span><br><span class="line">queue.put(aMessage, delayUntilEpoch);</span><br></pre></td></tr></table></figure>
<h3 id="SimpleDistributedQueue"><a href="#SimpleDistributedQueue" class="headerlink" title="SimpleDistributedQueue"></a>SimpleDistributedQueue</h3><blockquote>
<p>Simple Distributed Queue - A drop-in replacement for the DistributedQueue that comes with the ZK distribution.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 核心类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SimpleDistributedQueue</span><span class="params">(CuratorFramework client, String path)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 入队</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(<span class="keyword">byte</span>[] data)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 出队，移除头部元素并返回该元素，会阻塞。</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">byte</span>[] <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span></span><br></pre></td></tr></table></figure>
<h2 id="系统实现"><a href="#系统实现" class="headerlink" title="系统实现"></a>系统实现</h2><p>业务系统中是采用 <code>DistributedQueue</code> 的实现，首先在用户登录成功后向 ZooKeeper 的固定节点下写入 <code>PERSISTENT_SEQUENTIAL</code> 数据，写入后直接返回，不阻塞用户登录操作；在另外的线程中消费 <code>DistributedQueue</code> 队列中数据，直接按顺序获取节点数据，开始进行业务逻辑处理。</p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>对于使用 ZooKeeper 实现的分布式消息队列，需要注意一些问题。首先，对于使用 ZooKeeper 实现的队列这件事情本身，Curator 的官方文档就是不推荐的：</p>
<p><strong>IMPORTANT - We recommend that you do NOT use ZooKeeper for Queues. Please see <a href="https://cwiki.apache.org/confluence/display/CURATOR/TN4" target="_blank" rel="noopener">Tech Note 4</a> for details.</strong></p>
<p>ZooKeeper 的使用手册页面列举了一些 ZooKeeper 作为队列的使用场景。Curator 包括了几种队列的实现方式，以我们的经验，使用 ZooKeeper 作为消息队列是一个糟糕的选择：</p>
<ul>
<li>ZooKeeper 有 1MB 的传输限制。 实践中 ZNode 必须相对较小，而队列包含成千上万的消息，可能非常的大；</li>
<li>如果有很多节点，ZooKeeper 启动时相当的慢。而使用队列需要创建很多 ZNode 节点，所以在使用中需要显著调大 initLimit 和 syncLimit 参数值；</li>
<li>当某个 ZNode 很大的时候会很难清理，同时调用这个节点的 <code>getChildren()</code> 方法会失败；</li>
<li>当出现大量的包含成千上万的子节点的 ZNode 时，ZooKeeper 的性能会急剧下降；</li>
<li>ZooKeeper 的数据完全存放在内存中，如果有大量的队列消息会占用很多的内存空间。</li>
</ul>
<p>虽然从官方文档上来看，并不推荐使用 ZooKeeper 作为消息队列载体，但这是在大量消息的队列使用场景下，对于小规模的队列场景，例如我们新登录用户场景，一天也就几百个消息，其实也是没有问题的，之所谓<code>一切脱离业务谈技术架构都是耍流氓</code>。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="https://ifeve.com/zookeeper%EF%BC%8Dcurator/" target="_blank" rel="noopener">跟着实例学习ZooKeeper的用法： 队列</a></li>
<li><a href="https://www.cnblogs.com/boboooo/p/9259306.html" target="_blank" rel="noopener">Zookeeper应用之——队列（Queue）</a></li>
<li><a href="http://curator.apache.org/curator-recipes/index.html" target="_blank" rel="noopener">Curator - Recipes</a></li>
</ul>

        
    </section>
</article>



<div class="comments">
    <div id="comments"></div>
    <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
    <script>
    new Gitalk({
        clientID: "791785cb3bf7b9b5f1ea",
        clientSecret: "a73d2380b7dba08575e0190989ef017e480c20c9",
        repo: "dongzl.github.io",
        owner: "dongzl",
        admin: ["dongzl"],
        id: "2019/10/19/06-ZooKeeper-Distributed-Queue",
        distractionFreeMode: true,
        title: "从一个业务场景聊聊 ZooKeeper 队列使用",
        body: "https://dongzl.github.io/2019/10/19/06-ZooKeeper-Distributed-Queue/",
        labels: ["ZooKeeper","Curator","Distributed Queue"]
    }).render('comments');
    </script>
</div>

</div>
        <footer class="footer">
    Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, Theme by <a href="https://github.com/sanonz/hexo-theme-concise" target="_blank">Concise</a>

    
    <script>
        var _hmt = _hmt || [];
        (function () {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm.js?e4027971a230b210f4671f485b33846a";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();
    </script>
    
</footer>


  <script src="https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js"></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({theme: 'forest'});
    }
  </script>

    </main>

    <script type="text/javascript" src="https://cdn.bootcss.com/jquery/1.9.0/jquery.min.js"></script>
    <script type="text/javascript">
    $(function() {
        var nodes = {
            nav: $('#nav'),
            aside: $('#aside'),
            asideInner: $('#aside-inner'),
            navInner: $('#nav-inner')
        };

        var doing = false;
        nodes.asideInner.on('webkitAnimationEnd mozAnimationEnd oAnimationEnd oanimationend animationend', function() {
            if (nodes.aside.hasClass('mobile-open')) {
                nodes.aside.removeClass('mobile-open');
            } else {
                nodes.aside.removeClass('mobile-close panel-show');
            }
            doing = false;
        });
        $('#open-panel, #aside-mask').on('click', function() {
            if (doing) {
                return;
            }
            
            if (nodes.aside.hasClass('panel-show')) {
                nodes.aside.addClass('mobile-close');
            } else {
                nodes.aside.addClass('mobile-open panel-show');
            }
        });
        $('#open-menus').on('click', function() {
            nodes.navInner.slideToggle();
        });

        if (window.innerWidth <= 960) {
            setTimeout(function() {
                nodes.navInner.slideUp();
            }, 3000);
        }
    });
    </script>
    
        <script type="text/javascript" src="/js/scrollspy.min.js"></script>
        <script type="text/javascript">
        $(document.body).scrollspy({target: '#aside-inner'});
        </script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
    

</body>
</html>
