<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>董宗磊的博客</title>
  
  <subtitle>董宗磊的博客--善积跬步，方以千里</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://dongzl.github.io/"/>
  <updated>2020-03-22T14:27:12.465Z</updated>
  <id>https://dongzl.github.io/</id>
  
  <author>
    <name>[object Object]</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redis 面试常见问题知识点总结</title>
    <link href="https://dongzl.github.io/2020/03/22/18-Redis-Interview-knowledge/"/>
    <id>https://dongzl.github.io/2020/03/22/18-Redis-Interview-knowledge/</id>
    <published>2020-03-22T13:24:37.000Z</published>
    <updated>2020-03-22T14:27:12.465Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景描述"><a href="#背景描述" class="headerlink" title="背景描述"></a>背景描述</h2><p>在面试过程中，<code>缓存雪崩</code>、<code>缓存穿透</code>、<code>缓存击穿</code>、<code>分布式锁</code> 等问题是 Redis 的常见问题，本文根据 <a href="http://www.mashibing.com/" target="_blank" rel="noopener">马士兵教育</a> 公开课内容整理而成，主要总结了上述面试题一些回答思路。</p><h2 id="总结内容"><a href="#总结内容" class="headerlink" title="总结内容"></a>总结内容</h2><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>Redis 中的热点数据集中过期导致 MySQL 在某一时刻承受很大的压力，也有可能是因为 Redis 服务器宕机所致。</p><ul><li><p>数据集中过期：在数据过期时间后加上一个随机值，不要让数据同时过期；</p></li><li><p>Redis 宕机问题：a、设置多级缓存，b、搭建 Redis 集群，防止单点问题。</p></li></ul><img src="https://gitee.com/dongzl/article-images/raw/master/2020/18-Redis-Interview-knowledge/Redis-Interview-knowledge-01.jpg"><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>如果客户端发送的请求，查询的数据，在 Redis 中都查不到，那么缓存就失去意义了。这种情况多数是由恶意用户伪造请求参数，导致 Redis 缓存查不到数据而失效。</p><ul><li>BloomFilter（布隆过滤器）；</li><li>使用分布式锁解决缓存穿透，对于缓存中不存在的数据，在访问 MySQL 数据库时需要抢占分布式锁。</li></ul><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>Redis 中有一条热点数据，过期之后，MySQL 承接了大量的请求。</p><p>一般这种情况在实际工作中出现较少，很少会只有一条热点数据。</p><img src="https://gitee.com/dongzl/article-images/raw/master/2020/18-Redis-Interview-knowledge/Redis-Interview-knowledge-03.jpg"><h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><p>Redis 实现分布式锁的一些问题：</p><ul><li><p>死锁 –&gt; 有过期时间 –&gt; 乱入锁 –&gt; 增大有效期时间 –&gt; 效率低，吞吐量下降；</p></li><li><p>资源浪费。</p></li></ul><img src="https://gitee.com/dongzl/article-images/raw/master/2020/18-Redis-Interview-knowledge/Redis-Interview-knowledge-02.png">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景描述&quot;&gt;&lt;a href=&quot;#背景描述&quot; class=&quot;headerlink&quot; title=&quot;背景描述&quot;&gt;&lt;/a&gt;背景描述&lt;/h2&gt;&lt;p&gt;在面试过程中，&lt;code&gt;缓存雪崩&lt;/code&gt;、&lt;code&gt;缓存穿透&lt;/code&gt;、&lt;code&gt;缓存击穿&lt;/code&gt;、&lt;
      
    
    </summary>
    
    
      <category term="架构设计" scheme="https://dongzl.github.io/categories/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="缓存雪崩" scheme="https://dongzl.github.io/tags/%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9/"/>
    
      <category term="缓存穿透" scheme="https://dongzl.github.io/tags/%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F/"/>
    
      <category term="缓存击穿" scheme="https://dongzl.github.io/tags/%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF/"/>
    
  </entry>
  
  <entry>
    <title>BloomFilter 实现原理及使用</title>
    <link href="https://dongzl.github.io/2020/03/21/17-Bloom-Filter-Summary/"/>
    <id>https://dongzl.github.io/2020/03/21/17-Bloom-Filter-Summary/</id>
    <published>2020-03-21T13:10:04.000Z</published>
    <updated>2020-03-22T14:37:53.486Z</updated>
    
    <content type="html"><![CDATA[<h2 id="布隆过滤器介绍"><a href="#布隆过滤器介绍" class="headerlink" title="布隆过滤器介绍"></a>布隆过滤器介绍</h2><p>布隆过滤器（Bloom Filter）由 <code>Burton Howard Bloom</code> 在 1970 年提出，是一种空间效率高的概率型数据结构。它专门用来检测集合中是否存在特定的元素。其实对于判断集合中是否存在某个元素，我们平时都会直接使用比较算法，例如：</p><ul><li>如果集合用线性表存储，查找的时间复杂度为 O(n)；</li><li>如果用平衡 BST（如 AVL树、红黑树）存储，时间复杂度为 O(logn)；</li><li>如果用哈希表存储，并用链地址法与平衡 BST 解决哈希冲突（参考 JDK8 的 HashMap 实现方法），时间复杂度也要有O[log(n/m)]，m 为哈希分桶数。</li></ul><img src="https://gitee.com/dongzl/article-images/raw/master/2020/17-Bloom-Filter-Summary/Bloom-Filter-Summary-01.png"><p>如果采用上面提到的一些方法，需要将实际数据都要存储到集合中，才能真正判断元素是否存在，会占用很大的内存空间，而且对于上面计算的时间复杂度，如果集合中元素非常多时，查找效率并不高。Bloom Filter 就是为了解决这些问题应运而生的。</p><h2 id="Bloom-Filter-设计思想"><a href="#Bloom-Filter-设计思想" class="headerlink" title="Bloom Filter 设计思想"></a>Bloom Filter 设计思想</h2><p>Bloom Filter 是由一个长度为 m 的比特位数组（bit array）与 k 个哈希函数（hash function）组成的数据结构。位数组均初始化为 0，所有哈希函数都可以分别把输入数据尽量均匀地散列。</p><p>当要插入一个元素时，将其数据分别输入 k 个哈希函数，产生 k 个哈希值。以哈希值作为位数组中的下标，将所有 k 个对应的比特置为 1。</p><p>当要查询（即判断是否存在）一个元素时，同样将其数据输入哈希函数，然后检查对应的 k 个比特。如果有任意一个比特为 0，表明该元素一定不在集合中。如果所有比特均为 1，表明该元素有（较大的）可能性在集合中。为什么不是一定在集合中呢？因为一个比特被置为 1 有可能会受到其他元素的影响，这就是所谓“假阳性”（false positive）。相对地，“假阴性”（false negative）在 Bloom Filter 中是绝不会出现的。</p><p>下图示出一个 m=18, k=3 的 Bloom Filter 示例。集合中的 x、y、z 三个元素通过 3 个不同的哈希函数散列到位数组中。当查询元素 w 时，因为有一个比特为0，因此 w 不在该集合中。</p><img src="https://gitee.com/dongzl/article-images/raw/master/2020/17-Bloom-Filter-Summary/Bloom-Filter-Summary-02.png"><h2 id="Bloom-Filter-的优缺点与用途"><a href="#Bloom-Filter-的优缺点与用途" class="headerlink" title="Bloom Filter 的优缺点与用途"></a>Bloom Filter 的优缺点与用途</h2><p><strong>优点：</strong></p><ul><li>不需要存储数据本身，只用比特表示，因此空间占用相对于传统方式有巨大的优势，并且能够保密数据；</li><li>时间效率也较高，插入和查询的时间复杂度均为O(k)；</li><li>哈希函数之间相互独立，可以在硬件指令层面并行计算。</li></ul><p><strong>缺点：</strong></p><ul><li>存在假阳性的概率，不适用于任何要求 100% 准确率的场景；</li><li>只能插入和查询元素，不能删除元素，这与产生假阳性的原因是相同的。我们可以简单地想到通过计数（即将一个比特扩展为计数值）来记录元素数，但仍然无法保证删除的元素一定在集合中。</li></ul><p>所以，Bloom Filter 在对查准度要求没有那么苛刻，而对时间、空间效率要求较高的场合非常合适，本文第一句话提到的用途即属于此类。另外，由于它不存在 <strong>假阴性</strong> 问题，所以用作“不存在”逻辑的处理时有奇效，比如可以用来作为 <strong>缓存系统（如Redis）的缓冲，防止缓存穿透</strong>。</p><h2 id="Google-Guava-中-Bloom-Filter-的使用"><a href="#Google-Guava-中-Bloom-Filter-的使用" class="headerlink" title="Google Guava 中 Bloom Filter 的使用"></a>Google Guava 中 Bloom Filter 的使用</h2><blockquote><p>A Bloom filter offers an approximate containment test with one-sided error: if it claims that an element is contained in it, this might be in error, but if it claims that an element is <i>not</i> contained in it, then this is definitely true.</p></blockquote><blockquote><p>Bloom filter 提供了一个单方面错误的近似包含测试：如果它声称某个元素包含在其中，则这可能是错误的（可能不包含在其中）；但是如果它声称某个元素不包含在其中，那这一定是正确的（一定不包含在其中）。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.common.hash.BloomFilter;</span><br><span class="line"><span class="keyword">import</span> com.google.common.hash.Funnels;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BloomFilterTest</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BloomFilter&lt;String&gt; filter = BloomFilter.create(Funnels.stringFunnel(Charset.forName(<span class="string">"utf-8"</span>)), <span class="number">1000</span>, <span class="number">0.000001</span>);</span><br><span class="line">        filter.put(<span class="string">"java"</span>);</span><br><span class="line">        filter.put(<span class="string">"c++"</span>);</span><br><span class="line">        filter.put(<span class="string">"python"</span>);</span><br><span class="line">        System.out.println(filter.mightContain(<span class="string">"php"</span>));</span><br><span class="line">        BloomFilter&lt;String&gt; filter2 = BloomFilter.create(Funnels.stringFunnel(Charset.forName(<span class="string">"utf-8"</span>)), <span class="number">1000</span>, <span class="number">0.000001</span>);</span><br><span class="line">        filter2.put(<span class="string">"go"</span>);</span><br><span class="line">        filter2.put(<span class="string">"rust"</span>);</span><br><span class="line">        filter2.put(<span class="string">"c"</span>);</span><br><span class="line">        filter2.putAll(filter);</span><br><span class="line">        System.out.println(filter2.mightContain(<span class="string">"java"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Redis-中-Bloom-Filter-的使用"><a href="#Redis-中-Bloom-Filter-的使用" class="headerlink" title="Redis 中 Bloom Filter 的使用"></a>Redis 中 Bloom Filter 的使用</h2><p>Redis 中使用 BloomFilter 需要安装 <a href="https://github.com/RedisBloom" target="_blank" rel="noopener">RedisBloom</a> 插件，下载源码编译后生成一个 <code>rebloom.so</code> 文件，然后需要在在 Redis 的配置文件 <code>redis.conf</code> 中加入该模块即可:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loadmodule /$&#123;path&#125;/rebloom.so</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bf.add test 1</span><br><span class="line">bf.add test 2</span><br><span class="line">bf.exists test 2</span><br><span class="line">bf.exists test 3</span><br></pre></td></tr></table></figure><p>关于 <code>RedisBloom</code> 的详细说明可以参考文档：<a href="https://oss.redislabs.com/redisbloom/" target="_blank" rel="noopener">RedisBloom - Probabilistic Datatypes Module for Redis</a></p><p>Redis BloomFilter 在 java 中的应用，可以使用 <code>jrebloom-${version}.jar</code> jar 包中提供的功能：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.redislabs<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jrebloom<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.rebloom.client.Client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisBloomFilterTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Client client = <span class="keyword">new</span> Client(<span class="string">"192.168.202.121"</span>, <span class="number">6395</span>);</span><br><span class="line">        client.add(<span class="string">"test"</span>, <span class="string">"1"</span>);</span><br><span class="line">        client.add(<span class="string">"test"</span>, <span class="string">"2"</span>);</span><br><span class="line">        System.out.println(client.exists(<span class="string">"test"</span>, <span class="string">"2"</span>));</span><br><span class="line">        System.out.println(client.exists(<span class="string">"test"</span>, <span class="string">"3"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="row">    <embed src="https://gitee.com/dongzl/article-images/raw/master/2020/17-Bloom-Filter-Summary/Bloom-Filter-Summary-03.pdf" width="100%" height="550" type="application/pdf"></div><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://llimllib.github.io/bloomfilter-tutorial/" target="_blank" rel="noopener">Bloom Filters by Example</a></li><li><a href="https://www.jianshu.com/p/bef2ec1c361f" target="_blank" rel="noopener">布隆过滤器（Bloom Filter）原理及 Guava 中的具体实现</a></li><li><a href="https://oss.redislabs.com/redisbloom/" target="_blank" rel="noopener">RedisBloom - Probabilistic Datatypes Module for Redis</a></li><li><a href="https://www.cnblogs.com/heihaozi/p/12174478.html" target="_blank" rel="noopener">详细解析Redis中的布隆过滤器及其应用</a></li><li><a href="https://baijiahao.baidu.com/s?id=1655304940308056733&wfr=spider&for=pc" target="_blank" rel="noopener">帮你解读什么是Redis缓存穿透和缓存雪崩（包含解决方案）</a></li><li><a href="https://blog.csdn.net/ChenMMo/article/details/93615438" target="_blank" rel="noopener">Redis安装布隆过滤器插件 bloomfilter</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;布隆过滤器介绍&quot;&gt;&lt;a href=&quot;#布隆过滤器介绍&quot; class=&quot;headerlink&quot; title=&quot;布隆过滤器介绍&quot;&gt;&lt;/a&gt;布隆过滤器介绍&lt;/h2&gt;&lt;p&gt;布隆过滤器（Bloom Filter）由 &lt;code&gt;Burton Howard Bloom&lt;/co
      
    
    </summary>
    
    
      <category term="架构设计" scheme="https://dongzl.github.io/categories/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="Redis" scheme="https://dongzl.github.io/tags/Redis/"/>
    
      <category term="BloomFilter" scheme="https://dongzl.github.io/tags/BloomFilter/"/>
    
      <category term="Guava" scheme="https://dongzl.github.io/tags/Guava/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 数据库 Lock 知识总结</title>
    <link href="https://dongzl.github.io/2020/03/19/16-MySQL-Lock-Summary/"/>
    <id>https://dongzl.github.io/2020/03/19/16-MySQL-Lock-Summary/</id>
    <published>2020-03-19T14:13:22.000Z</published>
    <updated>2020-03-19T14:49:53.671Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MySQL-中锁的基本知识"><a href="#MySQL-中锁的基本知识" class="headerlink" title="MySQL 中锁的基本知识"></a>MySQL 中锁的基本知识</h2><p><strong>锁是计算机协调多个进程或线程并发访问某一资源的机制。</strong> 在数据库中，除传统的计算资源（如 CPU、RAM、I/O 等）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。</p><p>​相对其他数据库而言，MySQL 的锁机制比较简单，其最显著的特点是不同的 <strong>存储引擎</strong> 支持不同的锁机制。比如，MyISAM 和 MEMORY 存储引擎采用的是表级锁（table-level locking）；InnoDB 存储引擎既支持行级锁（row-level locking），也支持表级锁，但默认情况下是采用行级锁。</p><ul><li><p><strong>表级锁</strong>：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低； </p></li><li><p><strong>行级锁</strong>：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。  </p></li></ul><p>​从上述特点可见，很难笼统地说哪种锁更好，只能就具体应用的特点来说哪种锁更合适。仅从锁的角度来说：<strong>表级锁</strong>更适合于以查询为主，只有少量按索引条件更新数据的应用，如Web应用；而<strong>行级锁</strong>则更适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用，如一些在线事务处理（OLTP）系统。 </p><h2 id="MySQL-中锁的分类"><a href="#MySQL-中锁的分类" class="headerlink" title="MySQL 中锁的分类"></a>MySQL 中锁的分类</h2><ul><li><p>共享锁：Shared Locks（简称 S 锁，属于行锁）</p></li><li><p>排他锁：Exclusive Locks（简称 X 锁，属于行锁）</p></li><li><p>意向共享锁：Intention Shared Locks（简称 IS 锁，属于表锁）</p></li><li><p>意向排他锁：Intention Exclusive Locks（简称 IX 锁，属于表锁）</p></li><li><p>自增锁 AUTO-INC Locks</p></li></ul><h3 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h3><p>共享锁就是多个事务对于同一数据可以共享一把锁，都能访问到数据库，但是只能读不能修改；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#事务A：</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span> <span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share</span> <span class="keyword">mode</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#事务B:</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span>; <span class="comment">--(读取数据没问题)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#事务B:</span></span><br><span class="line"><span class="keyword">update</span> student <span class="keyword">set</span> <span class="keyword">name</span>=<span class="string">'hehe'</span> <span class="keyword">where</span> <span class="keyword">id</span>  =<span class="number">1</span>;</span><br><span class="line"><span class="comment">--注意：无法修改会卡死，当事务A提交事务之后，会立刻修改成功</span></span><br></pre></td></tr></table></figure><h3 id="排他锁"><a href="#排他锁" class="headerlink" title="排他锁"></a>排他锁</h3><p>排它锁不能与其他锁并存，如一个事务获取了一个数据行的排它锁，其他事务就不能再获取改行的锁，只有当前获取了排它锁的事务可以对数据进行读取和修改。<code>delete、update、insert</code> 默认是排他锁：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#事务A:</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#事务B:</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span> <span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share</span> <span class="keyword">mode</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 注意：事务B操作的时候回卡死，提交事务立马成功。</span></span><br></pre></td></tr></table></figure><h3 id="意向共享锁和意向排他锁"><a href="#意向共享锁和意向排他锁" class="headerlink" title="意向共享锁和意向排他锁"></a>意向共享锁和意向排他锁</h3><ul><li><p>意向共享锁：表示事务准备给数据行加入共享锁，也就是说一个数据行在加共享锁之前必须先取得该表的 IS 锁;</p></li><li><p>意向排他锁：表示事务准备给数据行加入排它锁，也就是说一个数据行加排它锁之前必须先取得该表的 IX 锁。</p></li></ul><p><strong>PS. 意向锁是InnoDB数据操作之前自动加的，不需要用户干预。</strong></p><h3 id="自增锁"><a href="#自增锁" class="headerlink" title="自增锁"></a>自增锁</h3><p>针对自增列自增长的一个特殊的表级别锁</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">VARIABLES</span> <span class="keyword">LIKE</span> <span class="string">'innodb_autoinc_lock_mode'</span>;</span><br><span class="line"><span class="comment">--默认值1 代表连续，事务未提交则id永久丢失</span></span><br></pre></td></tr></table></figure><h2 id="MyISAM-表锁"><a href="#MyISAM-表锁" class="headerlink" title="MyISAM 表锁"></a>MyISAM 表锁</h2><p>MySQL 的表级锁有两种模式：<strong>表共享读锁（Table Read Lock）</strong>和<strong>表独占写锁（Table Write Lock）</strong>。  </p><p>对 MyISAM 表的读操作，不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写请求；对 MyISAM 表的写操作，则会阻塞其他用户对同一表的读和写操作；MyISAM 表的读操作与写操作之间，以及写操作之间是串行的！ </p><p>建表语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`mylock`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`NAME`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=MyISAM <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`mylock`</span> (<span class="string">`id`</span>, <span class="string">`NAME`</span>) <span class="keyword">VALUES</span> (<span class="string">'1'</span>, <span class="string">'a'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`mylock`</span> (<span class="string">`id`</span>, <span class="string">`NAME`</span>) <span class="keyword">VALUES</span> (<span class="string">'2'</span>, <span class="string">'b'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`mylock`</span> (<span class="string">`id`</span>, <span class="string">`NAME`</span>) <span class="keyword">VALUES</span> (<span class="string">'3'</span>, <span class="string">'c'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`mylock`</span> (<span class="string">`id`</span>, <span class="string">`NAME`</span>) <span class="keyword">VALUES</span> (<span class="string">'4'</span>, <span class="string">'d'</span>);</span><br></pre></td></tr></table></figure><p><strong>MyISAM写锁阻塞读的案例：</strong></p><p>​当一个线程获得对一个表的写锁之后，只有持有锁的线程可以对表进行更新操作。其他线程的读写操作都会等待，直到锁释放为止。</p><table><thead><tr><th align="center">session1</th><th align="center">session2</th></tr></thead><tbody><tr><td align="center">获取表的write锁定<br>lock table mylock write;</td><td align="center"></td></tr><tr><td align="center">当前session对表的查询，插入，更新操作都可以执行<br>select * from mylock;<br>insert into mylock values(5,’e’);</td><td align="center">当前session对表的查询会被阻塞<br>select * from mylock；</td></tr><tr><td align="center">释放锁：<br>unlock tables；</td><td align="center">当前session能够立刻执行，并返回对应结果</td></tr></tbody></table><p><strong>MyISAM读阻塞写的案例：</strong></p><p>一个 session 使用 <code>lock table</code> 给表加读锁，这个 session 可以锁定表中的记录，但更新和访问其他表都会提示错误，同时，另一个 session 可以查询表中的记录，但更新就会出现锁等待。</p><table><thead><tr><th align="center">session1</th><th align="center">session2</th></tr></thead><tbody><tr><td align="center">获得表的read锁定<br>lock table mylock read;</td><td align="center"></td></tr><tr><td align="center">当前session可以查询该表记录：<br>select * from mylock;</td><td align="center">当前session可以查询该表记录：<br>select * from mylock;</td></tr><tr><td align="center">当前session不能查询没有锁定的表<br>select * from person<br>Table ‘person’ was not locked with LOCK TABLES</td><td align="center">当前session可以查询或者更新未锁定的表<br>select * from person<br>insert into person values(1,’zhangsan’);</td></tr><tr><td align="center">当前session插入或者更新表会提示错误<br>insert into mylock values(6,’f’)<br>Table ‘mylock’ was locked with a READ lock and can’t be updated<br>update mylock set name=’aa’ where id = 1;<br>Table ‘mylock’ was locked with a READ lock and can’t be updated</td><td align="center">当前session插入数据会等待获得锁<br>insert into mylock values(6,’f’);</td></tr><tr><td align="center">释放锁<br>unlock tables;</td><td align="center">获得锁，更新成功</td></tr></tbody></table><p><strong>注意：MyISAM 在执行查询语句之前，会自动给涉及的所有表加读锁，在执行更新操作前，会自动给涉及的表加写锁，这个过程并不需要用户干预，因此用户一般不需要使用命令来显式加锁，上例中的加锁时为了演示效果。</strong></p><p><strong>MyISAM 的并发插入问题：</strong></p><p>MyISAM 表的读和写是串行的，这是就总体而言的，在一定条件下，MyISAM 也支持查询和插入操作的并发执行</p><table><thead><tr><th align="center">session1</th><th align="center">session2</th></tr></thead><tbody><tr><td align="center">获取表的read local锁定<br>lock table mylock read local</td><td align="center"></td></tr><tr><td align="center">当前session不能对表进行更新或者插入操作<br>insert into mylock values(6,’f’)<br>Table ‘mylock’ was locked with a READ lock and can’t be updated<br>update mylock set name=’aa’ where id = 1;<br>Table ‘mylock’ was locked with a READ lock and can’t be updated</td><td align="center">其他session可以查询该表的记录<br>select* from mylock</td></tr><tr><td align="center">当前session不能查询没有锁定的表<br>select * from person<br>Table ‘person’ was not locked with LOCK TABLES</td><td align="center">其他session可以进行<font color="red">插入</font>操作，但是<font color="red">更新</font>会阻塞<br>update mylock set name = ‘aa’ where id = 1;</td></tr><tr><td align="center">当前session不能访问其他session插入的记录；</td><td align="center"></td></tr><tr><td align="center">释放锁资源：unlock tables</td><td align="center">当前session获取锁，更新操作完成</td></tr><tr><td align="center">当前session可以查看其他session插入的记录</td><td align="center"></td></tr></tbody></table><p> 可以通过检查 <code>table_locks_waited</code> 和 <code>table_locks_immediate</code>状态变量来分析系统上的表锁定争夺：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show status like 'table%';</span><br><span class="line">+<span class="comment">-----------------------+-------+</span></span><br><span class="line">| Variable_name         | Value |</span><br><span class="line">+<span class="comment">-----------------------+-------+</span></span><br><span class="line">| Table_locks_immediate | 352   |</span><br><span class="line">| Table_locks_waited    | 2     |</span><br><span class="line">+<span class="comment">-----------------------+-------+</span></span><br><span class="line"><span class="comment">--如果 Table_locks_waited 的值比较高，则说明存在着较严重的表级锁争用情况。</span></span><br></pre></td></tr></table></figure><h2 id="InnoDB锁"><a href="#InnoDB锁" class="headerlink" title="InnoDB锁"></a>InnoDB锁</h2><p>可以通过检查 <code>Innodb_row_lock</code> 状态变量来分析系统上的行锁的争夺情况：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show status like 'innodb_row_lock%';</span><br><span class="line">+<span class="comment">-------------------------------+-------+</span></span><br><span class="line">| Variable_name                 | Value |</span><br><span class="line">+<span class="comment">-------------------------------+-------+</span></span><br><span class="line">| Innodb_row_lock_current_waits | 0     |</span><br><span class="line">| Innodb_row_lock_time          | 18702 |</span><br><span class="line">| Innodb_row_lock_time_avg      | 18702 |</span><br><span class="line">| Innodb_row_lock_time_max      | 18702 |</span><br><span class="line">| Innodb_row_lock_waits         | 1     |</span><br><span class="line">+<span class="comment">-------------------------------+-------+</span></span><br><span class="line"><span class="comment">--如果发现锁争用比较严重，如InnoDB_row_lock_waits和InnoDB_row_lock_time_avg的值比较高</span></span><br></pre></td></tr></table></figure><p><strong>InnoDB的行锁模式及加锁方法</strong>：</p><ul><li><strong>共享锁（s）</strong>：又称读锁。允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。若事务 T 对数据对象 A 加上 S 锁，则事务 T 可以读 A 但不能修改 A，其他事务只能再对 A 加 S 锁，而不能加 X 锁，直到 T 释放 A 上的 S 锁，这保证了其他事务可以读 A，但在 T 释放 A 上的 S 锁之前不能对 A 做任何修改；<br>​</li><li><strong>排他锁（x）</strong>：又称写锁。允许获取排他锁的事务更新数据，阻止其他事务取得相同的数据集共享读锁和排他写锁。若事务 T 对数据对象 A 加上 X 锁，事务 T 可以读 A 也可以修改 A，其他事务不能再对 A 加任何锁，直到 T 释放 A 上的锁。</li></ul><p>​MySQL InnoDB引 擎默认的修改数据语句：<strong>update, delete, insert都会自动给涉及到的数据加上排他锁，select 语句默认不会加任何锁类型</strong>，如果加排他锁可以使用 <code>select …for update</code> 语句，加共享锁可以使用 <code>select … lock in share mode</code> 语句。<strong>所以加过排他锁的数据行在其他事务种是不能修改数据的，也不能通过for update和lock in share mode锁的方式查询数据，但可以直接通过select …from…查询数据，因为普通查询没有任何锁机制。</strong> </p><p><strong>InnoDB行锁实现方式</strong>：</p><p>InnoDB 行锁是通过给<strong>索引</strong>上的索引项加锁来实现的，这一点 MySQL 与 Oracle 不同，后者是通过在数据块中对相应数据行加锁来实现的。InnoDB 这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB 才使用行级锁，<strong>否则，InnoDB将使用表锁！</strong>  </p><ul><li>在不通过索引条件查询的时候，InnoDB 使用的是表锁而不是行锁</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tab_no_index(<span class="keyword">id</span> <span class="built_in">int</span>,<span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">10</span>)) <span class="keyword">engine</span>=<span class="keyword">innodb</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tab_no_index <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'1'</span>),(<span class="number">2</span>,<span class="string">'2'</span>),(<span class="number">3</span>,<span class="string">'3'</span>),(<span class="number">4</span>,<span class="string">'4'</span>);</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">session1</th><th align="center">session2</th></tr></thead><tbody><tr><td align="center">set autocommit=0<br>select * from tab_no_index where id = 1;</td><td align="center">set autocommit=0<br>select * from tab_no_index where id =2</td></tr><tr><td align="center">select * from tab_no_index where id = 1 for update</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">select * from tab_no_index where id = 2 for update;</td></tr></tbody></table><p>session1 只给一行加了排他锁，但是 session2 在请求其他行的排他锁的时候，会出现锁等待。原因是在没有索引的情况下，InnoDB 只能使用表锁。</p><ul><li>创建带索引的表进行条件查询，InnoDB 使用的是行锁</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tab_with_index(<span class="keyword">id</span> <span class="built_in">int</span>,<span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">10</span>)) <span class="keyword">engine</span>=<span class="keyword">innodb</span>;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tab_with_index <span class="keyword">add</span> <span class="keyword">index</span> <span class="keyword">id</span>(<span class="keyword">id</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tab_with_index <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'1'</span>),(<span class="number">2</span>,<span class="string">'2'</span>),(<span class="number">3</span>,<span class="string">'3'</span>),(<span class="number">4</span>,<span class="string">'4'</span>);</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">session1</th><th align="center">session2</th></tr></thead><tbody><tr><td align="center">set autocommit=0<br>select * from tab_with_indexwhere id = 1;</td><td align="center">set autocommit=0<br>select * from tab_with_indexwhere id =2</td></tr><tr><td align="center">select * from tab_with_indexwhere id = 1 for update</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">select * from tab_with_indexwhere id = 2 for update;</td></tr></tbody></table><ul><li>由于 MySQL 的行锁是针对索引加的锁，不是针对记录加的锁，所以虽然是访问不同行的记录，但是依然无法访问到具体的数据</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tab_with_index <span class="keyword">drop</span> <span class="keyword">index</span> <span class="keyword">id</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tab_with_index  <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'4'</span>);</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">session1</th><th align="center">session2</th></tr></thead><tbody><tr><td align="center">set autocommit=0</td><td align="center">set autocommit=0</td></tr><tr><td align="center">select * from tab_with_index where id = 1 and name=’1’ for update</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">select * from tab_with_index where id = 1 and name=’4’ for update<br>虽然 session2 访问的是和 session1 不同的记录，但是锁的是具体的表，所以需要等待锁</td></tr></tbody></table><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>对于MyISAM的表锁，主要讨论了以下几点：</strong> </p><ul><li><p>共享读锁（S）之间是兼容的，但共享读锁（S）与排他写锁（X）之间，以及排他写锁（X）之间是互斥的，也就是说读和写是串行的；  </p></li><li><p>在一定条件下，MyISAM 允许查询和插入并发执行，我们可以利用这一点来解决应用中对同一表查询和插入的锁争用问题；</p></li><li><p>MyISAM 默认的锁调度机制是写优先，这并不一定适合所有应用，用户可以通过设置 <code>LOW_PRIORITY_UPDATES</code> 参数，或在 <code>INSERT、UPDATE、DELETE</code> 语句中指定 <code>LOW_PRIORITY</code> 选项来调节读写锁的争用。 </p></li><li><p>由于表锁的锁定粒度大，读写之间又是串行的，因此，如果更新操作较多，MyISAM 表可能会出现严重的锁等待，可以考虑采用 InnoDB 引擎来减少锁冲突。</p></li></ul><p><strong>对于InnoDB表，本文主要讨论了以下几项内容：</strong> </p><ul><li>InnoDB 的行锁是基于索引实现的，如果不通过索引访问数据，InnoDB 会使用表锁；</li><li>在不同的隔离级别下，InnoDB 的锁机制和一致性读策略不同；</li></ul><p>在了解 InnoDB 锁特性后，用户可以通过设计和 SQL 调整等措施减少锁冲突和死锁，包括：</p><ul><li><p>尽量使用较低的隔离级别；精心设计索引，并尽量使用索引访问数据，使加锁更精确，从而减少锁冲突的机会；</p></li><li><p>选择合理的事务大小，小事务发生锁冲突的几率也更小；</p></li><li><p>给记录集显式加锁时，最好一次性请求足够级别的锁。比如要修改数据的话，最好直接申请排他锁，而不是先申请共享锁，修改时再请求排他锁，这样容易产生死锁；</p></li><li><p>不同的程序访问一组表时，应尽量约定以相同的顺序访问各表，对一个表而言，尽可能以固定的顺序存取表中的行。这样可以大大减少死锁的机会；</p></li><li><p>尽量用相等条件访问数据，这样可以避免间隙锁对并发插入的影响；不要申请超过实际需要的锁级别；除非必须，查询时不要显示加锁；</p></li><li><p>对于一些特定的事务，可以使用表锁来提高处理速度或减少死锁的可能。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;MySQL-中锁的基本知识&quot;&gt;&lt;a href=&quot;#MySQL-中锁的基本知识&quot; class=&quot;headerlink&quot; title=&quot;MySQL 中锁的基本知识&quot;&gt;&lt;/a&gt;MySQL 中锁的基本知识&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;锁是计算机协调多个进程或线程并发访问
      
    
    </summary>
    
    
      <category term="数据库" scheme="https://dongzl.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MySQL" scheme="https://dongzl.github.io/tags/MySQL/"/>
    
      <category term="Lock" scheme="https://dongzl.github.io/tags/Lock/"/>
    
  </entry>
  
  <entry>
    <title>JDK ThreadPoolExecutor 源码解析</title>
    <link href="https://dongzl.github.io/2020/03/18/15-ThreadPoolExecutor-Source-Code/"/>
    <id>https://dongzl.github.io/2020/03/18/15-ThreadPoolExecutor-Source-Code/</id>
    <published>2020-03-18T14:02:59.000Z</published>
    <updated>2020-03-22T14:54:05.593Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>学习 Java 的多线程知识就绕不开线程池，提起线程池那就必然要说到 ThreadPoolExecutor 类，自从 <code>阿里巴巴编码规范</code> 问世以来，ThreadPoolExecutor 可能也跟着火了一把，现在随便问个 Java 开发的基本都能背出来<code>线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险</code>。</p><p>笔者所参与的项目中很多地方都使用了线程池的 ThreadPoolExecutor 类去自定义线程池的一些参数。当然凡事没有绝对，使用 Executors 去创建线程池也是有的，如果只是开启数量可控的很少的线程去执行任务，也没必要大动干戈。</p><p><strong>为什么需要线程池</strong>：<br>在实际使用中，线程是很占用系统资源的，如果对线程管理不善，很容易导致系统问题。因此，在大多数并发框架中都会使用线程池来管理线程，使用线程池管理线程主要有如下好处:</p><ul><li>使用线程池可以重复利用已有的线程继续执行任务，避免线程在创建和销毁时造成的消耗；</li><li>由于没有线程创建和销毁时的消耗，可以提高系统响应速度；</li><li>通过线程可以对线程进行合理的管理，根据系统的承受能力调整可运行<br>线程数量的大小等。</li></ul><h2 id="线程池工作原理"><a href="#线程池工作原理" class="headerlink" title="线程池工作原理"></a>线程池工作原理</h2><img src="https://gitee.com/dongzl/article-images/raw/master/2020/15-ThreadPoolExecutor-Source-Code/ThreadPoolExecutor-Source-Code-04.png"><p>线程池执行所提交的任务过程: </p><ul><li>先判断线程池中核心线程池所有的线程是否都在执行任务。如果不是，则新创建一个线程执行刚提交的任务，否则，核心线程池中所有的线程都在执行任务，则进入第2步;</li><li>判断当前阻塞队列是否已满，如果未满，则将提交的任务放置在阻塞队列中；否则，则进入第3步；</li><li>判断线程池中所有的线程是否都在执行任务，如果没有，则创建一个新的线程来执行任务，否则，则交给饱和策略进行处理。</li></ul><img src="https://gitee.com/dongzl/article-images/raw/master/2020/15-ThreadPoolExecutor-Source-Code/ThreadPoolExecutor-Source-Code-05.png"><h2 id="JDK-自带线程池实现"><a href="#JDK-自带线程池实现" class="headerlink" title="JDK 自带线程池实现"></a>JDK 自带线程池实现</h2><img src="https://gitee.com/dongzl/article-images/raw/master/2020/15-ThreadPoolExecutor-Source-Code/ThreadPoolExecutor-Source-Code-01.png"><table><thead><tr><th>线程池</th><th>corePoolSize</th><th>maximumPoolSize</th><th>keepAliveTime</th><th>unit</th><th>workQueue</th><th>threadFactory</th><th>handler</th></tr></thead><tbody><tr><td>newCachedThreadPool</td><td>0</td><td>Integer.MAX_VALUE</td><td>60</td><td>TimeUnit.SECONDS</td><td>SynchronousQueue</td><td>DefaultThreadFactory</td><td>AbortPolicy</td></tr><tr><td>newFixedThreadPool</td><td>nThreads</td><td>nThreads</td><td>0</td><td>TimeUnit.MILLISECONDS</td><td>LinkedBlockingQueue</td><td>DefaultThreadFactory</td><td>AbortPolicy</td></tr><tr><td>newSingleThreadExecutor</td><td>1</td><td>1</td><td>0</td><td>TimeUnit.MILLISECONDS</td><td>LinkedBlockingQueue</td><td>DefaultThreadFactory</td><td>AbortPolicy</td></tr><tr><td>newSingleThreadScheduledExecutor</td><td>1</td><td>Integer.MAX_VALUE</td><td>0</td><td>TimeUnit.NANOSECONDS</td><td>DelayedWorkQueue</td><td>DefaultThreadFactory</td><td>AbortPolicy</td></tr><tr><td>newSingleThreadScheduledExecutor</td><td>corePoolSize</td><td>Integer.MAX_VALUE</td><td>0</td><td>TimeUnit.NANOSECONDS</td><td>DelayedWorkQueue</td><td>DefaultThreadFactory</td><td>AbortPolicy</td></tr><tr><td>newWorkStealingPool</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr></tbody></table><p>补充： </p><ul><li><p>各种线程池实现中 threadFactory 参数可以自定义，也可以使用使用 JDK 默认 <code>DefaultThreadFactory</code> 实现类。</p></li><li><p><code>newWorkStealingPool</code> 属于 <code>ForkJoinPool</code> 线程池框架内容，实现上比较特殊。</p></li></ul><p>参数说明</p><ul><li>corePoolSize:核心线程池的大小。</li><li>maximumPoolSize:线程池能创建线程的最大个数</li><li>keepAliveTime:空闲线程存活时间</li><li>unit: 时间单位，为keepAlive Time指定时间单位</li><li>workQueue:阻塞队列，用于保存任务的阻塞队列</li><li>threadFactory: 创建线程的工程类</li><li>handler:饱和策略(拒绝策略)</li></ul><h2 id="JDK-自带阻塞队列实现"><a href="#JDK-自带阻塞队列实现" class="headerlink" title="JDK 自带阻塞队列实现"></a>JDK 自带阻塞队列实现</h2><img src="https://gitee.com/dongzl/article-images/raw/master/2020/15-ThreadPoolExecutor-Source-Code/ThreadPoolExecutor-Source-Code-02.png"><h2 id="线程池的生命周期"><a href="#线程池的生命周期" class="headerlink" title="线程池的生命周期"></a>线程池的生命周期</h2><img src="https://gitee.com/dongzl/article-images/raw/master/2020/15-ThreadPoolExecutor-Source-Code/ThreadPoolExecutor-Source-Code-03.png"><ul><li><p>RUNNING：能接受新提交的任务，并且也能处理阻塞队列中的任务；</p></li><li><p>SHUTDOWN：关闭状态，不再接受新提交的任务，但却可以继续处理阻<br>塞队列中已保存的任务；</p></li><li><p>STOP：不能接受新任务，也不处理队列中的任务，会中断正在处理任务的<br>线程；</p></li><li><p>TIDYING：如果所有的任务都已终止了，workerCount(有效线程数)为0，线程池进入该状态后会调用terminated()方法进入TERMINATED状态；</p></li><li><p>TERMINATED：在 terminated (方法执行完后进入该状态，默认<br>terminated()方法中什么也没有做。</p></li></ul><h2 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h2><ul><li><code>ThreadPoolExecutor.AbortPolicy</code>：丢弃任务并抛出 <code>RejectedExecutionException</code> 异常；</li><li><code>ThreadPoolExecutor.DiscardPolicy</code>：也是丢弃任务，但是不抛<br>出异常；</li><li><code>ThreadPoolExecutor.DiscardOldestPolicy</code>：丢弃队列最前面的<br>任务，然后重新尝试执行任务(重复此过程)；</li><li><code>ThreadPoolExecutor.CallerRunsPolicy</code>：由调用线程处理该任务。</li></ul><h2 id="ThreadPoolExecutor-源码解析"><a href="#ThreadPoolExecutor-源码解析" class="headerlink" title="ThreadPoolExecutor 源码解析"></a>ThreadPoolExecutor 源码解析</h2><h3 id="常用变量的解释"><a href="#常用变量的解释" class="headerlink" title="常用变量的解释"></a>常用变量的解释</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. `ctl`，可以看做一个int类型的数字，高3位表示线程池状态，低29位表示worker数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"><span class="comment">// 2. `COUNT_BITS`，`Integer.SIZE`为32，所以`COUNT_BITS`为29</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"><span class="comment">// 3. `CAPACITY`，线程池允许的最大线程数。1左移29位，然后减1，即为 2^29 - 1</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// runState is stored in the high-order bits</span></span><br><span class="line"><span class="comment">// 4. 线程池有5种状态，按大小排序如下：RUNNING &lt; SHUTDOWN &lt; STOP &lt; TIDYING &lt; TERMINATED</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Packing and unpacking ctl</span></span><br><span class="line"><span class="comment">// 5. `runStateOf()`，获取线程池状态，通过按位与操作，低29位将全部变成0</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span>     </span>&#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125;</span><br><span class="line"><span class="comment">// 6. `workerCountOf()`，获取线程池worker数量，通过按位与操作，高3位将全部变成0</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span>  </span>&#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;</span><br><span class="line"><span class="comment">// 7. `ctlOf()`，根据线程池状态和线程池worker数量，生成ctl值</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>&#123; <span class="keyword">return</span> rs | wc; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Bit field accessors that don't require unpacking ctl.</span></span><br><span class="line"><span class="comment"> * These depend on the bit layout and on workerCount being never negative.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 8. `runStateLessThan()`，线程池状态小于xx</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">runStateLessThan</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c &lt; s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 9. `runStateAtLeast()`，线程池状态大于等于xx</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">runStateAtLeast</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c &gt;= s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 基本类型参数校验</span></span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="comment">// 空指针校验</span></span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="comment">// 根据传入参数`unit`和`keepAliveTime`，将存活时间转换为纳秒存到变量`keepAliveTime `中</span></span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="提交执行-task-的过程"><a href="#提交执行-task-的过程" class="headerlink" title="提交执行 task 的过程"></a>提交执行 task 的过程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Proceed in 3 steps:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 1. If fewer than corePoolSize threads are running, try to</span></span><br><span class="line"><span class="comment">     * start a new thread with the given command as its first</span></span><br><span class="line"><span class="comment">     * task.  The call to addWorker atomically checks runState and</span></span><br><span class="line"><span class="comment">     * workerCount, and so prevents false alarms that would add</span></span><br><span class="line"><span class="comment">     * threads when it shouldn't, by returning false.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 2. If a task can be successfully queued, then we still need</span></span><br><span class="line"><span class="comment">     * to double-check whether we should have added a thread</span></span><br><span class="line"><span class="comment">     * (because existing ones died since last checking) or that</span></span><br><span class="line"><span class="comment">     * the pool shut down since entry into this method. So we</span></span><br><span class="line"><span class="comment">     * recheck state and if necessary roll back the enqueuing if</span></span><br><span class="line"><span class="comment">     * stopped, or start a new thread if there are none.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 3. If we cannot queue task, then we try to add a new</span></span><br><span class="line"><span class="comment">     * thread.  If it fails, we know we are shut down or saturated</span></span><br><span class="line"><span class="comment">     * and so reject the task.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="comment">// worker数量比核心线程数小，直接创建worker执行任务</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// worker数量超过核心线程数，任务直接进入队列</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="comment">// 线程池状态不是RUNNING状态，说明执行过shutdown命令，需要对新加入的任务执行reject()操作。</span></span><br><span class="line">        <span class="comment">// 这儿为什么需要recheck，是因为任务入队列前后，线程池的状态可能会发生变化。</span></span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="comment">// 这儿为什么需要判断0值，主要是在线程池构造方法中，核心线程数允许为0</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果线程池不是运行状态，或者任务进入队列失败，则尝试创建worker执行任务。</span></span><br><span class="line">    <span class="comment">// 这儿有3点需要注意：</span></span><br><span class="line">    <span class="comment">// 1. 线程池不是运行状态时，addWorker内部会判断线程池状态</span></span><br><span class="line">    <span class="comment">// 2. addWorker第2个参数表示是否创建核心线程</span></span><br><span class="line">    <span class="comment">// 3. addWorker返回false，则说明任务执行失败，需要执行reject操作</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="addworker-源码解析"><a href="#addworker-源码解析" class="headerlink" title="addworker 源码解析"></a>addworker 源码解析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">    retry:</span><br><span class="line">    <span class="comment">// 外层自旋</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这个条件写得比较难懂，我对其进行了调整，和下面的条件等价</span></span><br><span class="line">        <span class="comment">// (rs &gt; SHUTDOWN) || </span></span><br><span class="line">        <span class="comment">// (rs == SHUTDOWN &amp;&amp; firstTask != null) || </span></span><br><span class="line">        <span class="comment">// (rs == SHUTDOWN &amp;&amp; workQueue.isEmpty())</span></span><br><span class="line">        <span class="comment">// 1. 线程池状态大于SHUTDOWN时，直接返回false</span></span><br><span class="line">        <span class="comment">// 2. 线程池状态等于SHUTDOWN，且firstTask不为null，直接返回false</span></span><br><span class="line">        <span class="comment">// 3. 线程池状态等于SHUTDOWN，且队列为空，直接返回false</span></span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">               firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">               ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 内层自旋</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">            <span class="comment">// worker数量超过容量，直接返回false</span></span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// 使用CAS的方式增加worker数量。</span></span><br><span class="line">            <span class="comment">// 若增加成功，则直接跳出外层循环进入到第二部分</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">            c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">            <span class="comment">// 线程池状态发生变化，对外层循环进行自旋</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">            <span class="comment">// 其他情况，直接内层循环进行自旋即可</span></span><br><span class="line">            <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">    Worker w = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">        <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">            <span class="comment">// worker的添加必须是串行的，因此需要加锁</span></span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// Recheck while holding lock.</span></span><br><span class="line">                <span class="comment">// Back out on ThreadFactory failure or if</span></span><br><span class="line">                <span class="comment">// shut down before lock acquired.</span></span><br><span class="line">                <span class="comment">// 这儿需要重新检查线程池状态</span></span><br><span class="line">                <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    <span class="comment">// worker已经调用过了start()方法，则不再创建worker</span></span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                    <span class="comment">// worker创建并添加到workers成功</span></span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    <span class="comment">// 更新`largestPoolSize`变量</span></span><br><span class="line">                    <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 启动worker线程</span></span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// worker线程启动失败，说明线程池状态发生了变化（关闭操作被执行），需要进行shutdown相关操作</span></span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程池-worker-任务单元"><a href="#线程池-worker-任务单元" class="headerlink" title="线程池 worker 任务单元"></a>线程池 worker 任务单元</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This class will never be serialized, but we provide a</span></span><br><span class="line"><span class="comment">     * serialVersionUID to suppress a javac warning.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6138294804551838833L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Thread this worker is running in.  Null if factory fails. */</span></span><br><span class="line">    <span class="keyword">final</span> Thread thread;</span><br><span class="line">    <span class="comment">/** Initial task to run.  Possibly null. */</span></span><br><span class="line">    Runnable firstTask;</span><br><span class="line">    <span class="comment">/** Per-thread task counter */</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> completedTasks;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates with given first task and thread from ThreadFactory.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> firstTask the first task (null if none)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Worker(Runnable firstTask) &#123;</span><br><span class="line">        setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker</span></span><br><span class="line">        <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">        <span class="comment">// 这儿是Worker的关键所在，使用了线程工厂创建了一个线程。传入的参数为当前worker</span></span><br><span class="line">        <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Delegates main run loop to outer runWorker  */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        runWorker(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="核心线程执行逻辑-runWorker"><a href="#核心线程执行逻辑-runWorker" class="headerlink" title="核心线程执行逻辑-runWorker"></a>核心线程执行逻辑-runWorker</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    Thread wt = Thread.currentThread();</span><br><span class="line">    Runnable task = w.firstTask;</span><br><span class="line">    w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 调用unlock()是为了让外部可以中断</span></span><br><span class="line">    w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">    <span class="comment">// 这个变量用于判断是否进入过自旋（while循环）</span></span><br><span class="line">    <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 这儿是自旋</span></span><br><span class="line">        <span class="comment">// 1. 如果firstTask不为null，则执行firstTask；</span></span><br><span class="line">        <span class="comment">// 2. 如果firstTask为null，则调用getTask()从队列获取任务。</span></span><br><span class="line">        <span class="comment">// 3. 阻塞队列的特性就是：当队列为空时，当前线程会被阻塞等待</span></span><br><span class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 这儿对worker进行加锁，是为了达到下面的目的</span></span><br><span class="line">            <span class="comment">// 1. 降低锁范围，提升性能</span></span><br><span class="line">            <span class="comment">// 2. 保证每个worker执行的任务是串行的</span></span><br><span class="line">            w.lock();</span><br><span class="line">            <span class="comment">// If pool is stopping, ensure thread is interrupted;</span></span><br><span class="line">            <span class="comment">// if not, ensure thread is not interrupted.  This</span></span><br><span class="line">            <span class="comment">// requires a recheck in second case to deal with</span></span><br><span class="line">            <span class="comment">// shutdownNow race while clearing interrupt</span></span><br><span class="line">            <span class="comment">// 如果线程池正在停止，则对当前线程进行中断操作</span></span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                 (Thread.interrupted() &amp;&amp;</span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            <span class="comment">// 执行任务，且在执行前后通过`beforeExecute()`和`afterExecute()`来扩展其功能。</span></span><br><span class="line">            <span class="comment">// 这两个方法在当前类里面为空实现。</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 帮助gc</span></span><br><span class="line">                task = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 已完成任务数加一 </span></span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 自旋操作被退出，说明线程池正在结束</span></span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://mp.weixin.qq.com/s/ahHKn8qs96bTHURQlcvuNA" target="_blank" rel="noopener">Java 线程池 ThreadPoolExecutor 八种拒绝策略浅析</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;学习 Java 的多线程知识就绕不开线程池，提起线程池那就必然要说到 ThreadPoolExecutor 类，自从 &lt;code&gt;阿里巴巴编
      
    
    </summary>
    
    
      <category term="java开发" scheme="https://dongzl.github.io/categories/java%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="ThreadPoolExecutor" scheme="https://dongzl.github.io/tags/ThreadPoolExecutor/"/>
    
      <category term="线程池" scheme="https://dongzl.github.io/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>Redis 高可用之主从复制</title>
    <link href="https://dongzl.github.io/2020/03/17/14-Redis-HA-Master-Salve/"/>
    <id>https://dongzl.github.io/2020/03/17/14-Redis-HA-Master-Salve/</id>
    <published>2020-03-17T10:39:21.000Z</published>
    <updated>2020-03-22T15:07:59.112Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景描述"><a href="#背景描述" class="headerlink" title="背景描述"></a>背景描述</h2><p>单机的 Redis，能够承载的 QPS 大概就在十万左右。对于缓存来说，一般都是用来支撑读高并发的，做成 <code>master-slave</code> 架构，一主多从，<code>master</code> 节点负责写，并且将数据复制到其它的 <code>slave</code> 节点，<code>slave</code> 节点负责读，所有的读请求全部走 <code>slave</code> 节点，这样也可以很轻松实现水平扩容，支撑读高并发。</p><h2 id="Redis-replication-的核心机制"><a href="#Redis-replication-的核心机制" class="headerlink" title="Redis replication 的核心机制"></a>Redis replication 的核心机制</h2><ul><li>Redis 采用异步方式复制数据到 slave 节点，不过 Redis2.8 开始，slave node 会周期性地确认自己每次复制的数据量；</li><li>一个 master node 是可以配置多个 slave node 的；</li><li>slave node 也可以连接其他的 slave node；</li><li>slave node 做复制的时候，不会阻塞 master node 的正常读写；</li><li>slave node 在做复制的时候，也不会阻塞对自己的读操作，它会用旧的数据集来提供服务；但是复制完成的时候，需要删除旧数据集，加载新数据集，这个时候会暂停服务；</li><li>slave node 主要用来进行横向扩容，做读写分离，扩容的 slave node 可以提高读的吞吐量。</li></ul><p>PS. 如果采用了主从架构，那么建议必须开启 master node 的持久化，不建议用 slave node 作为 master node 的数据热备，因为如果关掉了 master 的持久化，可能在 master 宕机重启后数据是空的，这个时候 slave node 做数据同步，slave node 的数据也丢了。</p><p>另外，master node 也需要进行各种备份。一旦本地的所有文件丢失了，从备份中挑选一份 RDB 文件去恢复 master 数据，这样才能确保启动的时候，是有数据的，防止数据全部丢失。</p><h2 id="Redis-主从复制的核心原理"><a href="#Redis-主从复制的核心原理" class="headerlink" title="Redis 主从复制的核心原理"></a>Redis 主从复制的核心原理</h2><p>当启动一个 slave node 的时候，它会发送一个 <code>PSYNC</code> 命令给 master node。如果这是 slave node 初次连接到 master node，那么会触发一次 <code>full resynchronization</code> 全量复制。此时 master 会启动一个后台线程，开始生成一份 RDB 快照文件，同时还会将客户端 client 新收到的所有写命令缓存在内存中。RDB 文件生成完毕后， master 会将这个 RDB 文件发送给 slave，slave 会先写入本地磁盘，然后再从本地磁盘加载到内存中，接着 master 会将内存中缓存的写命令发送到 slave，slave 也会同步这些数据。slave node 如果跟 master node 有网络故障，断开了连接，会自动重连，连接之后 master node 仅会复制给 slave 部分缺少的数据。</p><img src="https://gitee.com/dongzl/article-images/raw/master/2020/14-Redis-HA-Master-Salve/Redis-HA-Master-Salve-01.png"><h3 id="主从复制的断点续传"><a href="#主从复制的断点续传" class="headerlink" title="主从复制的断点续传"></a>主从复制的断点续传</h3><p>从 Redis2.8 开始，就支持主从复制的断点续传，如果主从复制过程中，网络连接断掉了，那么可以接着上次复制的地方，继续复制下去，而不是从头开始复制一份。</p><p>master node 会在内存中维护一个 <code>backlog</code>，master 和 slave 都会保存一个 <code>replica offset</code> 还有一个 <code>master run id</code>，<code>offset</code> 就是保存在 <code>backlog</code> 中的。如果 master 和 slave 网络连接断掉了，slave 会让 master 从上次 <code>replica offset</code> 开始继续复制，如果没有找到对应的 <code>offset</code>，那么就会执行一次 <code>resynchronization</code>。</p><blockquote><p>如果根据 host + ip 定位 master node，是不靠谱的，如果 master node 重启或者数据发生了变化，那么 slave node 应该根据不同的 run id 区分。</p></blockquote><h3 id="无磁盘化复制"><a href="#无磁盘化复制" class="headerlink" title="无磁盘化复制"></a>无磁盘化复制</h3><p>master 在内存中直接创建 <code>RDB</code>，然后发送给 slave，不会在自己本地落地磁盘了。只需要在配置文件中开启 <code>repl-diskless-sync yes</code> 即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">repl-diskless-sync yes</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 等待 5s 后再开始复制，因为要等更多 slave 重新连接过来</span></span><br><span class="line">repl-diskless-sync-delay 5</span><br></pre></td></tr></table></figure><h3 id="slave-对过期-key-处理"><a href="#slave-对过期-key-处理" class="headerlink" title="slave 对过期 key 处理"></a>slave 对过期 key 处理</h3><p>slave 不会处理过期 key，只会等待 master 过期 key。如果 master 过期了一个 key，或者通过 LRU 淘汰了一个 key，那么会模拟一条 del 命令发送给 slave。</p><h2 id="复制的完整流程"><a href="#复制的完整流程" class="headerlink" title="复制的完整流程"></a>复制的完整流程</h2><p>slave node 启动时，会在自己本地保存 master node 的信息，包括 master node 的 <code>host</code> 和 <code>ip</code>，但是复制流程没开始。</p><p>slave node 内部有个定时任务，每秒检查是否有新的 master node 要连接和复制，如果发现，就跟 master node 建立 <code>socket</code> 网络连接。然后 slave node 发送 <code>ping</code> 命令给 master node。如果 master 设置了 <code>requirepass</code>，那么 slave node 必须发送 <code>masterauth</code> 的口令过去进行认证。master node 第一次执行全量复制，将所有数据发给 slave node。而在后续，master node 持续将写命令，异步复制给 slave node。</p><img src="https://gitee.com/dongzl/article-images/raw/master/2020/14-Redis-HA-Master-Salve/Redis-HA-Master-Salve-02.png"><h3 id="全量复制"><a href="#全量复制" class="headerlink" title="全量复制"></a>全量复制</h3><ul><li><p>master 执行 <code>bgsave</code>，在本地生成一份 <code>RDB</code> 快照文件；</p></li><li><p>master node 将 RDB 快照文件发送给 slave node，如果 RDB 复制时间超过 <code>60</code> 秒（<code>repl-timeout</code>），那么 slave node 就会认为复制失败，所以需要根据实际情况适当调大这个参数；</p></li><li><p>master node 在生成 RDB 文件时，会将所有新的写命令缓存在内存中，在 slave node 保存了 RDB 之后，再将新的写命令复制给 slave node。</p></li><li><p>如果在复制期间，内存缓冲区持续消耗超过 <code>64MB</code>，或者一次性超过 <code>256MB</code>，那么将会停止复制，复制失败；</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client-output-buffer-limit slave 256MB 64MB 60</span><br></pre></td></tr></table></figure><ul><li><p>slave node 接收到 <code>RDB</code> 之后，清空自己的旧数据，然后重新加载 <code>RDB</code> 到自己的内存中，同时基于旧的数据版本对外提供服务；</p></li><li><p>如果 slave node 开启了 <code>AOF</code>，那么会立即执行 <code>BGREWRITEAOF</code>，重写 <code>AOF</code>。</p></li></ul><img src="https://gitee.com/dongzl/article-images/raw/master/2020/14-Redis-HA-Master-Salve/Redis-HA-Master-Salve-03.png"><img src="https://gitee.com/dongzl/article-images/raw/master/2020/14-Redis-HA-Master-Salve/Redis-HA-Master-Salve-04.png"><h3 id="增量复制"><a href="#增量复制" class="headerlink" title="增量复制"></a>增量复制</h3><ul><li><p>如果全量复制过程中，master-slave 网络连接断掉，那么 slave 重新连接 master 时，会触发增量复制；</p></li><li><p>master 直接从自己的 <code>backlog</code> 中获取部分丢失的数据，发送给 slave node，默认 <code>backlog</code> 就是 <code>1MB</code>。</p></li><li><p>master 就是根据 slave 发送的 <code>psync</code> 中的 <code>offset</code> 来从 <code>backlog</code> 中获取数据的。</p></li></ul><h3 id="heartbeat"><a href="#heartbeat" class="headerlink" title="heartbeat"></a>heartbeat</h3><p>主从节点互相都会发送 <code>heartbeat</code> 信息。</p><p>master 默认每隔 <code>10秒</code> 发送一次 <code>heartbeat</code>，slave node 每隔 <code>1秒</code> 发送一个 <code>heartbeat</code>。</p><h3 id="异步复制"><a href="#异步复制" class="headerlink" title="异步复制"></a>异步复制</h3><p>master 每次接收到写命令之后，先在内部写入数据，然后异步发送给 slave node。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><p><a href="https://blog.csdn.net/juded/article/details/90245371" target="_blank" rel="noopener">Redis：解决异步复制丢失、脑裂数据丢失状况</a></p></li><li><p><a href="https://github.com/antirez/redis-doc/blob/master/topics/replication.md" target="_blank" rel="noopener">Replication</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/91770135" target="_blank" rel="noopener">如何保障mysql和redis之间的数据一致性？</a></p></li><li><p><a href="https://blog.51cto.com/14257804/2376731" target="_blank" rel="noopener">深入Redis 主从复制原理</a></p></li><li><p><a href="https://www.cnblogs.com/leeSmall/p/8398401.html" target="_blank" rel="noopener">Redis系列八：redis主从复制和哨兵</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景描述&quot;&gt;&lt;a href=&quot;#背景描述&quot; class=&quot;headerlink&quot; title=&quot;背景描述&quot;&gt;&lt;/a&gt;背景描述&lt;/h2&gt;&lt;p&gt;单机的 Redis，能够承载的 QPS 大概就在十万左右。对于缓存来说，一般都是用来支撑读高并发的，做成 &lt;code&gt;mas
      
    
    </summary>
    
    
      <category term="架构设计" scheme="https://dongzl.github.io/categories/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="Redis" scheme="https://dongzl.github.io/tags/Redis/"/>
    
      <category term="主从复制" scheme="https://dongzl.github.io/tags/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>Kafka 是如何解决使用 MQ 中容易出现的一些问题</title>
    <link href="https://dongzl.github.io/2020/03/16/13-Solve-MQ-Problem-With-Kafka/"/>
    <id>https://dongzl.github.io/2020/03/16/13-Solve-MQ-Problem-With-Kafka/</id>
    <published>2020-03-16T12:58:08.000Z</published>
    <updated>2020-03-18T01:07:21.533Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景描述"><a href="#背景描述" class="headerlink" title="背景描述"></a>背景描述</h2><p>目前，很多的业务系统都会或多或少的使用各种 MQ 消息队列框架，例如：<code>RabbitMQ</code>、<code>Kafka</code>、<code>RocketMQ</code> 等等，使用 MQ 消息队列，可以满足业务系统 <code>解耦</code>、<code>异步</code>、<code>削峰填谷</code> 场景的需要，但是使用 MQ 中也不得不面临一些问题，这些问题总结如下：</p><blockquote><p>1、如何保证消息队列的高可用？<br>2、如何保证消息不被重复消费？（如何保证消息消费的幂等性）<br>3、如何保证消息的可靠传输？（如何处理消息丢失的问题）<br>4、如何保证消息的顺序性？</p></blockquote><p>其实这些问题也是在面试中 MQ 经常被问到的问题，下面我们就总结分析一下，Kafka 中是如何解决上述问题的。</p><h2 id="Kafka-如何保证高可用"><a href="#Kafka-如何保证高可用" class="headerlink" title="Kafka 如何保证高可用"></a>Kafka 如何保证高可用</h2><p>Kafka 的基本架构组成是：由多个 broker 组成一个集群，每个 broker 是一个节点；当创建一个 topic 时，这个 topic 会被划分为多个 partition，每个 partition 可以存在于不同的 broker 上，每个 partition 只存放一部分数据。</p><p>这就是<strong>天然的分布式消息队列</strong>，就是说一个 topic 的数据，是<strong>分散放在多个机器上的，每个机器就放一部分数据</strong>。</p><p>在 Kafka 0.8 版本之前，是没有 HA 机制的，当任何一个 broker 所在节点宕机了，这个 broker 上的 partition 就无法提供读写服务，所以这个版本之前，Kafka 没有什么高可用性可言。</p><p>在 Kafka 0.8 以后，提供了 HA 机制，就是 replica 副本机制。每个 partition 上的数据都会同步到其它机器，形成自己的多个 replica 副本。所有 replica 会选举一个 leader 出来，消息的生产者和消费者都跟这个 leader 打交道，其他 replica 作为 follower。写的时候，leader 会负责把数据同步到所有 follower 上去，读的时候就直接读 leader 上的数据即可。Kafka 负责均匀的将一个 partition 的所有 replica 分布在不同的机器上，这样才可以提高容错性。</p><p>&lt;插入图片&gt; @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</p><p>拥有了 replica 副本机制，如果某个 broker 宕机了，这个 broker 上的 partition 在其他机器上还存在副本。如果这个宕机的 broker 上面有某个 partition 的 leader，那么此时会从其 follower 中重新选举一个新的 leader 出来，这个新的 leader 会继续提供读写服务，这就有达到了所谓的高可用性。</p><p>写数据的时候，生产者只将数据写入 leader 节点，leader 会将数据写入本地磁盘，接着其他 follower 会主动从 leader 来拉取数据，follower 同步好数据了，就会发送 ack 给 leader，leader 收到所有 follower 的 ack 之后，就会返回写成功的消息给生产者。</p><p>消费数据的时候，消费者只会从 leader 节点去读取消息，但是只有当一个消息已经被所有 follower 都同步成功返回 ack 的时候，这个消息才会被消费者读到。</p><p>&lt;插入图片&gt; @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</p><h2 id="使用-Kafka，如何保证消息不被重复消费"><a href="#使用-Kafka，如何保证消息不被重复消费" class="headerlink" title="使用 Kafka，如何保证消息不被重复消费"></a>使用 Kafka，如何保证消息不被重复消费</h2><h3 id="Kafka-在什么场景下会导致消费者消费到重复数据"><a href="#Kafka-在什么场景下会导致消费者消费到重复数据" class="headerlink" title="Kafka 在什么场景下会导致消费者消费到重复数据"></a>Kafka 在什么场景下会导致消费者消费到重复数据</h3><p>Kafka 实际上有个 offset 的概念，就是每个消息写到 partition 里，都会有一个 offset，代表消息的序号，在 consumer 消费了数据之后，<strong>每隔一段时间（定时定期）</strong>，consumer 会把自己消费过的消息的 offset 提交一下，表示<strong>这些消息已经消费过了，如果发生异常，下次我将从上次消费到的 offset 来继续消费</strong>。</p><p>但是这个过程还是会有意外出现，比如 consumer 机器突然宕机，这会导致 consumer 有些消息已经处理了，但是没来得及提交 offset，这个时候重启之后，就会有少数宕机之前会来得及提交 offset 的消息会被再消费一次。</p><h3 id="如何解决消费到重复数据问题"><a href="#如何解决消费到重复数据问题" class="headerlink" title="如何解决消费到重复数据问题"></a>如何解决消费到重复数据问题</h3><p>对于重复消费的问题，我理解对于任何 MQ 消息队列都是无法避免的，所以就需要我们在业务系统进行<strong>重复消费的幂等性</strong>验证，当然也要考虑业务场景需要，比如一个日志采集系统，每天上千万的数据，某条重复数据的影响几乎可以忽略不计，这个时候也是不需要考虑；如果是其他场景，需要保证幂等性，可以从如下几方面考虑：</p><ul><li>如果是写数据库，可以将消息中的某个字段做为数据库唯一约束，在数据处理之前，先根据唯一约束查询一下，判断是否已经消费过；</li><li>如果是写入 Redis，可以直接调用 set 方法，天然具备幂等性；</li><li>在生产者发送每消息的时候，在消息里面加一个全局唯一的 id，类似订单 id 之类的数据，当消费到这个数据之后，先根据这个全局 id 去比如 Redis 里查一下，如果不存在，说明没有消费过，就继续处理，然后这个 id 写 Redis；如果存在，说明已经消费过，消息直接丢弃。</li></ul><h2 id="使用-Kafka，如何保证消息的可靠传输"><a href="#使用-Kafka，如何保证消息的可靠传输" class="headerlink" title="使用 Kafka，如何保证消息的可靠传输"></a>使用 Kafka，如何保证消息的可靠传输</h2><p>对于保证消息的可靠传输，其实就是如何解决消息丢失的问题；那么我们首先需要弄明白消息为什么会丢失，对于一个消息队列，会有 <code>生产者</code>、<code>MQ</code>、<code>消费者</code> 这三个角色，在这三个角色数据处理和传输过程中，都有可能会出现消息丢失，</p><p>&lt;插入图片&gt; @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</p><p>下面我们就结合 Kafka 来分析一下消息丢失的原因以及解决办法：</p><h3 id="消费者异常导致的消息丢失"><a href="#消费者异常导致的消息丢失" class="headerlink" title="消费者异常导致的消息丢失"></a>消费者异常导致的消息丢失</h3><p>消费者可能导致数据丢失的情况是：消费者获取到了这条消息后，还未处理，Kafka 就自动提交了 offset，这时 Kafka 就认为消费者已经处理完这条消息，其实消费者才刚准备处理这条消息，这时如果消费者宕机，那这条消息就丢失了。</p><p>消费者引起消息丢失的主要原因就是消息还未处理完 Kafka 会自动提交了 offset，那么只要关闭自动提交 offset，消费者在处理完之后手动提交 offset，就可以保证消息不会丢失。但是此时需要注意重复消费问题，比如消费者刚处理完，还没提交 offset，这时自己宕机了，此时这条消息肯定会被重复消费一次，这就需要消费者根据实际情况保证幂等性。</p><h3 id="Kafka-导致的消息丢失"><a href="#Kafka-导致的消息丢失" class="headerlink" title="Kafka 导致的消息丢失"></a>Kafka 导致的消息丢失</h3><p>Kafka 导致的数据丢失一个常见的场景就是 Kafka 某个 broker 宕机，，而这个节点正好是某个 partition 的 leader 节点，这时需要重新重新选举该 partition 的 leader。如果该 partition 的 leader 在宕机时刚好还有些数据没有同步到 follower，此时 leader 挂了，在选举某个 follower 成 leader 之后，就会丢失一部分数据。</p><p>对于这个问题，Kafka 可以设置如下 4 个参数，来尽量避免消息丢失：</p><ul><li>给 topic 设置 replication.factor 参数：这个值必须大于 1，要求每个 partition 必须有至少 2 个副本；</li><li>在 Kafka 服务端设置 min.insync.replicas 参数：这个值必须大于 1，这个参数的含义是一个 leader 至少感知到有至少一个 follower 还跟自己保持联系，没掉队，这样才能确保 leader 挂了还有一个 follower 节点。</li><li>在 producer 端设置 acks=all：这个是要求每条数据，必须是写入所有 replica 之后，才能认为是写成功了；</li><li>在 producer 端设置 retries=MAX（很大很大很大的一个值，无限次重试的意思）：这个参数的含义是一旦写入失败，就无限重试，卡在这里了。</li></ul><h3 id="生产者数据传输导致的消息丢失"><a href="#生产者数据传输导致的消息丢失" class="headerlink" title="生产者数据传输导致的消息丢失"></a>生产者数据传输导致的消息丢失</h3><p>对于生产者数据传输导致的数据丢失主常见情况是生产者发送消息给 Kafka，由于网络等原因导致消息丢失，对于这种情况也是通过在 <strong>producer</strong> 端设置 <strong>acks=all</strong> 来处理，这个参数是要求 leader 接收到消息后，需要等到所有的 follower 都同步到了消息之后，才认为本次写成功了。如果没满足这个条件，生产者会自动不断的重试。</p><p><a href="https://mp.weixin.qq.com/s/qttczGROYoqSulzi8FLXww" target="_blank" rel="noopener">面试官问我如何保证Kafka不丢失消息?我哭了！</a></p><h2 id="Kafka-如何保证消息的顺序性"><a href="#Kafka-如何保证消息的顺序性" class="headerlink" title="Kafka 如何保证消息的顺序性"></a>Kafka 如何保证消息的顺序性</h2><p>在某些业务场景下，我们需要保证对于有逻辑关联的多条MQ消息被按顺序处理，比如对于某一条数据，正常处理顺序是<code>新增-更新-删除</code>，最终结果是数据被删除；如果消息没有按序消费，处理顺序可能是<code>删除-新增-更新</code>，最终数据没有被删掉，可能会产生一些逻辑错误。对于如何保证消息的顺序性，主要需要考虑如下两点：</p><ul><li>如何保证消息在 MQ 中顺序性；</li><li>如何保证消费者处理消费的顺序性。</li></ul><h3 id="如何保证消息在-MQ-中顺序性"><a href="#如何保证消息在-MQ-中顺序性" class="headerlink" title="如何保证消息在 MQ 中顺序性"></a>如何保证消息在 MQ 中顺序性</h3><p>对于 Kafka，如果我们创建了一个 topic，默认有三个 partition。生产者在写数据的时候，可以指定一个 key，比如在订单 topic 中我们可以指定订单 id 作为 key，那么相同订单 id 的数据，一定会被分发到同一个 partition 中去，而且这个 partition 中的数据一定是有顺序的。消费者从 partition 中取出来数据的时候，也一定是有顺序的。通过制定 key 的方式首先可以保证在 kafka 内部消息是有序的。</p><h3 id="如何保证消费者处理消费的顺序性"><a href="#如何保证消费者处理消费的顺序性" class="headerlink" title="如何保证消费者处理消费的顺序性"></a>如何保证消费者处理消费的顺序性</h3><p>对于某个 topic 的一个 partition，只能被同组内部的一个 consumer 消费，如果这个 consumer 内部还是单线程处理，那么其实只要保证消息在 MQ 内部是有顺序的就可以保证消费也是有顺序的。但是单线程吞吐量太低，在处理大量 MQ 消息时，我们一般会开启多线程消费机制，那么如何保证消息在多个线程之间是被顺序处理的呢？对于多线程消费我们可以预先设置 N 个内存 Queue，具有相同 key 的数据都放到同一个内存 Queue 中；然后开启 N 个线程，每个线程分别消费一个内存 Queue 的数据即可，这样就能保证顺序性。当然，消息放到内存 Queue 中，有可能还未被处理，consumer 发生宕机，内存 Queue 中的数据会全部丢失，这就转变为上面提到的<strong>如何保证消息的可靠传输</strong>的问题了。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.cnblogs.com/qingyunzong/p/9004703.html" target="_blank" rel="noopener">Kafka学习之路 （三）Kafka的高可用</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景描述&quot;&gt;&lt;a href=&quot;#背景描述&quot; class=&quot;headerlink&quot; title=&quot;背景描述&quot;&gt;&lt;/a&gt;背景描述&lt;/h2&gt;&lt;p&gt;目前，很多的业务系统都会或多或少的使用各种 MQ 消息队列框架，例如：&lt;code&gt;RabbitMQ&lt;/code&gt;、&lt;code
      
    
    </summary>
    
    
      <category term="架构" scheme="https://dongzl.github.io/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="kafka" scheme="https://dongzl.github.io/tags/kafka/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 主从复制原理及配置</title>
    <link href="https://dongzl.github.io/2020/03/15/12-MySQL-Master-Slave-Replication/"/>
    <id>https://dongzl.github.io/2020/03/15/12-MySQL-Master-Slave-Replication/</id>
    <published>2020-03-15T03:04:01.000Z</published>
    <updated>2020-03-15T11:52:19.478Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MySQL-主从复制原理"><a href="#MySQL-主从复制原理" class="headerlink" title="MySQL 主从复制原理"></a>MySQL 主从复制原理</h2><h3 id="什么是-MySQL-的主从复制"><a href="#什么是-MySQL-的主从复制" class="headerlink" title="什么是 MySQL 的主从复制"></a>什么是 MySQL 的主从复制</h3><p>MySQL 主从复制是指数据可以从一个 MySQL 数据库服务器主节点复制到一个或多个从节点。MySQL 默认采用异步复制方式，这样从节点不用一直访问主服务器来更新自己的数据，数据的更新可以在远程连接上进行，从节点可以复制主数据库中的所有数据库或者特定的数据库，或者特定的表。</p><h3 id="为什么需要主从复制"><a href="#为什么需要主从复制" class="headerlink" title="为什么需要主从复制"></a>为什么需要主从复制</h3><ul><li>提高数据库读写性能，提升系统吞吐量</li></ul><p>在业务复杂的系统中，如果有一条 SQL 语句的执行需要锁表，导致 MySQL 暂时不能提供读的服务，那么就很影响运行中的业务，使用主从复制，让主库负责写，从库负责读，这样即使主库出现了锁表的情景，通过读从库也可以保证业务的正常运作。</p><ul><li><p>做数据库热备</p></li><li><p>架构扩展需要</p></li></ul><p>业务量越来越大，I/O 访问频率过高，单机无法满足，此时做多库的存储，降低磁盘I/O 访问的频率，提升整个数据库性能。</p><h3 id="MySQL-的复制原理"><a href="#MySQL-的复制原理" class="headerlink" title="MySQL 的复制原理"></a>MySQL 的复制原理</h3><p><strong>原理</strong>：</p><ul><li><p>master 服务器将数据的改变记录二进制 binlog 日志，当 master 上的数据发生改变时，则将其改变写入二进制日志中；</p></li><li><p>slave 服务器会在一定时间间隔内对 master 二进制日志进行探测其是否发生改变，如果发生改变，则开始一个 I/OThread 请求 master 二进制事件；</p></li><li><p>同时主节点为每个 I/O 线程启动一个 dump 线程，用于向其发送二进制事件，并保存至从节点本地的中继日志中，从节点将启动 SQL 线程从中继日志中读取二进制日志，在本地重放，使得其数据和主节点的保持一致，最后 I/OThread 和 SQLThread 将进入睡眠状态，等待下一次被唤醒。</p></li></ul><p><strong>也就是</strong>：</p><ul><li><p>从库会生成两个线程,一个 I/O 线程,一个 SQL 线程；</p></li><li><p>I/O 线程会去请求主库的 binlog，并将得到的 binlog 写到本地的 relay-log（中继日志）文件中；主库会生成一个 log dump 线程,用来给从库 I/O 线程传 binlog；</p></li><li><p>SQL 线程，会读取 relay log 文件中的日志，并解析成sql语句逐一执行。</p></li></ul><p><strong>注意</strong>：</p><ul><li><p>master 将操作语句记录到 binlog 日志中，然后授予 slave 远程连接的权限（master 一定要开启 binlog 二进制日志功能；通常为了数据安全考虑，slave 也开启binlog功能）；</p></li><li><p>slave 开启两个线程：IO 线程和 SQL 线程。其中：IO 线程负责读取 master 的 binlog 内容到中继日志 relay log 里；SQL 线程负责从 relay log 日志里读出 binlog 内容，并更新到 slave 的数据库里，这样就能保证 slave 数据和 master 数据保持一致了；</p></li><li><p>MySQL 复制至少需要两个 MySQL 的服务，当然 MySQL 服务可以分布在不同的服务器上，也可以在一台服务器上启动多个服务；</p></li><li><p>MySQL复制最好确保 master 和 slave 服务器上的 MySQL 版本相同（如果不能满足版本一致，那么要保证 master 主节点的版本低于 slave 从节点的版本）；</p></li><li><p>master 和 slave 两节点间时间需同步。</p></li></ul><img src="https://gitee.com/dongzl/article-images/raw/master/2020/12-MySQL-Master-Slave-Replication/MySQL-Master-Slave-Replication-01.jpeg"><p><strong>具体步骤</strong>：</p><ul><li><p>从库通过手工执行 change master to 语句连接主库，提供了连接的用户一切条件（user 、password、port、ip），并且让从库知道，二进制日志的起点位置（file名 position 号）start slave；</p></li><li><p>从库的 IO 线程和主库的 dump 线程建立连接；</p></li><li><p>从库根据 change master to 语句提供的 file 名和 position 号，IO 线程向主库发起 binlog 的请求；</p></li><li><p>主库 dump 线程根据从库的请求，将本地 binlog 以 events 的方式发给从库IO 线程；</p></li><li><p>从库 IO 线程接收 binlog events，并存放到本地 relay-log 中，传送过来的信息，会记录到 <code>master.info</code> 中；</p></li><li><p>从库 SQL 线程应用 relay-log，并且把应用过的记录到 <code>relay-log.info</code> 中，默认情况下，已经应用过的 relay 会自动被清理 purge。</p></li></ul><h3 id="MySQL-主从复制的形式"><a href="#MySQL-主从复制的形式" class="headerlink" title="MySQL 主从复制的形式"></a>MySQL 主从复制的形式</h3><ul><li><p>一主一从</p></li><li><p>主主复制</p></li><li><p>一主多从</p></li><li><p>多主一从</p></li><li><p>级联复制</p></li></ul><img src="https://gitee.com/dongzl/article-images/raw/master/2020/12-MySQL-Master-Slave-Replication/MySQL-Master-Slave-Replication-02.png"><h3 id="MySQL-主从复制延时分析"><a href="#MySQL-主从复制延时分析" class="headerlink" title="MySQL 主从复制延时分析"></a>MySQL 主从复制延时分析</h3><p>MySQL 的主从复制都是单线程的操作，主库对所有 DDL 和 DML 产生的日志写进 binlog，由于 binlog 是顺序写，所以效率很高，slave 的 SQL thread 线程将主库的 DDL 和 DML 操作事件在 slave 中重放。DML 和 DDL 的 IO 操作是随机的，不是顺序，所以成本要高很多，另一方面，由于 SQL thread 也是单线程的，当主库的并发较高时，产生的 DML 数量超过 slave 的 SQL thread 所能处理的速度，或者当 slave 中有大型 query 语句产生了锁等待，那么延时就产生了。</p><p><strong>解决方案</strong>：</p><ul><li>业务的持久层实现采用分库架构，mysql 服务可以水平扩展，分散压力；</li><li>单个库读写分离，一主多从，主写从读，分散压力；这样从库压力可能会比主库高，保护主库。</li><li>服务的基础架构在业务系统和mysql之间加入memcache或者redis 的cache层，降低mysql读压力。</li><li>不同业务的mysql物理上放在不同的机器，分散压力。</li><li>使用比主库更好的硬件设备作为slave，mysql压力小，延迟自然会变小。</li><li>使用更加强劲的硬件设备。</li></ul><h2 id="MySQL-主从复制安装配置"><a href="#MySQL-主从复制安装配置" class="headerlink" title="MySQL 主从复制安装配置"></a>MySQL 主从复制安装配置</h2><h3 id="基础设置准备"><a href="#基础设置准备" class="headerlink" title="基础设置准备"></a>基础设置准备</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">操作系统：</span></span><br><span class="line">centos6.5</span><br><span class="line"><span class="meta">#</span><span class="bash">mysql版本：</span></span><br><span class="line">5.7</span><br><span class="line"><span class="meta">#</span><span class="bash">两台虚拟机：</span></span><br><span class="line">node1:192.168.85.111（主）</span><br><span class="line">node2:192.168.85.112（从）</span><br></pre></td></tr></table></figure><h3 id="安装-MySQL-数据库"><a href="#安装-MySQL-数据库" class="headerlink" title="安装 MySQL 数据库"></a>安装 MySQL 数据库</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">## 在两台数据库中分别创建数据库</span></span></span><br><span class="line"></span><br><span class="line">```sql</span><br><span class="line">--注意两台必须全部执行</span><br><span class="line">create database test;</span><br></pre></td></tr></table></figure><h3 id="在主（node1）服务器进行如下配置："><a href="#在主（node1）服务器进行如下配置：" class="headerlink" title="在主（node1）服务器进行如下配置："></a>在主（node1）服务器进行如下配置：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">修改配置文件，执行以下命令打开mysql配置文件</span></span><br><span class="line">vi /etc/my.cnf</span><br><span class="line"><span class="meta">#</span><span class="bash">在mysqld模块中添加如下配置信息</span></span><br><span class="line">log-bin=master-bin #二进制文件名称</span><br><span class="line">binlog-format=ROW  #二进制日志格式，有row、statement、mixed三种格式，row指的是把改变的内容复制过去，而不是把命令在从服务器上执行一遍，statement指的是在主服务器上执行的SQL语句，在从服务器上执行同样的语句。MySQL默认采用基于语句的复制，效率比较高。mixed指的是默认采用基于语句的复制，一旦发现基于语句的无法精确的复制时，就会采用基于行的复制。</span><br><span class="line">server-id=1   #要求各个服务器的id必须不一样</span><br><span class="line">binlog-do-db=test   #同步的数据库名称</span><br></pre></td></tr></table></figure><h3 id="配置从服务器登录主服务器的账号授权"><a href="#配置从服务器登录主服务器的账号授权" class="headerlink" title="配置从服务器登录主服务器的账号授权"></a>配置从服务器登录主服务器的账号授权</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--授权操作</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> validate_password_policy=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> validate_password_length=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">replication</span> <span class="keyword">slave</span> <span class="keyword">on</span> *.* <span class="keyword">to</span> <span class="string">'root'</span>@<span class="string">'%'</span> <span class="keyword">identified</span> <span class="keyword">by</span> <span class="string">'123456'</span>;</span><br><span class="line"><span class="comment">--刷新权限</span></span><br><span class="line"><span class="keyword">flush</span> <span class="keyword">privileges</span>;</span><br></pre></td></tr></table></figure><h3 id="从服务器的配置"><a href="#从服务器的配置" class="headerlink" title="从服务器的配置"></a>从服务器的配置</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">修改配置文件，执行以下命令打开mysql配置文件</span></span><br><span class="line">vi /etc/my.cnf</span><br><span class="line"><span class="meta">#</span><span class="bash">在mysqld模块中添加如下配置信息</span></span><br><span class="line">log-bin=master-bin#二进制文件的名称</span><br><span class="line">binlog-format=ROW#二进制文件的格式</span><br><span class="line">server-id=2#服务器的id</span><br></pre></td></tr></table></figure><h3 id="重启主服务器的mysqld服务"><a href="#重启主服务器的mysqld服务" class="headerlink" title="重启主服务器的mysqld服务"></a>重启主服务器的mysqld服务</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">重启mysql服务</span></span><br><span class="line">service mysqld restart</span><br><span class="line"><span class="meta">#</span><span class="bash">登录mysql数据库</span></span><br><span class="line">mysql -uroot -p</span><br><span class="line"><span class="meta">#</span><span class="bash">查看master的状态</span></span><br><span class="line">show master status；</span><br></pre></td></tr></table></figure><h3 id="重启从服务器并进行相关配置"><a href="#重启从服务器并进行相关配置" class="headerlink" title="重启从服务器并进行相关配置"></a>重启从服务器并进行相关配置</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">重启mysql服务</span></span><br><span class="line">service mysqld restart</span><br><span class="line"><span class="meta">#</span><span class="bash">登录mysql</span></span><br><span class="line">mysql -uroot -p</span><br><span class="line"><span class="meta">#</span><span class="bash">连接主服务器</span></span><br><span class="line">change master to master_host='192.168.85.11',master_user='root',master_password='123456',master_port=3306,master_log_file='master-bin.000001',master_log_pos=154;</span><br><span class="line"><span class="meta">#</span><span class="bash">启动slave</span></span><br><span class="line">start slave</span><br><span class="line"><span class="meta">#</span><span class="bash">查看slave的状态</span></span><br><span class="line">show slave status\G(注意没有分号)</span><br></pre></td></tr></table></figure><blockquote><p>内容来源：<a href="http://www.mashibing.com/" target="_blank" rel="noopener">马士兵教育</a> 公开课内容知识整理</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;MySQL-主从复制原理&quot;&gt;&lt;a href=&quot;#MySQL-主从复制原理&quot; class=&quot;headerlink&quot; title=&quot;MySQL 主从复制原理&quot;&gt;&lt;/a&gt;MySQL 主从复制原理&lt;/h2&gt;&lt;h3 id=&quot;什么是-MySQL-的主从复制&quot;&gt;&lt;a href=
      
    
    </summary>
    
    
      <category term="数据库" scheme="https://dongzl.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="主从复制" scheme="https://dongzl.github.io/tags/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
    
      <category term="MySQL" scheme="https://dongzl.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 数据库优化知识总结</title>
    <link href="https://dongzl.github.io/2020/03/14/11-MySQL-Optimization-Knowledge-Summary/"/>
    <id>https://dongzl.github.io/2020/03/14/11-MySQL-Optimization-Knowledge-Summary/</id>
    <published>2020-03-14T14:06:18.000Z</published>
    <updated>2020-03-15T02:56:38.528Z</updated>
    
    <content type="html"><![CDATA[<h2 id="性能监控"><a href="#性能监控" class="headerlink" title="性能监控"></a>性能监控</h2><h3 id="show-profile-查询剖析工具"><a href="#show-profile-查询剖析工具" class="headerlink" title="show profile 查询剖析工具"></a>show profile 查询剖析工具</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">## https://dev.mysql.com/doc/refman/5.7/en/show-profile.html</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">profiles</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">## 开启 show profile 监控</span></span><br><span class="line"><span class="keyword">set</span> profiling=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">## 根据 Type 查询</span></span><br><span class="line"><span class="keyword">show</span> profile cpu <span class="keyword">for</span> <span class="keyword">query</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">show</span> profile <span class="keyword">all</span> <span class="keyword">for</span> <span class="keyword">query</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">## 未来有可能被移除，推荐使用 Performance Schema</span></span><br><span class="line">Note: </span><br><span class="line">The <span class="keyword">SHOW</span> PROFILE <span class="keyword">and</span> <span class="keyword">SHOW</span> <span class="keyword">PROFILES</span> statements <span class="keyword">are</span> deprecated <span class="keyword">and</span> will be removed <span class="keyword">in</span> a future MySQL release. </span><br><span class="line"><span class="keyword">Use</span> the <span class="keyword">Performance</span> <span class="keyword">Schema</span> instead; see Section 25.19.1, “Query Profiling Using Performance Schema”.</span><br><span class="line"></span><br><span class="line"><span class="comment">## 查看MySQL支持存储引擎类型</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">engines</span>;</span><br></pre></td></tr></table></figure><h3 id="Performance-Schema-库"><a href="#Performance-Schema-库" class="headerlink" title="Performance Schema 库"></a>Performance Schema 库</h3><p>5.7 新提供自带监控数据库，有 87 张数据表。</p><p><a href="https://dev.mysql.com/doc/refman/5.7/en/performance-schema.html" target="_blank" rel="noopener">MySQL Performance Schema</a></p><h3 id="使用-show-processlist-查看连接"><a href="#使用-show-processlist-查看连接" class="headerlink" title="使用 show processlist 查看连接"></a>使用 show processlist 查看连接</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">processlist</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'%max_connection%'</span>;</span><br></pre></td></tr></table></figure><h2 id="schema-与数据类型优化"><a href="#schema-与数据类型优化" class="headerlink" title="schema 与数据类型优化"></a>schema 与数据类型优化</h2><h3 id="数据类型优化"><a href="#数据类型优化" class="headerlink" title="数据类型优化"></a>数据类型优化</h3><ul><li>更小的通常更好</li><li>简单就好<ul><li>整型比字符类型代价更低</li><li>使用MySQL自带类型而不是字符串类型还存储日期和时间</li><li>用整型存储IP地址</li></ul></li></ul><ul><li>尽量避免 null</li><li>实际细则</li></ul><h3 id="索引优化细节"><a href="#索引优化细节" class="headerlink" title="索引优化细节"></a>索引优化细节</h3><ul><li><p>当使用索引列进行查询的时候尽量不要使用表达式，把计算放到业务层而不是数据层（表达式会导致索引失效）；</p></li><li><p>尽量使用主键查询，而不是其它索引，因为主键查询不会触发回表查询，减少 IO 次数；</p></li><li><p>使用前缀索引，前缀索引可以减少空间占用；</p></li><li><p>使用索引扫描来排序；</p></li><li><p>union all，in，or 都能够使用索引，但是推荐使用 in；</p></li><li><p>范围列可以用到索引；</p></li><li><p>强制类型转换会导致全表扫描，即索引失效；</p></li><li><p>更新十分频繁，数据区分度不高的字段上不宜建立索引；</p></li><li><p>创建索引的列，不允许为 null，可能会得到不符合预期的结果（null != null）；</p></li><li><p>当需要进行表连接的时候，最好不要超过三张表，因为需要 join 的字段，数据类型必须一致；</p></li><li><p>能使用 limit 的时候尽量使用 limit，减少后续查询操作（limit 1）；</p></li><li><p>单表索引建议控制在 5 个以内；</p></li><li><p>单索引字段数不允许超过 5 个（组合索引字段个数）；</p></li><li><p>创建索引的时候需要避免的错误概念：1、索引越多越好；2、过早优化，在不了解系统的情况下进行优化。</p></li></ul><h2 id="MySQL-执行计划"><a href="#MySQL-执行计划" class="headerlink" title="MySQL 执行计划"></a>MySQL 执行计划</h2><p>​在企业的应用场景中，为了知道优化SQL语句的执行，需要查看SQL语句的具体执行过程，以加快SQL语句的执行效率。</p><p>可以使用 explain + SQL 语句来模拟优化器执行 SQL 查询语句，从而知道 MySQL 是如何处理 SQL 语句的。</p><p>​<a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html" target="_blank" rel="noopener">EXPLAIN Output Format</a></p><h3 id="执行计划中包含的信息"><a href="#执行计划中包含的信息" class="headerlink" title="执行计划中包含的信息"></a>执行计划中包含的信息</h3><table><thead><tr><th align="center">Column</th><th align="center">Meaning</th></tr></thead><tbody><tr><td align="center">id</td><td align="center">The <code>SELECT</code> identifier</td></tr><tr><td align="center">select_type</td><td align="center">The <code>SELECT</code> type</td></tr><tr><td align="center">table</td><td align="center">The table for the output row</td></tr><tr><td align="center">partitions</td><td align="center">The matching partitions</td></tr><tr><td align="center">type</td><td align="center">The join type</td></tr><tr><td align="center">possible_keys</td><td align="center">The possible indexes to choose</td></tr><tr><td align="center">key</td><td align="center">The index actually chosen</td></tr><tr><td align="center">key_len</td><td align="center">The length of the chosen key</td></tr><tr><td align="center">ref</td><td align="center">The columns compared to the index</td></tr><tr><td align="center">rows</td><td align="center">Estimate of rows to be examined</td></tr><tr><td align="center">filtered</td><td align="center">Percentage of rows filtered by table condition</td></tr><tr><td align="center">extra</td><td align="center">Additional information</td></tr></tbody></table><p><strong>id</strong></p><p>select 查询的序列号，包含一组数字，表示查询中执行 select 子句或者操作表的顺序</p><p>id 号分为三种情况：</p><p>​1、如果 id 相同，那么执行顺序从上到下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp e <span class="keyword">join</span> dept d <span class="keyword">on</span> e.deptno = d.deptno <span class="keyword">join</span> salgrade sg <span class="keyword">on</span> e.sal <span class="keyword">between</span> sg.losal <span class="keyword">and</span> sg.hisal;</span><br></pre></td></tr></table></figure><p>​2、如果 id 不同，如果是子查询，id 的序号会递增，id 值越大优先级越高，越先被执行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp e <span class="keyword">where</span> e.deptno <span class="keyword">in</span> (<span class="keyword">select</span> d.deptno <span class="keyword">from</span> dept d <span class="keyword">where</span> d.dname = <span class="string">'SALES'</span>);</span><br></pre></td></tr></table></figure><p>3、id 相同和不同的，同时存在：相同的可以认为是一组，从上往下顺序执行，在所有组中，id 值越大，优先级越高，越先执行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp e <span class="keyword">join</span> dept d <span class="keyword">on</span> e.deptno = d.deptno <span class="keyword">join</span> salgrade sg <span class="keyword">on</span> e.sal <span class="keyword">between</span> sg.losal <span class="keyword">and</span> sg.hisal <span class="keyword">where</span> e.deptno <span class="keyword">in</span> (<span class="keyword">select</span> d.deptno <span class="keyword">from</span> dept d <span class="keyword">where</span> d.dname = <span class="string">'SALES'</span>);</span><br></pre></td></tr></table></figure><p><strong>select_type</strong></p><p>主要用来分辨查询的类型，是普通查询还是联合查询还是子查询</p><table><thead><tr><th align="center"><code>select_type</code> Value</th><th align="center">Meaning</th></tr></thead><tbody><tr><td align="center">SIMPLE</td><td align="center">Simple SELECT (not using UNION or subqueries)</td></tr><tr><td align="center">PRIMARY</td><td align="center">Outermost SELECT</td></tr><tr><td align="center">UNION</td><td align="center">Second or later SELECT statement in a UNION</td></tr><tr><td align="center">DEPENDENT UNION</td><td align="center">Second or later SELECT statement in a UNION, dependent on outer query</td></tr><tr><td align="center">UNION RESULT</td><td align="center">Result of a UNION.</td></tr><tr><td align="center">SUBQUERY</td><td align="center">First SELECT in subquery</td></tr><tr><td align="center">DEPENDENT SUBQUERY</td><td align="center">First SELECT in subquery, dependent on outer query</td></tr><tr><td align="center">DERIVED</td><td align="center">Derived table</td></tr><tr><td align="center">UNCACHEABLE SUBQUERY</td><td align="center">A subquery for which the result cannot be cached and must be re-evaluated for each row of the outer query</td></tr><tr><td align="center">UNCACHEABLE UNION</td><td align="center">The second or later select in a UNION that belongs to an uncacheable subquery (see UNCACHEABLE SUBQUERY)</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--sample:简单的查询，不包含子查询和union</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp;</span><br><span class="line"></span><br><span class="line"><span class="comment">--primary:查询中若包含任何复杂的子查询，最外层查询则被标记为Primary</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> staname,ename supname <span class="keyword">from</span> (<span class="keyword">select</span> ename staname,mgr <span class="keyword">from</span> emp) t <span class="keyword">join</span> emp <span class="keyword">on</span> t.mgr=emp.empno ;</span><br><span class="line"></span><br><span class="line"><span class="comment">--union:若第二个select出现在union之后，则被标记为union</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> deptno = <span class="number">10</span> <span class="keyword">union</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> sal &gt;<span class="number">2000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--dependent union:跟union类似，此处的depentent表示union或union all联合而成的结果会受外部表影响</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp e <span class="keyword">where</span> e.empno  <span class="keyword">in</span> ( <span class="keyword">select</span> empno <span class="keyword">from</span> emp <span class="keyword">where</span> deptno = <span class="number">10</span> <span class="keyword">union</span> <span class="keyword">select</span> empno <span class="keyword">from</span> emp <span class="keyword">where</span> sal &gt;<span class="number">2000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">--union result:从union表获取结果的select</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> deptno = <span class="number">10</span> <span class="keyword">union</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> sal &gt;<span class="number">2000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--subquery:在select或者where列表中包含子查询</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> sal &gt; (<span class="keyword">select</span> <span class="keyword">avg</span>(sal) <span class="keyword">from</span> emp) ;</span><br><span class="line"></span><br><span class="line"><span class="comment">--dependent subquery:subquery的子查询要受到外部表查询的影响</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp e <span class="keyword">where</span> e.deptno <span class="keyword">in</span> (<span class="keyword">select</span> <span class="keyword">distinct</span> deptno <span class="keyword">from</span> dept);</span><br><span class="line"></span><br><span class="line"><span class="comment">--DERIVED: from子句中出现的子查询，也叫做派生类，</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> staname,ename supname <span class="keyword">from</span> (<span class="keyword">select</span> ename staname,mgr <span class="keyword">from</span> emp) t <span class="keyword">join</span> emp <span class="keyword">on</span> t.mgr=emp.empno ;</span><br><span class="line"></span><br><span class="line"><span class="comment">--UNCACHEABLE SUBQUERY：表示使用子查询的结果不能被缓存</span></span><br><span class="line"> <span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> empno = (<span class="keyword">select</span> empno <span class="keyword">from</span> emp <span class="keyword">where</span> deptno=@@sort_buffer_size);</span><br><span class="line"> </span><br><span class="line"><span class="comment">--uncacheable union:表示union的查询结果不能被缓存：sql语句未验证</span></span><br></pre></td></tr></table></figure><p><strong>table</strong></p><p>对应行正在访问哪一个表，表名或者别名，可能是临时表或者 union 合并结果集</p><p>1、如果是具体的表名，则表明从实际的物理表中获取数据，当然也可以是表的别名</p><p>2、表名是 derivedN 的形式，表示使用了 id 为 N 的查询产生的衍生表</p><p>3、当有 union result 的时候，表名是 union n1,n2 等的形式，n1,n2 表示参与 union 的 id</p><p><strong>type</strong></p><p>type 显示的是访问类型，访问类型表示我是以何种方式去访问我们的数据，最容易想的是全表扫描，直接暴力的遍历一张表去寻找需要的数据，效率非常低下，访问的类型有很多，效率从最好到最坏依次是：</p><p>system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL </p><p>一般情况下，得保证查询至少达到 range 级别，最好能达到 ref</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--all:全表扫描，一般情况下出现这样的sql语句而且数据量比较大的话那么就需要进行优化。</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp;</span><br><span class="line"></span><br><span class="line"><span class="comment">--index：全索引扫描这个比all的效率要好，主要有两种情况，一种是当前的查询时覆盖索引，即我们需要的数据在索引中就可以索取，或者是使用了索引进行排序，这样就避免数据的重排序</span></span><br><span class="line"><span class="keyword">explain</span>  <span class="keyword">select</span> empno <span class="keyword">from</span> emp;</span><br><span class="line"></span><br><span class="line"><span class="comment">--range：表示利用索引查询的时候限制了范围，在指定范围内进行查询，这样避免了index的全索引扫描，适用的操作符： =, &lt;&gt;, &gt;, &gt;=, &lt;, &lt;=, IS NULL, BETWEEN, LIKE, or IN() </span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> empno <span class="keyword">between</span> <span class="number">7000</span> <span class="keyword">and</span> <span class="number">7500</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--index_subquery：利用索引来关联子查询，不再扫描全表</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> emp.job <span class="keyword">in</span> (<span class="keyword">select</span> job <span class="keyword">from</span> t_job);</span><br><span class="line"></span><br><span class="line"><span class="comment">--unique_subquery:该连接类型类似与index_subquery,使用的是唯一索引</span></span><br><span class="line"> <span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp e <span class="keyword">where</span> e.deptno <span class="keyword">in</span> (<span class="keyword">select</span> <span class="keyword">distinct</span> deptno <span class="keyword">from</span> dept);</span><br><span class="line"> </span><br><span class="line"><span class="comment">--index_merge：在查询过程中需要多个索引组合使用，没有模拟出来</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--ref_or_null：对于某个字段即需要关联条件，也需要null值的情况下，查询优化器会选择这种访问方式</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp e <span class="keyword">where</span>  e.mgr <span class="keyword">is</span> <span class="literal">null</span> <span class="keyword">or</span> e.mgr=<span class="number">7369</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--ref：使用了非唯一性索引进行数据的查找</span></span><br><span class="line"> <span class="keyword">create</span> <span class="keyword">index</span> idx_3 <span class="keyword">on</span> emp(deptno);</span><br><span class="line"> <span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp e,dept d <span class="keyword">where</span> e.deptno =d.deptno;</span><br><span class="line"></span><br><span class="line"><span class="comment">--eq_ref ：使用唯一性索引进行数据查找</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp,emp2 <span class="keyword">where</span> emp.empno = emp2.empno;</span><br><span class="line"></span><br><span class="line"><span class="comment">--const：这个表至多有一个匹配行，</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> empno = <span class="number">7369</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">--system：表只有一行记录（等于系统表），这是const类型的特例，平时不会出现</span></span><br></pre></td></tr></table></figure><p> <strong>possible_keys</strong> </p><p>显示可能应用在这张表中的索引，一个或多个，查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询实际使用</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp,dept <span class="keyword">where</span> emp.deptno = dept.deptno <span class="keyword">and</span> emp.deptno = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p><strong>key</strong></p><p>实际使用的索引，如果为 null，则没有使用索引，查询中若使用了覆盖索引，则该索引和查询的 select 字段重叠。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp,dept <span class="keyword">where</span> emp.deptno = dept.deptno <span class="keyword">and</span> emp.deptno = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p><strong>key_len</strong></p><p>表示索引中使用的字节数，可以通过 key_len 计算查询中使用的索引长度，在不损失精度的情况下长度越短越好。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp,dept <span class="keyword">where</span> emp.deptno = dept.deptno <span class="keyword">and</span> emp.deptno = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p><strong>ref</strong></p><p>显示索引的哪一列被使用了，如果可能的话，是一个常数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp,dept <span class="keyword">where</span> emp.deptno = dept.deptno <span class="keyword">and</span> emp.deptno = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p><strong>rows</strong></p><p>根据表的统计信息及索引使用情况，大致估算出找出所需记录需要读取的行数，此参数很重要，直接反应的 SQL 找了多少数据，在完成目的的情况下越少越好</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp;</span><br></pre></td></tr></table></figure><p><strong>extra</strong></p><p>包含额外的信息。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--using filesort:说明mysql无法利用索引进行排序，只能利用排序算法进行排序，会消耗额外的位置</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">order</span> <span class="keyword">by</span> sal;</span><br><span class="line"></span><br><span class="line"><span class="comment">--using temporary:建立临时表来保存中间结果，查询完成之后把临时表删除</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> ename,<span class="keyword">count</span>(*) <span class="keyword">from</span> emp <span class="keyword">where</span> deptno = <span class="number">10</span> <span class="keyword">group</span> <span class="keyword">by</span> ename;</span><br><span class="line"></span><br><span class="line"><span class="comment">--using index:这个表示当前的查询时覆盖索引的，直接从索引中读取数据，而不用访问数据表。如果同时出现using where 表名索引被用来执行索引键值的查找，如果没有，表面索引被用来读取数据，而不是真的查找</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> deptno,<span class="keyword">count</span>(*) <span class="keyword">from</span> emp <span class="keyword">group</span> <span class="keyword">by</span> deptno <span class="keyword">limit</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--using where:使用where进行条件过滤</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> t_user <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--using join buffer:使用连接缓存，情况没有模拟出来</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--impossible where：where语句的结果总是false</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> empno = <span class="number">7469</span>;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://zhenganwen.top/posts/433a3305/" target="_blank" rel="noopener">MySQL优化面试</a></li><li><a href="http://tigcms.jd.com/details/HkO5QrfPQ.html" target="_blank" rel="noopener">MySQL explain详解</a></li><li><a href="http://tigcms.jd.com/details/ryG-r2dM7.html" target="_blank" rel="noopener">MySQL数据库开发规范</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;性能监控&quot;&gt;&lt;a href=&quot;#性能监控&quot; class=&quot;headerlink&quot; title=&quot;性能监控&quot;&gt;&lt;/a&gt;性能监控&lt;/h2&gt;&lt;h3 id=&quot;show-profile-查询剖析工具&quot;&gt;&lt;a href=&quot;#show-profile-查询剖析工具&quot; class
      
    
    </summary>
    
    
      <category term="数据库" scheme="https://dongzl.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MySQL" scheme="https://dongzl.github.io/tags/MySQL/"/>
    
      <category term="优化" scheme="https://dongzl.github.io/tags/%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 数据库索引的实现原理</title>
    <link href="https://dongzl.github.io/2020/03/14/10-The-Implementation-Principles-Of-MySQL-Index/"/>
    <id>https://dongzl.github.io/2020/03/14/10-The-Implementation-Principles-Of-MySQL-Index/</id>
    <published>2020-03-14T05:52:04.000Z</published>
    <updated>2020-03-16T03:00:59.576Z</updated>
    
    <content type="html"><![CDATA[<h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><blockquote><p>1、MySQL 数据库索引分类。<br>2、MySQL 数据库 InnoDB 存储引擎的底层数据结构。<br>3、为什么底层使用 B+ 树而不用 B 树</p></blockquote><h2 id="MySQL-架构"><a href="#MySQL-架构" class="headerlink" title="MySQL 架构"></a>MySQL 架构</h2><img src="https://gitee.com/dongzl/article-images/raw/master/2020/10-The-Implementation-Principles-Of-MySQL-Index/The-Implementation-Principles-Of-MySQL-Index-03.png"><h2 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h2><p>MySQL 索引分五种类型：主键索引、唯一索引、普通索引和全文索引、组合索引。通过给字段添加索引可以提高数据的读取速度，提高项目的并发能力和抗压能力。</p><ul><li><p>主键索引：主键是一种唯一性索引，但它必须指定为 PRIMARY KEY，每个表只能有一个主键；</p></li><li><p>唯一索引：索引列的所有值都只能出现一次，即必须唯一，但是值可以为空；</p></li><li><p>普通索引：基本的索引类型，值可以为空，没有唯一性的限制；</p></li><li><p>全文索引：全文索引的索引类型为 FULLTEXT，全文索引可以在 varchar、char、text 类型的列上创建；（使用较少，一般都使用专门的搜索框架，例如 ElasticSearch）</p></li><li><p>组合索引：多列值组成一个索引，专门用于组合搜索。</p></li></ul><h2 id="MySQL-索引实现原理分析"><a href="#MySQL-索引实现原理分析" class="headerlink" title="MySQL 索引实现原理分析"></a>MySQL 索引实现原理分析</h2><p><strong>为什么没有使用 Hash 表的索引格式</strong></p><p>使用类似于 JDK 中 HashMap 的数据结构来存储索引数据，有如下特点：</p><ul><li><p>优点：查询速度快，Hash 数据结构查询时间复杂度为 O(1);</p></li><li><p>缺点：</p><ul><li>1、需要将数据文件 load 到内存，比较耗费内存空间；</li><li>2、Hash 快速查询只适合等值查询，对于范围查询效率低下，在实际工作中范围查询的场景比较多。</li></ul></li></ul><p><strong>为什么没有使用二叉树和红黑树索引格式</strong></p><p>无论是二叉树还是红黑树，都会因为树的深度过深而造成 IO 次数变多，影响数据读取效率。</p><p><strong>为什么没有使用 B 树索引格式</strong></p><p>B 树特点：</p><p>1、所有键值分布在整棵树中；<br>2、搜索有可能在非叶子节点结束，在关键字全集内做一次查找，性能逼近二分查找；<br>3、每个节点最多拥有 m 个子树；<br>4、根节点至少有 2 个子树；<br>5、分支节点至少拥有 m / 2 棵子树（除根节点和叶子节点外都是分支节点）；<br>6、所有叶子节点都在同一层、每个节点最多可以有 m - 1 个 key，并且以升序排列。</p><p>B 树缺点：</p><ul><li><p>每个节点都有 key，同时也包含 data，而每个页存储空间是有限的，如果 data 比较大的话会导致每个节点存储的 key 数量变小；</p></li><li><p>当存储的数据量很大的时候会导致深度较大，增大查询时磁盘 IO 次数，进而影响查询性能。</p></li></ul><img src="https://gitee.com/dongzl/article-images/raw/master/2020/10-The-Implementation-Principles-Of-MySQL-Index/The-Implementation-Principles-Of-MySQL-Index-01.png"><p><strong>MySQL B+ 树索引格式实现原理</strong></p><p>B+ 树是在 B 树的基础上做的一种优化，优化如下：</p><ul><li><p>B+ 树每个节点可以包含更多的节点（非叶子节点不在存储数据），这样做的原因有两个，第一是为了降低树的高度，第二个原因是将数据范围变为多个区间，区间越多，数据检索越快；</p></li><li><p>非叶子节点存储 key ，叶子节点存储 key 和数据；</p></li><li><p>叶子节点两两指针互相连接（符合磁盘的预读特性），顺序查询性能更高。</p></li></ul><p><strong>MySQL InnoDB–B+ 树，叶子节点直接存储数据</strong></p><ul><li><p>InnoDB 是通过 B+ 树结构对主键创建索引，在叶子节点中存储记录数据，如果没有主键，就选择唯一键，如果没有唯一键，那么会生成一个 6 位的 row_id 来作为主键；</p></li><li><p>如果创建索引的键是其他字段，那么在叶子节点中存储的是该记录的主键，然后在通过主键索引找到对应的记录，这个过程叫做回表。</p></li></ul><p><strong>MySQL MyISAM–B+ 树，叶子节点存储表中数据的地址</strong></p><img src="https://gitee.com/dongzl/article-images/raw/master/2020/10-The-Implementation-Principles-Of-MySQL-Index/The-Implementation-Principles-Of-MySQL-Index-02.png"><h2 id="MySQL-索引的一些其他内容"><a href="#MySQL-索引的一些其他内容" class="headerlink" title="MySQL 索引的一些其他内容"></a>MySQL 索引的一些其他内容</h2><h3 id="回表"><a href="#回表" class="headerlink" title="回表"></a>回表</h3><p>如果 MySQL 中的索引不是主键索引，在使用这个索引进行数据查询时，需要现在这个索引的 B+ 树中找到叶子节点存储的主键 ID，然后根据主键 ID 到主键索引的 B+ 树中查找到最终记录，这个过程就叫做回表。</p><h3 id="最左匹配原则"><a href="#最左匹配原则" class="headerlink" title="最左匹配原则"></a>最左匹配原则</h3><p>在创建联合索引时，如果在查询条件中包含索引的最左列，那么这个索引可以匹配到，如果不包含最左列，这个索引无法匹配，这个称做最左原则。</p><p>比如某个表有联合索引，索引字段为 (column1, column2)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a、<span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> column1 = <span class="string">'c1'</span> <span class="keyword">and</span> column2 = <span class="string">'c2'</span>;</span><br><span class="line"></span><br><span class="line">b、<span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> column2 = <span class="string">'c2'</span> <span class="keyword">and</span> column1 = <span class="string">'c1'</span>;</span><br><span class="line"></span><br><span class="line">c、<span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> column1 = <span class="string">'c1'</span>;</span><br><span class="line"></span><br><span class="line">d、<span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> column2 = <span class="string">'c2'</span>;</span><br></pre></td></tr></table></figure><p>上述 a、b、c 三个查询可以使用该索引，查询 d 无法使用该索引。</p><p>知识补充，如果上述四条SQL语句都希望走索引，需要创建两个索引：</p><p>组合索引: (column1, column2), 和 column2 单列索引；</p><p>或者是组合索引: (column2, column1), 和 column1 单列索引；</p><p>具体选择哪种方案，需要对比 column1、column2 字段类型，在满足查询优化情况尽量减少磁盘空间占用。</p><p>PS.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 范围查询只能用到 column2 列上索引，column2 上用不到</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> column1 &gt; <span class="string">'c1'</span> <span class="keyword">and</span> column2 = <span class="string">'c2'</span>;</span><br></pre></td></tr></table></figure><h3 id="索引覆盖"><a href="#索引覆盖" class="headerlink" title="索引覆盖"></a>索引覆盖</h3><p>如果索引中包含查询结果需要的全部字段，那么将不需要在回表查询该记录的所有数据，这个过程就是索引覆盖，覆盖索引在查询计划中表现为：<code>using index</code>。</p><h3 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h3><p>例如有 user_table 表，表上有 (user_name, age) 联合索引<br>如果现在有一个需求，查出名称中以“张”开头且年龄小于等于 10 的用户信息：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> user_table <span class="keyword">where</span> user_name <span class="keyword">like</span> <span class="string">'张%'</span> <span class="keyword">and</span> age &gt; <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>这条查询语句有两种执行可能：</p><ul><li><p>根据 (user_name, age) 联合索引查询所有满足名称以“张”开头的索引，然后回表查询出相应的全行数据，然后再筛选出满足年龄小于等于10的用户数据。</p></li><li><p>根据 (user_name, age) 联合索引查询所有满足名称以“张”开头的索引，然后直接再筛选出年龄小于等于10的索引，之后再回表查询全行数据。</p></li></ul><p>很明显，后一种方式需要回表查询的全行数据比较少，这就是 MySQL 的索引下推。</p><h3 id="聚簇索引与非聚簇索引"><a href="#聚簇索引与非聚簇索引" class="headerlink" title="聚簇索引与非聚簇索引"></a>聚簇索引与非聚簇索引</h3><p>聚簇索引并不是一种索引类型，而是一种数据存储方式，指的是数据行跟相邻的键值紧凑的存储在一起。费聚簇索引是指数据文件和索引文件分开存放。</p><p>MySQL 数据库中 InnoDB 存储引擎，B+ 树索引可以分为聚簇索引（也称聚集索引，clustered index）和辅助索引（有时也称非聚簇索引或二级索引，secondary index，non-clustered index）。这两种索引内部都是B+树，聚集索引的叶子节点存放着一整行的数据。</p><p>InnoDB 中的主键索引是一种聚簇索引，非聚簇索引都是辅助索引，像复合索引、前缀索引、唯一索引。</p><p>InnoDB 使用的是聚簇索引，MyISAM 使用的是非聚簇索引。</p><p><strong>聚簇索引的优缺点</strong>：</p><p>优点：</p><ul><li><p>数据访问更快，因为聚簇索引将索引和数据保存在同一个B+树中，因此从聚簇索引中获取数据比非聚簇索引更快；</p></li><li><p>聚簇索引对于主键的排序查找和范围查找速度非常快。</p></li></ul><p>缺点：</p><ul><li><p>插入速度严重依赖于插入顺序，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个自增的ID列为主键</p></li><li><p>更新主键的代价很高，因为将会导致被更新的行移动。因此，对于 InnoDB 表，我们一般定义主键为不可更新。</p></li><li><p>二级索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据。</p></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.jianshu.com/p/bdc9e57ccf8b" target="_blank" rel="noopener">MySQL 索引篇之覆盖索引、联合索引、索引下推</a></li><li><a href="https://blog.csdn.net/mccand1234/article/details/95799942" target="_blank" rel="noopener">索引下推（5.6版本+）</a></li><li><a href="https://zhenganwen.top/posts/433a3305/" target="_blank" rel="noopener">MySQL优化面试</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;面试题&quot;&gt;&lt;a href=&quot;#面试题&quot; class=&quot;headerlink&quot; title=&quot;面试题&quot;&gt;&lt;/a&gt;面试题&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;1、MySQL 数据库索引分类。&lt;br&gt;2、MySQL 数据库 InnoDB 存储引擎的底层数据结构。&lt;b
      
    
    </summary>
    
    
      <category term="数据库" scheme="https://dongzl.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MySQL" scheme="https://dongzl.github.io/tags/MySQL/"/>
    
      <category term="索引" scheme="https://dongzl.github.io/tags/%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 数据库事务 ACID 的实现原理</title>
    <link href="https://dongzl.github.io/2020/03/13/09-The-Implementation-Principles-Of-MySQL-ACID/"/>
    <id>https://dongzl.github.io/2020/03/13/09-The-Implementation-Principles-Of-MySQL-ACID/</id>
    <published>2020-03-13T13:39:26.000Z</published>
    <updated>2020-03-14T11:44:27.951Z</updated>
    
    <content type="html"><![CDATA[<h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><blockquote><p>MySQL 数据库的原子性和持久性怎么保证？</p></blockquote><blockquote><p>技术关键点：通过 undo log 保证原子性；通过 redo log 保证持久性。</p></blockquote><h2 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h2><p>首先介绍一下 MySQL 事务的 ACID 特性：</p><ul><li><p>原子性（Atomicity）：事务中所有操作作为一个整体像原子一样不可分割，要么全部成功，要么全部失败；</p></li><li><p>一致性（Consistency）：事务的执行结果必须使数据从一个一致性状态到另一个一致性状态。一致性状态是指：a. 系统的状态满足数据的完整性约束；b. 系统的状态反映数据库本应描述现实世界的真实状态，比如转账前后两个账户的金额总和应该保持不变；</p></li><li><p>隔离性（Isolation）：并发执行的事务不会互相影响，其对数据库的影响和他们串行执行时一样。比如多个用户同时往一个账户转账，最后账户的结果应该和他们按先后次序转账的结果一样；</p></li><li><p>持久性（Durability）：事务一旦提交，其对数据库的更新就是持久的。任何事务或系统故障都不会导致数据丢失。</p></li></ul><h3 id="事务的特点"><a href="#事务的特点" class="headerlink" title="事务的特点"></a>事务的特点</h3><p>事务的根本追求：数据一致性</p><p>可能会对事务一致性造成破坏的原因：</p><ul><li><p>事务的并发执行</p></li><li><p>事务故障或系统故障</p></li></ul><p>避免事务一致性被破坏的技术手段：</p><ul><li><p>并发控制技术（保证事务隔离性，防止事务并发执行破坏数据的一致性）</p></li><li><p>日志恢复技术（保证事务的原子性和持久性，防止事务故障或系统故障破坏数据一致性）</p></li></ul><img src="https://gitee.com/dongzl/article-images/raw/master/2020/09-The-Implementation-Principles-Of-MySQL-ACID/The-Implementation-Principles-Of-MySQL-ACID_01.png"><h3 id="事务的实现原理"><a href="#事务的实现原理" class="headerlink" title="事务的实现原理"></a>事务的实现原理</h3><ul><li><p>原子性：通过 undo log 来实现</p></li><li><p>持久性：通过 redo log 来实现</p></li><li><p>隔离性：读写锁 + MVCC 来实现</p></li><li><p>一致性：通过 原子性 + 隔离性 + 持久性 来实现</p></li></ul><p><strong>undo log 作用以及实现原理</strong></p><p>作用：保证事务原子性；实现多版本并发控制（MVCC）</p><p>原理：在操作任何数据之前，先将数据备份到 undo log，然后进行数据的修改，如果出现了错误或者 ROLLBACK 回滚事务，可以利用 undo log 中的备份将数据回复到事务开始之前的状态，undo log 是逻辑日志，可以理解为：</p><ul><li>当 delete 一条记录时，undo log 中会记录一条对应的 insert 记录；</li><li>当 insert 一条记录时，undo log 中会记录一条对应的 delete 记录；</li><li>当 update 一条记录时，它记录一条对应相反的 update 记录。</li></ul><p><strong>redo log 作用以及实现原理</strong></p><p>作用：保证事务的持久性</p><p>原理：redo log 记录的是新数据的备份。在事务提交前，只要将 redo log 持久化即可，不需要立即将数据持久化（预写式日志：WAL）。当系统崩溃时，虽然数据没有持久化，但是 redo log 已经持久化。系统可以根据 redo log 的内容，将所有的数据恢复到最新的状态。</p><p><strong>事务的隔离性</strong></p><p>事务具有隔离性，理论上来说事务之间的执行不应该互相影响，其对数据库的影响应该和串行执行时一样。</p><p>然而完全的隔离级别会导致系统并发性能很低，降低对资源的利用率，因此对事务的隔离性要求会放宽，这也会一定程度上造成对数据库一致性要求降低。</p><p>SQL 标准定义的事务的隔离级别：</p><ul><li><p>读未提交（READ UNCOMMITTED）：对事务处理没有任何限制，不推荐</p></li><li><p>读已提交（READ COMMITTED）：Oracle 数据库默认的隔离级别</p></li><li><p>可重复读（REPEATABLE READ）：MySQL 数据库默认隔离级别</p></li><li><p>串行化（SERIALIZABLE）：并发性能最低，不推荐</p></li></ul><p>不同的隔离级别可能导致的并发异常：</p><table><thead><tr><th>事务的隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>读未提交（READ UNCOMMITTED）</td><td>YES</td><td>YES</td><td>YES</td></tr><tr><td>读已提交（READ COMMITTED）</td><td></td><td>YES</td><td>YES</td></tr><tr><td>可重复读（REPEATABLE READ）</td><td></td><td></td><td>YES</td></tr><tr><td>串行化（SERIALIZABLE）</td><td></td><td></td><td></td></tr></tbody></table><p>设置事务的隔离级别操作：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 查看 MySQL 事务是否自动提交</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">session</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'autocommit'</span>;</span><br><span class="line"><span class="keyword">select</span> @@autocommit;</span><br><span class="line"></span><br><span class="line">// MySQL 关闭事务自动提交</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">session</span> autocommit=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">// 查看 MySQL 当前事务隔离级别</span><br><span class="line"><span class="keyword">SELECT</span> @@tx_isolation;</span><br><span class="line"></span><br><span class="line">// 修改 MySQL 事务隔离级别</span><br><span class="line">// 设置read uncommitted级别：</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">session</span> <span class="keyword">transaction</span> <span class="keyword">isolation</span> <span class="keyword">level</span> <span class="keyword">read</span> uncommitted;</span><br><span class="line"></span><br><span class="line">// 设置read committed级别：</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">session</span> <span class="keyword">transaction</span> <span class="keyword">isolation</span> <span class="keyword">level</span> <span class="keyword">read</span> committed;</span><br><span class="line"></span><br><span class="line">// 设置repeatable read级别：</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">session</span> <span class="keyword">transaction</span> <span class="keyword">isolation</span> <span class="keyword">level</span> repeatable <span class="keyword">read</span>;</span><br><span class="line"></span><br><span class="line">// 设置serializable级别：</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">session</span> <span class="keyword">transaction</span> <span class="keyword">isolation</span> <span class="keyword">level</span> <span class="keyword">serializable</span>;</span><br></pre></td></tr></table></figure><p><strong>事务的隔离性实现原理：锁</strong></p><p>MySQL 锁分类：</p><ul><li><p>共享锁（读锁）：数据只能读取，不能更新；</p></li><li><p>排他锁（写锁）：执行写入操作时，其他事务不能读取。</p></li></ul><p>锁粒度：锁定对象的大小就是锁的粒度：记录 / 表。</p><p>基于锁的并发流程控制：</p><ul><li><p>事务根据自己对数据项进行的操作类型申请相应的锁（读申请共享锁，写申请排他锁）</p></li><li><p>申请锁的请求被发送给锁管理器。锁管理器根据当前数据项是否已经有锁以及申请的和持有的锁是否冲突决定是否为该请求授予锁；</p></li><li><p>若锁被授予，则申请锁的事务可以继续执行；若被拒绝，则申请锁的事务将进行等待，知道锁被其他事务释放。</p></li></ul><h2 id="面试题-1"><a href="#面试题-1" class="headerlink" title="面试题"></a>面试题</h2><blockquote><p>MySQL 中 InnoDB 存储引擎和 MyISAM 存储引擎的区别？</p></blockquote><p><a href="https://www.zhihu.com/question/20596402?sort=created" target="_blank" rel="noopener">Mysql 中 MyISAM 和 InnoDB 的区别有哪些？</a></p><table><thead><tr><th>特征</th><th>MyISAM</th><th>InnoDB</th></tr></thead><tbody><tr><td>索引类型</td><td>非聚簇索引</td><td>聚簇索引</td></tr><tr><td>支持事务</td><td>否</td><td>是</td></tr><tr><td>支持表锁</td><td>是</td><td>是</td></tr><tr><td>支持行锁</td><td>否</td><td>是</td></tr><tr><td>支持外键</td><td>否</td><td>是</td></tr><tr><td>支持全文索引</td><td>是</td><td>是（5.6版本后支持）</td></tr><tr><td>适合操作类型</td><td>大量select</td><td>大量 inset/delete/update</td></tr><tr><td>文件组织形式</td><td>.frm / .ibd</td><td>.MYD / .MYI / .frm</td></tr></tbody></table><p><strong>其他区别内容：</strong></p><ul><li><p>MyISAM：.frm文件存储表定义；数据文件的扩展名为.MYD(MYData)；索引文件的扩展名是.MYI (MYIndex)。</p></li><li><p>InnoDB：.frm文件存储表定义；.ibd 文件和 .ibdata 文件：这两种文件都是存放InnoDB 数据的文件，之所以用两种文件来存放 文件：这两种文件都是存放InnoDB 的数据，是因为 文件：这两种文件都是存放InnoDB 的数据存储方式能够通过配置来决定是使用共享表空间存放存储数据，还是用独享表空间存放存储数据。独享表空间存储方式使用 .ibd 文件，并且每个表一个 .ibd 文件；共享表空间存储方式使用 .ibdata 文件，所有表共同使用一个 .ibdata 文件。</p></li><li><p>MyISAM：允许没有任何索引和主键的表存在，索引都是保存行的地址。</p></li><li><p>InnoDB：如果没有设定主键或者非空唯一索引，就会自动生成一个6字节的主键(用户不可见)，数据是主索引的一部分，附加索引保存的是主索引的值。</p></li><li><p>MyISAM： 保存有表的总行数，如果 select count() from table; 会直接取出出该值。</p></li><li><p>InnoDB： 没有保存表的总行数，如果使用 select count(*) from table; 就会遍历整个表，消耗相当大，但是在加了 wehre 条件后，MyISAM 和 InnoDB 处理的方式都一样。</p></li></ul><div class="row">    <embed src="https://gitee.com/dongzl/article-images/raw/master/pdf/这几道mysql题你搞懂了，金三银四涨薪稳了.pdf" width="100%" height="550" type="application/pdf"></div><ul><li><p>参考资料</p></li><li><p><a href="https://www.cnblogs.com/f-ck-need-u/archive/2018/05/08/9010872.html" target="_blank" rel="noopener">详细分析MySQL事务日志(redo log和undo log)</a></p></li><li><p><a href="https://www.zhihu.com/question/20596402?sort=created" target="_blank" rel="noopener">Mysql 中 MyISAM 和 InnoDB 的区别有哪些？</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;面试题&quot;&gt;&lt;a href=&quot;#面试题&quot; class=&quot;headerlink&quot; title=&quot;面试题&quot;&gt;&lt;/a&gt;面试题&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;MySQL 数据库的原子性和持久性怎么保证？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
      
    
    </summary>
    
    
      <category term="数据库" scheme="https://dongzl.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="ACID" scheme="https://dongzl.github.io/tags/ACID/"/>
    
      <category term="MySQL" scheme="https://dongzl.github.io/tags/MySQL/"/>
    
      <category term="Redo log" scheme="https://dongzl.github.io/tags/Redo-log/"/>
    
      <category term="Undo log" scheme="https://dongzl.github.io/tags/Undo-log/"/>
    
  </entry>
  
  <entry>
    <title>论“茴”字的四种写法：一道面试题总结线程间通信的几种方式</title>
    <link href="https://dongzl.github.io/2020/03/07/07-Several-Methods-Of-Communication-Between-Thread/"/>
    <id>https://dongzl.github.io/2020/03/07/07-Several-Methods-Of-Communication-Between-Thread/</id>
    <published>2020-03-07T13:35:58.000Z</published>
    <updated>2020-03-09T13:32:28.199Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景描述"><a href="#背景描述" class="headerlink" title="背景描述"></a>背景描述</h2><blockquote><p>用两个线程，一个输出字母，一个输出数字，交替输出：1A2B3C4D5E…26Z。</p></blockquote><img src="https://gitee.com/dongzl/article-images/raw/master/2020/07-Several-Methods-Of-Communication-Between-Thread/Several-Methods-Of-Communication-Between-Thread.png"><p>这是一道典型的线程间通信的面试题，两个线程交替<strong>运行-暂停</strong>，并且当一个线程运行后需要暂停，同时要通知另外一个线程运行；另外一个线程得到通知后开始运行，运行后暂停并通知对方线程运行，彼此交替运行，直至打印完整结果。对于这个问题有很多中解法，下面我们就一一分析这些方法。</p><a id="more"></a><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="LockSupport-类实现"><a href="#LockSupport-类实现" class="headerlink" title="LockSupport 类实现"></a>LockSupport 类实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.LockSupport;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockSupportDemo</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Thread t1, t2;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] digit = <span class="keyword">new</span> String[]&#123;<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"5"</span>, <span class="string">"6"</span>, <span class="string">"7"</span>, <span class="string">"8"</span>, <span class="string">"9"</span>, <span class="string">"10"</span>&#125;;</span><br><span class="line">        String[] alphabet = <span class="keyword">new</span> String[]&#123;<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>, <span class="string">"E"</span>, <span class="string">"F"</span>, <span class="string">"G"</span>, <span class="string">"H"</span>, <span class="string">"I"</span>, <span class="string">"J"</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (String d : digit) &#123;</span><br><span class="line">                    System.out.println(d);</span><br><span class="line">                    LockSupport.unpark(t2);</span><br><span class="line">                    LockSupport.park(t1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t1"</span>);</span><br><span class="line">        </span><br><span class="line">        t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (String a : alphabet) &#123;</span><br><span class="line">                    LockSupport.park(t2);</span><br><span class="line">                    System.out.println(a);</span><br><span class="line">                    LockSupport.unpark(t1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t2"</span>);</span><br><span class="line">        </span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>LockSupport</code> 中的 <code>park</code> 和 <code>unpark</code> 可以实现线程的阻塞与唤醒。</p><ul><li><p><code>park</code>: Disables the current thread for thread scheduling purposes unless the permit is available.</p></li><li><p><code>unpark</code>: Makes available the permit for the given thread, if it was not already available.</p></li></ul><h3 id="while-循环-volatile-变量实现"><a href="#while-循环-volatile-变量实现" class="headerlink" title="while 循环 + volatile 变量实现"></a>while 循环 + volatile 变量实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WhileCycleDemo</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">enum</span> RunThreadEnum &#123;T1, T2&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> RunThreadEnum run = RunThreadEnum.T1;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] digit = <span class="keyword">new</span> String[]&#123;<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"5"</span>, <span class="string">"6"</span>, <span class="string">"7"</span>, <span class="string">"8"</span>, <span class="string">"9"</span>, <span class="string">"10"</span>&#125;;</span><br><span class="line">        String[] alphabet = <span class="keyword">new</span> String[]&#123;<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>, <span class="string">"E"</span>, <span class="string">"F"</span>, <span class="string">"G"</span>, <span class="string">"H"</span>, <span class="string">"I"</span>, <span class="string">"J"</span>&#125;;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (String d : digit) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (run != RunThreadEnum.T1) &#123;&#125;</span><br><span class="line">                    System.out.println(d);</span><br><span class="line">                    run = RunThreadEnum.T2;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t1"</span>).start();</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (String a : alphabet) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (run != RunThreadEnum.T2) &#123;&#125;</span><br><span class="line">                    System.out.println(a);</span><br><span class="line">                    run = RunThreadEnum.T1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 <code>while 循环 + volatile 变量</code> 这种实现方案，程序并不难理解，通过交替设置某个变量值的方式实现效果，不过这种方式实现需要注意一点就是 <code>run</code> 变量一定要使用 <code>volatile</code> 关键字修饰，保证变量的内存可见性。</p><h3 id="AtomicBoolean-类实现"><a href="#AtomicBoolean-类实现" class="headerlink" title="AtomicBoolean 类实现"></a>AtomicBoolean 类实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicBoolean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicBooleanDemo</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> AtomicBoolean run = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] digit = <span class="keyword">new</span> String[]&#123;<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"5"</span>, <span class="string">"6"</span>, <span class="string">"7"</span>, <span class="string">"8"</span>, <span class="string">"9"</span>, <span class="string">"10"</span>&#125;;</span><br><span class="line">        String[] alphabet = <span class="keyword">new</span> String[]&#123;<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>, <span class="string">"E"</span>, <span class="string">"F"</span>, <span class="string">"G"</span>, <span class="string">"H"</span>, <span class="string">"I"</span>, <span class="string">"J"</span>&#125;;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (String d : digit) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (run.get()) &#123;&#125;</span><br><span class="line">                    System.out.println(d);</span><br><span class="line">                    run.set(<span class="keyword">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t1"</span>).start();</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (String a : alphabet) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (!run.get()) &#123;&#125;</span><br><span class="line">                    System.out.println(a);</span><br><span class="line">                    run.set(<span class="keyword">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>AtomicBoolean</code> 类实现也比较好理解，主要是借助内部API实现来保证变量在线程之间的可见性。</p><h3 id="BlockingQueue-阻塞队列实现"><a href="#BlockingQueue-阻塞队列实现" class="headerlink" title="BlockingQueue 阻塞队列实现"></a>BlockingQueue 阻塞队列实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockingQueueDemo</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> BlockingQueue&lt;String&gt; queue1 = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">static</span> BlockingQueue&lt;String&gt; queue2 = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] digit = <span class="keyword">new</span> String[]&#123;<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"5"</span>, <span class="string">"6"</span>, <span class="string">"7"</span>, <span class="string">"8"</span>, <span class="string">"9"</span>, <span class="string">"10"</span>&#125;;</span><br><span class="line">        String[] alphabet = <span class="keyword">new</span> String[]&#123;<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>, <span class="string">"E"</span>, <span class="string">"F"</span>, <span class="string">"G"</span>, <span class="string">"H"</span>, <span class="string">"I"</span>, <span class="string">"J"</span>&#125;;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (String d : digit) &#123;</span><br><span class="line">                    System.out.println(d);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        queue1.put(<span class="string">"ok"</span>);</span><br><span class="line">                        queue2.take();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t1"</span>).start();</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (String a : alphabet) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        queue1.take();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(a);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        queue2.put(<span class="string">"ok"</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>借助 <code>BlockingQueue</code> 类实现，主要是借助阻塞队列的阻塞特性，当队列为空时，调用阻塞队列的 <code>take</code> 方法，会阻塞当前线程的执行，直到队列不为空后唤醒当前线程继续执行。</p><h3 id="PipedInputStream-amp-PipedOutputStream-实现"><a href="#PipedInputStream-amp-PipedOutputStream-实现" class="headerlink" title="PipedInputStream &amp; PipedOutputStream 实现"></a>PipedInputStream &amp; PipedOutputStream 实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PipedInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.PipedOutputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PipedStreamDemo</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String[] digit = <span class="keyword">new</span> String[]&#123;<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"5"</span>, <span class="string">"6"</span>, <span class="string">"7"</span>, <span class="string">"8"</span>, <span class="string">"9"</span>, <span class="string">"10"</span>&#125;;</span><br><span class="line">        String[] alphabet = <span class="keyword">new</span> String[]&#123;<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>, <span class="string">"E"</span>, <span class="string">"F"</span>, <span class="string">"G"</span>, <span class="string">"H"</span>, <span class="string">"I"</span>, <span class="string">"J"</span>&#125;;</span><br><span class="line">    </span><br><span class="line">        PipedInputStream input1 = <span class="keyword">new</span> PipedInputStream();</span><br><span class="line">        PipedInputStream input2 = <span class="keyword">new</span> PipedInputStream();</span><br><span class="line">        PipedOutputStream output1 = <span class="keyword">new</span> PipedOutputStream();</span><br><span class="line">        PipedOutputStream output2 = <span class="keyword">new</span> PipedOutputStream();</span><br><span class="line">        </span><br><span class="line">        input1.connect(output2);</span><br><span class="line">        input2.connect(output1);</span><br><span class="line">        </span><br><span class="line">        String msg = <span class="string">"exchange"</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">8</span>];</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (String d : digit) &#123;</span><br><span class="line">                        System.out.println(d);</span><br><span class="line">                        output1.write(msg.getBytes());</span><br><span class="line">                        input1.read(buffer);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t1"</span>).start();</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">8</span>];</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (String a : alphabet) &#123;</span><br><span class="line">                        input2.read(buffer);</span><br><span class="line">                        System.out.println(a);</span><br><span class="line">                        output2.write(msg.getBytes());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种事借助了 <code>java.io</code> 包中的 <code>PipedInputStream &amp; PipedOutputStream</code> 来实现，这两个类在实际中真是没有使用过，而且从程序运行效果来看，上述代码执行效率非常之低，其实这种实现方案只是一个凑数，开脑洞的方案。</p><h3 id="synchronized-wait-notifyAll-实现"><a href="#synchronized-wait-notifyAll-实现" class="headerlink" title="synchronized + wait() + notifyAll() 实现"></a>synchronized + wait() + notifyAll() 实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitNotifyDemo</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        Object o = <span class="keyword">new</span> Object();</span><br><span class="line">        </span><br><span class="line">        String[] digit = <span class="keyword">new</span> String[]&#123;<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"5"</span>, <span class="string">"6"</span>, <span class="string">"7"</span>, <span class="string">"8"</span>, <span class="string">"9"</span>, <span class="string">"10"</span>&#125;;</span><br><span class="line">        String[] alphabet = <span class="keyword">new</span> String[]&#123;<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>, <span class="string">"E"</span>, <span class="string">"F"</span>, <span class="string">"G"</span>, <span class="string">"H"</span>, <span class="string">"I"</span>, <span class="string">"J"</span>&#125;;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (o) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (String d : digit) &#123;</span><br><span class="line">                        System.out.println(d);</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            o.notifyAll();</span><br><span class="line">                            o.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    o.notifyAll(); <span class="comment">//一定再调用一次，否则程序无法退出执行</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t1"</span>).start();</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (o) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (String a : alphabet) &#123;</span><br><span class="line">                        System.out.println(a);</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            o.notifyAll();</span><br><span class="line">                            o.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    o.notifyAll();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 <code>Object</code> 类中 <code>wait()</code> &amp; <code>notifyAll()</code> 方法使用，也可以达到交替打印的效果。其中 <code>wait()</code> 方法作用是使当前线程阻塞，释放资源对象 o，<code>notifyAll()</code> 方法作用是唤醒正在等待资源对象 o 的线程，使其继续向下执行。这里需要注意一点是在循环打印输出之后，一定要再次调用<code>notifyAll()</code> 方法，因为两个线程交替<strong>执行-等待</strong>，最后一定会有一个线程处于等待状态，如果不最后再调用一次<code>notifyAll()</code> 方法，那么一定会有一个线程无法退出执行，程序也就无法终止。</p><p>PS. 这里还有一点需要注意就是上述程序无法控制<strong>数字和字母输出先后顺序，也行是数字先输出，也许是字母先输出</strong>，因为线程两断代码完全一致，执行先后顺序无法确定，这个问题我们可以借助 <code>CountDownLatch</code> 工具类或者通过一个标志变量来处理，程序如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitNotifyDemo</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        Object o = <span class="keyword">new</span> Object();</span><br><span class="line">    </span><br><span class="line">        CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        String[] digit = <span class="keyword">new</span> String[]&#123;<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"5"</span>, <span class="string">"6"</span>, <span class="string">"7"</span>, <span class="string">"8"</span>, <span class="string">"9"</span>, <span class="string">"10"</span>&#125;;</span><br><span class="line">        String[] alphabet = <span class="keyword">new</span> String[]&#123;<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>, <span class="string">"E"</span>, <span class="string">"F"</span>, <span class="string">"G"</span>, <span class="string">"H"</span>, <span class="string">"I"</span>, <span class="string">"J"</span>&#125;;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">//latch.await(); //借助 CountDownLatch 工具解决先后顺序问题(需要处理异常)</span></span><br><span class="line">                <span class="keyword">synchronized</span> (o) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (!flag) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            o.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">for</span> (String d : digit) &#123;</span><br><span class="line">                        System.out.println(d);</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            o.notifyAll();</span><br><span class="line">                            o.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    o.notifyAll(); <span class="comment">//一定再调用一次，否则程序无法退出执行</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t1"</span>).start();</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (o) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (String a : alphabet) &#123;</span><br><span class="line">                        System.out.println(a);</span><br><span class="line">                        <span class="comment">//latch.countDown();</span></span><br><span class="line">                        flag = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            o.notifyAll();</span><br><span class="line">                            o.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    o.notifyAll();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Lock-Condition-实现"><a href="#Lock-Condition-实现" class="headerlink" title="Lock + Condition 实现"></a>Lock + Condition 实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockConditionDemo</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        String[] digit = <span class="keyword">new</span> String[]&#123;<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"5"</span>, <span class="string">"6"</span>, <span class="string">"7"</span>, <span class="string">"8"</span>, <span class="string">"9"</span>, <span class="string">"10"</span>&#125;;</span><br><span class="line">        String[] alphabet = <span class="keyword">new</span> String[]&#123;<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>, <span class="string">"E"</span>, <span class="string">"F"</span>, <span class="string">"G"</span>, <span class="string">"H"</span>, <span class="string">"I"</span>, <span class="string">"J"</span>&#125;;</span><br><span class="line">    </span><br><span class="line">        Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        Condition condition1 = lock.newCondition();</span><br><span class="line">        Condition condition2 = lock.newCondition();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    lock.lock();</span><br><span class="line">                    <span class="keyword">for</span> (String d : digit) &#123;</span><br><span class="line">                        System.out.println(d);</span><br><span class="line">                        condition2.signalAll();</span><br><span class="line">                        condition1.await();</span><br><span class="line">                    &#125;</span><br><span class="line">                    condition2.signalAll(); <span class="comment">// 需要调用一次，否则程序无法终止</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t1"</span>).start();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    lock.lock();</span><br><span class="line">                    <span class="keyword">for</span> (String a : alphabet) &#123;</span><br><span class="line">                        System.out.println(a);</span><br><span class="line">                        condition1.signalAll();</span><br><span class="line">                        condition2.await();</span><br><span class="line">                    &#125;</span><br><span class="line">                    condition1.signalAll();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Lock + Condition</code> 实现方案与 <code>synchronized + wait() + notifyAll()</code>实现方案非常类似，包括使用的API都存在相似的对应关系：</p><ul><li>synchronized 关键字 VS Lock 类</li><li>Condition.await() VS Object.wait()</li><li>Condition.signalAll() VS Object.notifyAll()</li></ul><p>包括需要注意的问题，在使用 <code>Lock + Condition</code> 时我们也需要在循环执行最后在调用一次 <code>signalAll()</code> 方法，否则程序无法终止运行。</p><h2 id="最后总结"><a href="#最后总结" class="headerlink" title="最后总结"></a>最后总结</h2><p>对于这道面试题，主要还是考察线程之间通信问题，主要的考点应该是在<code>synchronized + wait() + notifyAll()</code> 的使用上，当然对于其他实现方案，比较好的是：</p><ul><li>Lock + Condition 实现</li><li>LockSupport 类实现</li></ul><p>对于其它的方案，有的是使用了一些编程技巧，有的是利用 JDK 中现有类的一些实现，并不是重点考察方向，像 <code>PipedInputStream &amp; PipedOutputStream</code> 的实现方案，虽然可以达到效果，其实有些充数的嫌疑，如果有面试官硬扣这种实现，就有点像鲁迅笔下的孔乙己先生在和你讨论“茴”字有几种写法的味道了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景描述&quot;&gt;&lt;a href=&quot;#背景描述&quot; class=&quot;headerlink&quot; title=&quot;背景描述&quot;&gt;&lt;/a&gt;背景描述&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;用两个线程，一个输出字母，一个输出数字，交替输出：1A2B3C4D5E…26Z。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;img src=&quot;https://gitee.com/dongzl/article-images/raw/master/2020/07-Several-Methods-Of-Communication-Between-Thread/Several-Methods-Of-Communication-Between-Thread.png&quot;&gt;

&lt;p&gt;这是一道典型的线程间通信的面试题，两个线程交替&lt;strong&gt;运行-暂停&lt;/strong&gt;，并且当一个线程运行后需要暂停，同时要通知另外一个线程运行；另外一个线程得到通知后开始运行，运行后暂停并通知对方线程运行，彼此交替运行，直至打印完整结果。对于这个问题有很多中解法，下面我们就一一分析这些方法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java开发" scheme="https://dongzl.github.io/categories/java%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Thread" scheme="https://dongzl.github.io/tags/Thread/"/>
    
      <category term="Lock" scheme="https://dongzl.github.io/tags/Lock/"/>
    
      <category term="synchronized" scheme="https://dongzl.github.io/tags/synchronized/"/>
    
  </entry>
  
  <entry>
    <title>极客时间 《数据结构与算法之美》 学习笔记</title>
    <link href="https://dongzl.github.io/2020/03/05/06-The-Beauty-Of-Data-Structures-And-Algorithms/"/>
    <id>https://dongzl.github.io/2020/03/05/06-The-Beauty-Of-Data-Structures-And-Algorithms/</id>
    <published>2020-03-05T01:36:44.000Z</published>
    <updated>2020-03-09T14:18:41.064Z</updated>
    
    <content type="html"><![CDATA[<p>本文是 <a href="https://time.geekbang.org/" target="_blank" rel="noopener">极客时间</a> 上 <a href="https://time.geekbang.org/column/intro/126" target="_blank" rel="noopener">数据结构与算法之美</a> 课程的学习笔记内容。</p><a id="more"></a><h2 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h2><h3 id="10-递归：如何用三行代码找到“最终推荐人”？"><a href="#10-递归：如何用三行代码找到“最终推荐人”？" class="headerlink" title="10 | 递归：如何用三行代码找到“最终推荐人”？"></a>10 | 递归：如何用三行代码找到“最终推荐人”？</h3><p><strong>递归需要满足的三个条件</strong>：</p><ul><li>一个问题的解可以分解为几个子问题的解</li><li>这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样</li><li>存在递归终止条件</li></ul><p><font color="red">写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码</font></p><p><strong>编写递归代码的关键是，只要遇到递归，我们就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤。</strong></p><p><strong>使用递归可能需要规避的问题</strong>：</p><ul><li>递归代码要警惕堆栈溢出</li><li>递归代码要警惕重复计算</li></ul><p><a href="https://mp.weixin.qq.com/s/Ki3WN2AJ5HhxxmaQ0lVh3Q" target="_blank" rel="noopener">还有程序员天真地以为”尾递归“真的可以避免堆栈溢出！</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是 &lt;a href=&quot;https://time.geekbang.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;极客时间&lt;/a&gt; 上 &lt;a href=&quot;https://time.geekbang.org/column/intro/126&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;数据结构与算法之美&lt;/a&gt; 课程的学习笔记内容。&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://dongzl.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="https://dongzl.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="https://dongzl.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>聊聊代理模式（Proxy）的使用</title>
    <link href="https://dongzl.github.io/2020/02/29/05-Design-Pattern-Proxy/"/>
    <id>https://dongzl.github.io/2020/02/29/05-Design-Pattern-Proxy/</id>
    <published>2020-02-29T06:44:21.000Z</published>
    <updated>2020-03-09T13:35:42.159Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>最近在学习 <a href="https://time.geekbang.org/" target="_blank" rel="noopener">极客时间</a> 的 <a href="https://time.geekbang.org/column/intro/250" target="_blank" rel="noopener">设计模式之美</a> 课程，这一篇算是自己的学习总结。代理模式（Proxy）在很多非常优秀框架中都有他的身影，比如，大名鼎鼎的 Spring AOP 就是使用动态代理（Dynamic Proxy）模式；还有就是在一些微服务框架中，如果调用一个远程服务接口，RPC 框架一般都会使用代理模式。</p><a id="more"></a><h2 id="代理模式介绍"><a href="#代理模式介绍" class="headerlink" title="代理模式介绍"></a>代理模式介绍</h2><p><strong>代理模式定义</strong></p><p><strong>Proxy Pattern</strong>: Provide a surrogate or placeholder for another object to control access to it.（为其他对象提供一种代理以控制对这个对象的访问。）</p><img src="https://gitee.com/dongzl/article-images/raw/master/2020/05-Design-Pattern-Proxy/Design-Pattern-Proxy_01.png" width="600px"><ul><li>Subject：定义 RealSubject 对外的接口，且这些接口必须被 Proxy 实现，这样外部调用 proxy 的接口最终都被转化为对 RealSubject 的调用。</li><li>RealSubject：真正的目标对象（被代理对象）。</li><li>Proxy：目标对象的代理，负责控制和管理目标对象，并间接地传递外部对目标对象的访问。</li></ul><h2 id="静态代理实现"><a href="#静态代理实现" class="headerlink" title="静态代理实现"></a>静态代理实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticProxy</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> ProxyExecute(<span class="keyword">new</span> RemoteExecute()).execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Executable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RemoteExecute</span> <span class="keyword">implements</span> <span class="title">Executable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">        System.out.println(<span class="string">"Remote execute ......"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProxyExecute</span> <span class="keyword">implements</span> <span class="title">Executable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Executable executable;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxyExecute</span><span class="params">(Executable executable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.executable = executable;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        executable.execute();</span><br><span class="line">        System.out.println(<span class="string">"Time: "</span> + (System.currentTimeMillis() - start));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码就是静态代理个一个简单实现，由于在静态代理模式中 Proxy 只能代理固定实现某个接口的被代理对象，所以并不十分灵活，所以在这个静态代理的基础上就衍生出了动态代理（Dynamic Proxy）。</p><h2 id="JDK-动态代理实现"><a href="#JDK-动态代理实现" class="headerlink" title="JDK 动态代理实现"></a>JDK 动态代理实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDKDynamicProxy</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Executable remote = <span class="keyword">new</span> RemoteExecute();</span><br><span class="line">        </span><br><span class="line">        System.getProperties().setProperty(<span class="string">"sun.misc.ProxyGenerator.saveGeneratedFiles"</span>, <span class="string">"true"</span>);</span><br><span class="line">        </span><br><span class="line">        Executable executable = (Executable)Proxy.newProxyInstance(JDKDynamicProxy.class.getClassLoader(), <span class="keyword">new</span> Class[]&#123;Executable.class&#125;, <span class="keyword">new</span> ExecuteInvocationHandler(remote));</span><br><span class="line">        executable.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExecuteInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Executable executable;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExecuteInvocationHandler</span><span class="params">(Executable executable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.executable = executable;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        Object result = method.invoke(executable, args);</span><br><span class="line">        System.out.println(<span class="string">"Time: "</span> + (System.currentTimeMillis() - start));</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Executable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RemoteExecute</span> <span class="keyword">implements</span> <span class="title">Executable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">        System.out.println(<span class="string">"Remote execute ......"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JDK 的动态代理是通过 Proxy 类来实现的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</span> </span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> IllegalArgumentException</span></span><br></pre></td></tr></table></figure><p>newProxyInstance 方法需要三个参数，</p><ul><li>loader 是生成代理类的类加载器；</li><li>interfaces 指定被代理类实现的接口（所以很多资料都说 JDK 的动态代理需要被代理类必须实现某一个接口，其实证据就在这里）；</li><li>h 调用处理器（实现 InvocationHandler 接口，InvocationHandler 接口中定义了 invoke 方法）。</li></ul><p>通过设置 JDK 属性，我们可以将动态代理过程中生成的代理类保存下来，观察 JDK 动态生成的代理类的一些实现细节：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.getProperties().setProperty(<span class="string">"sun.misc.ProxyGenerator.saveGeneratedFiles"</span>, <span class="string">"true"</span>);</span><br></pre></td></tr></table></figure><p>PS. <strong>这个属性值在不同 JDK 版本名称不同，JDK8 中为 <code>sun.misc.ProxyGenerator.saveGeneratedFiles</code>，JDK12 中是 <code>jdk.proxy.ProxyGenerator.saveGeneratedFiles</code>，没有深究是从 JDK 哪个版本改的这个属性名。</strong></p><p>通过设置这个参数，在程序运行后会生成一个 <code>$Proxy0.class</code> 文件，我们通过工具反编译文件后内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Source code recreated from a .class file by IntelliJ IDEA</span></span><br><span class="line"><span class="comment">// (powered by Fernflower decompiler)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> design.pattern.proxy.v2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.UndeclaredThrowableException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> $<span class="title">Proxy0</span> <span class="keyword">extends</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Executable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> $Proxy0(InvocationHandler var1) <span class="keyword">throws</span>  &#123;</span><br><span class="line">        <span class="keyword">super</span>(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略 equals 方法</span></span><br><span class="line">    <span class="comment">// 省略 toString 方法</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m3, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略 hashCode 方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            m1 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"equals"</span>, Class.forName(<span class="string">"java.lang.Object"</span>));</span><br><span class="line">            m2 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"toString"</span>);</span><br><span class="line">            m3 = Class.forName(<span class="string">"design.pattern.proxy.v2.Executable"</span>).getMethod(<span class="string">"execute"</span>);</span><br><span class="line">            m0 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"hashCode"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodError(var2.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoClassDefFoundError(var3.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过类的结构我们可以知道动态生成代理类 <code>$Proxy0</code> 继承自 <code>Proxy</code> 类，同时实现了我们自定义的 <code>Executable</code> 接口，并重写了其中的 <code>execute</code> 方法，<code>execute</code> 方法实现很简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m3, (Object[])<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p>调用父类中 <code>h</code> 变量的 <code>invoke</code> 方法，其中 <code>h</code> 变量就是我们实现的 <code>InvocationHandler</code> 接口的 <code>ExecuteInvocationHandler</code> 类变量。</p><p>JDK 动态代理实现流程图：</p><img src="https://gitee.com/dongzl/article-images/raw/master/2020/05-Design-Pattern-Proxy/Design-Pattern-Proxy_02.png"><h2 id="cglib-动态代理"><a href="#cglib-动态代理" class="headerlink" title="cglib 动态代理"></a>cglib 动态代理</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CGlibDynamicProxy</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setSuperclass(RemoteExecute.class);</span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> ExecuteMethodInterceptor());</span><br><span class="line">        RemoteExecute execute = (RemoteExecute)enhancer.create();</span><br><span class="line">        execute.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExecuteMethodInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(o.getClass().getSuperclass().getName());</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        Object result = methodProxy.invokeSuper(o, objects);</span><br><span class="line">        System.out.println(<span class="string">"Time: "</span> + (System.currentTimeMillis() - start));</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RemoteExecute</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">        System.out.println(<span class="string">"Remote execute ......"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>cglib 实现的动态代理功能使用的是 <code>Enhancer</code> 类，其中需要定义 <code>MethodInterceptor</code> 接口实现类，<code>MethodInterceptor</code> 接口与 JDK 动态代理中的 InvocationHandler 接口作用非常类型，内部通过反射调用被代理类的方法。</p><p><code>cglib</code> 动态代理一个比较的的优势是被代理类（RemoteExecute）不需要实现任何接口，这个就是很多资料上说的 <code>cglib</code> 动态代理与 <code>JDK</code> 动态代理的一个很大区别就是：<strong>cglib 动态代理不需要被代理类实现任何接口，而 JDK 动态代理需要被代理类必须要实现一个接口。</strong> 由于 <code>cglib</code> 动态代理的这个优势，所以 <code>Spring AOP</code> 的动态代理就是通过 <code>cglib</code> 来实现的。</p><h2 id="代理模式使用总结"><a href="#代理模式使用总结" class="headerlink" title="代理模式使用总结"></a>代理模式使用总结</h2><p>代理模式的目的：</p><ul><li>为外部调用者提供一个访问服务提供者的代理对象。</li></ul><p>代理模式的动机：</p><ul><li>限制对目标对象的直接访问，降低耦合度。</li></ul><p>代理模式优点：</p><ul><li>低耦合（协调调用者和被调用者）</li><li>易扩展</li><li>灵活度高</li></ul><p>代理模式缺点：</p><ul><li>间接访问可能会延迟请求相应</li><li>增加工作量</li></ul><p>代理模式分类：</p><ul><li>静态代理</li><li>动态代理</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><p><a href="https://www.cnblogs.com/yssjun/archive/2019/05/31/10889022.html" target="_blank" rel="noopener">设计模式之代理模式（proxy pattern）</a></p></li><li><p><a href="https://www.cnblogs.com/liuyun1995/p/8144628.html" target="_blank" rel="noopener">JDK动态代理</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景介绍&quot;&gt;&lt;a href=&quot;#背景介绍&quot; class=&quot;headerlink&quot; title=&quot;背景介绍&quot;&gt;&lt;/a&gt;背景介绍&lt;/h2&gt;&lt;p&gt;最近在学习 &lt;a href=&quot;https://time.geekbang.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;极客时间&lt;/a&gt; 的 &lt;a href=&quot;https://time.geekbang.org/column/intro/250&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;设计模式之美&lt;/a&gt; 课程，这一篇算是自己的学习总结。代理模式（Proxy）在很多非常优秀框架中都有他的身影，比如，大名鼎鼎的 Spring AOP 就是使用动态代理（Dynamic Proxy）模式；还有就是在一些微服务框架中，如果调用一个远程服务接口，RPC 框架一般都会使用代理模式。&lt;/p&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="https://dongzl.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://dongzl.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="代理模式" scheme="https://dongzl.github.io/tags/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Proxy" scheme="https://dongzl.github.io/tags/Proxy/"/>
    
  </entry>
  
  <entry>
    <title>极客时间 《深入浅出计算机组成原理》 学习笔记</title>
    <link href="https://dongzl.github.io/2020/02/21/04-On-The-Principle-Of-Computer-Composition/"/>
    <id>https://dongzl.github.io/2020/02/21/04-On-The-Principle-Of-Computer-Composition/</id>
    <published>2020-02-21T12:54:33.000Z</published>
    <updated>2020-03-10T02:25:46.323Z</updated>
    
    <content type="html"><![CDATA[<p>本文是 <a href="https://time.geekbang.org/" target="_blank" rel="noopener">极客时间</a> 上 <a href="https://time.geekbang.org/column/intro/170" target="_blank" rel="noopener">深入浅出计算机组成原理</a> 课程的学习笔记内容。</p><a id="more"></a><h2 id="入门篇"><a href="#入门篇" class="headerlink" title="入门篇"></a>入门篇</h2><h3 id><a href="#" class="headerlink" title></a></h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是 &lt;a href=&quot;https://time.geekbang.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;极客时间&lt;/a&gt; 上 &lt;a href=&quot;https://time.geekbang.org/column/intro/170&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;深入浅出计算机组成原理&lt;/a&gt; 课程的学习笔记内容。&lt;/p&gt;
    
    </summary>
    
    
      <category term="其他" scheme="https://dongzl.github.io/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="计算机组成原理" scheme="https://dongzl.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>计算机中常用数学公式汇总</title>
    <link href="https://dongzl.github.io/2020/02/17/03-The-Mathematical-Formula-Summary/"/>
    <id>https://dongzl.github.io/2020/02/17/03-The-Mathematical-Formula-Summary/</id>
    <published>2020-02-17T14:04:54.000Z</published>
    <updated>2020-03-09T14:20:17.388Z</updated>
    
    <content type="html"><![CDATA[<ul><li>斐波那契数列通向公式：</li></ul><p>$$a_n=\frac{1}{\sqrt{5}} \begin{bmatrix} \begin{pmatrix} \frac{1 + \sqrt{5}}{2} \end{pmatrix}^n - \begin{pmatrix} \frac{1 - \sqrt{5}}{2} \end{pmatrix}^n\end{bmatrix}$$</p><ul><li>斐波那契数列矩阵方程：</li></ul><p>$$\begin{bmatrix} f(n)\\ f(n - 1) \end{bmatrix} = \begin{bmatrix} 1&amp;1\\ 1&amp;0 \end{bmatrix} \begin{bmatrix} f(n - 1)\\ f(n - 2) \end{bmatrix} = \begin{bmatrix} 1&amp;1\\ 1&amp;0 \end{bmatrix}^{n + 1} \begin{bmatrix} f(1)\\ f(0) \end{bmatrix}$$</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;斐波那契数列通向公式：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$$a_n=\frac{1}{\sqrt{5}} \begin{bmatrix} \begin{pmatrix} \frac{1 + \sqrt{5}}{2} \end{pmatrix}^n - \begin{
      
    
    </summary>
    
    
      <category term="其他" scheme="https://dongzl.github.io/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="数学公式" scheme="https://dongzl.github.io/tags/%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>各种算法的复杂度</title>
    <link href="https://dongzl.github.io/2020/02/13/02-Know-Thy-Complexities/"/>
    <id>https://dongzl.github.io/2020/02/13/02-Know-Thy-Complexities/</id>
    <published>2020-02-13T02:17:58.000Z</published>
    <updated>2020-03-09T14:18:35.599Z</updated>
    
    <content type="html"><![CDATA[<p>你好，这个页面涵盖了计算机科学中常用算法的时间和空间复杂度。在准备过去的技术采访中，我自己花了几个小时爬取网页，把搜索、排序算法中最好情况、最坏情况以及平均情况时间复杂度的内容汇总到一起，这样我就不会在被问及这些问题时被难住了。在过去的几年里，我采访了硅谷的几家初创公司，以及一些大公司，例如谷歌、Facebook、雅虎、LinkedIn和Uber，每次我准备采访时，我都会想“为什么没有人创建一个好的大O备忘单呢？”。所以，为了给你们这些好人节省很多时间，我创造了一个。享受吧！</p><a id="more"></a><blockquote><p>Hi there!  This webpage covers the space and time Big-O complexities of common algorithms used in Computer Science.  When preparing for technical interviews in the past, I found myself spending hours crawling the internet putting together the best, average, and worst case complexities for search and sorting algorithms so that I wouldn’t be stumped when asked about them.  Over the last few years, I’ve interviewed at several Silicon Valley startups, and also some bigger companies, like Google, Facebook, Yahoo, LinkedIn, and Uber, and each time that I prepared for an interview, I thought to myself “Why hasn’t someone created a nice Big-O cheat sheet?”.  So, to save all of you fine folks a ton of time, I went ahead and created one.  Enjoy!</p></blockquote><h2 id="大O复杂度统计图"><a href="#大O复杂度统计图" class="headerlink" title="大O复杂度统计图"></a>大O复杂度统计图</h2><p>Big-O Complexity Chart</p><img src="https://gitee.com/dongzl/article-images/raw/master/2020/02-Know-Thy-Complexities/Big-O-Complexity-Chart.png" width="1000px"><h2 id="常用数据结构操作"><a href="#常用数据结构操作" class="headerlink" title="常用数据结构操作"></a>常用数据结构操作</h2><p>Common Data Structure Operations</p><img src="https://gitee.com/dongzl/article-images/raw/master/2020/02-Know-Thy-Complexities/Common-Data-Structure-Operations.png" width="1000px"><h2 id="线性排序算法"><a href="#线性排序算法" class="headerlink" title="线性排序算法"></a>线性排序算法</h2><p>Array Sorting Algorithms</p><img src="https://gitee.com/dongzl/article-images/raw/master/2020/02-Know-Thy-Complexities/Array-Sorting-Algorithms.png" width="1000px"><h2 id="官方网站-Big-O-统计数据图"><a href="#官方网站-Big-O-统计数据图" class="headerlink" title="官方网站 Big-O 统计数据图"></a>官方网站 Big-O 统计数据图</h2><p>Get the Official Big-O Cheat Sheet Poster</p><img src="https://gitee.com/dongzl/article-images/raw/master/2020/02-Know-Thy-Complexities/Big-O-Cheat-Sheet-Poster.png" width="1000px"><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.bigocheatsheet.com/" target="_blank" rel="noopener">Know Thy Complexities!</a></li><li><a href="https://blog.csdn.net/herorenme/article/details/8919095" target="_blank" rel="noopener">Know Thy Complexities! (各种算法的复杂度)</a></li><li><a href="https://www.cnblogs.com/datascientist/p/3557401.html" target="_blank" rel="noopener">Know Thy Complexities!</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;你好，这个页面涵盖了计算机科学中常用算法的时间和空间复杂度。在准备过去的技术采访中，我自己花了几个小时爬取网页，把搜索、排序算法中最好情况、最坏情况以及平均情况时间复杂度的内容汇总到一起，这样我就不会在被问及这些问题时被难住了。在过去的几年里，我采访了硅谷的几家初创公司，以及一些大公司，例如谷歌、Facebook、雅虎、LinkedIn和Uber，每次我准备采访时，我都会想“为什么没有人创建一个好的大O备忘单呢？”。所以，为了给你们这些好人节省很多时间，我创造了一个。享受吧！&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://dongzl.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Big-O" scheme="https://dongzl.github.io/tags/Big-O/"/>
    
  </entry>
  
  <entry>
    <title>Google Guava EventBus 在 ShardingShere 中的应用</title>
    <link href="https://dongzl.github.io/2020/02/01/01-Google-Guava-EventBus-ShardingSphere/"/>
    <id>https://dongzl.github.io/2020/02/01/01-Google-Guava-EventBus-ShardingSphere/</id>
    <published>2020-02-01T10:02:52.000Z</published>
    <updated>2020-03-09T13:37:28.929Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Guava-EventBus-介绍"><a href="#Guava-EventBus-介绍" class="headerlink" title="Guava EventBus 介绍"></a>Guava EventBus 介绍</h2><p>Guava 的 EventBus 可以简化生产/消费模型。EventBus 通过非常简单的方式，实现了观察者模式中的监听注册，事件分发。</p><blockquote><p>Dispatches events to listeners, and provides ways for listeners to register themselves. The EventBus allows publish-subscribe-style communication between components without requiring the components to explicitly register with one another (and thus be aware of each other). It is designed exclusively to replace traditional Java in-processs event distribution using explicit registration. It is not a general-purpose publish-subscribe system, nor is it intended for interprocess communication.</p></blockquote><blockquote><p>将事件分发给监听器，同时提供监听器注册监听的方式。EventBus 支持组件之间的发布-订阅式通信，而不需要组件显式地彼此注册（从而彼此感知对方存在）。它是专门为使用显式注册来替代传统的 Java 进程内事件分发而设计的。它不是一个通用的发布订阅系统，也不支持进程间通信。</p></blockquote><a id="more"></a><img src="https://gitee.com/dongzl/article-images/raw/master/2020/01-Google-Guava-EventBus-ShardingSphere/Google-Guava-EventBus.png" width="600px"><p>通过阅读 Guava 的 EventBus 源码，EventBus 支持的操作如下：</p><ul><li>Receiving Events（接收事件）</li><li>Posting Events （发布事件）</li><li>Subscriber Methods （订阅事件）</li><li>Dead Events （没有订阅者的事件）</li></ul><h2 id="EventBus-发布-订阅使用"><a href="#EventBus-发布-订阅使用" class="headerlink" title="EventBus 发布/订阅使用"></a>EventBus 发布/订阅使用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 订阅者</span></span><br><span class="line"><span class="keyword">import</span> com.google.common.eventbus.Subscribe;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EventHandler</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Subscribe</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mq</span><span class="params">(MQEvent mq)</span> </span>&#123;</span><br><span class="line">        System.out.println(mq.getClass().getCanonicalName() + <span class="string">" work"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 订阅事件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MQEvent</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试类</span></span><br><span class="line"><span class="keyword">import</span> com.google.common.eventbus.EventBus;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EventTest</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//初始化消息总线</span></span><br><span class="line">        EventBus eventBus = <span class="keyword">new</span> EventBus();</span><br><span class="line">        <span class="comment">// 注册订阅者</span></span><br><span class="line">        eventBus.register(<span class="keyword">new</span> EventHandler());</span><br><span class="line">        <span class="comment">//MqEvent推送给订阅者</span></span><br><span class="line">        MQEvent mqEvent = <span class="keyword">new</span> MQEvent();</span><br><span class="line">        <span class="comment">//发布消息</span></span><br><span class="line">        eventBus.post(mqEvent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="EventBus-在-ShardingSphere-中的实际应用"><a href="#EventBus-在-ShardingSphere-中的实际应用" class="headerlink" title="EventBus 在 ShardingSphere 中的实际应用"></a>EventBus 在 ShardingSphere 中的实际应用</h2><p>在 <a href="https://github.com/apache/incubator-shardingsphere" target="_blank" rel="noopener">ShardingSphere</a> 项目中需要将数据库配置信息存储到统一配置中心（例如：ZooKeeper、nacos、Apollo），对于统一的配置中心可以通过监听机制，监听配置中心配置信息的变化，将配置中心变更的信息推送给 ShardingSphere，对于这种情况就是一个典型的发布-订阅模型，在 ShardingSphere 就是通过 EventBus 来完成这个功能的，我们来看一下 ShardingSphere 的代码实现：</p><ul><li><p>系统启动时，通过 ShardingOrchestrationFacade.init() 方法注册监听内容，ConfigurationChangedListenerManager.initListeners() 方法用于启动对于系统配置的监听。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigurationChangedListenerManager</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    ... ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Initialize all configuration changed listeners.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initListeners</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        schemaChangedListener.watch(ChangedType.UPDATED, ChangedType.DELETED);</span><br><span class="line">        propertiesChangedListener.watch(ChangedType.UPDATED);</span><br><span class="line">        authenticationChangedListener.watch(ChangedType.UPDATED);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>例如在 PropertiesChangedListener.watch() 方法中，通过调用父类的 PostShardingConfigCenterEventListener.watch(final ChangedType… watchedChangedTypes) 方法完成监听，在 PostShardingConfigCenterEventListener 方法中使用了 EventBus，注册监听配置中心中某个 Key 的变化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">watch</span><span class="params">(<span class="keyword">final</span> String watchKey, <span class="keyword">final</span> Collection&lt;ChangedType&gt; watchedChangedTypeList)</span> </span>&#123;</span><br><span class="line">    configCenter.watch(watchKey, <span class="keyword">new</span> DataChangedEventListener() &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onChange</span><span class="params">(<span class="keyword">final</span> DataChangedEvent dataChangedEvent)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (watchedChangedTypeList.contains(dataChangedEvent.getChangedType())) &#123;</span><br><span class="line">                eventBus.post(createShardingOrchestrationEvent(dataChangedEvent));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>对于配置中心监听配置信息的变化都是由不同的框架（ZooKeeper、nacos、Apollo）来完成的，下面以 nacos 为例，看一下监听实现，nacos 中配置信息发生变化后对通过 receiveConfigInfo 方法推送给 ShardingShpere，ShardingShpere 接收到变更后通过 EventBus 的 post 方法发送变更事件，订阅事件的类接收到变更后会进行相应逻辑处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">watch</span><span class="params">(<span class="keyword">final</span> String key, <span class="keyword">final</span> DataChangedEventListener dataChangedEventListener)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String dataId = key.replace(<span class="string">"/"</span>, <span class="string">"."</span>);</span><br><span class="line">        String group = properties.getProperty(<span class="string">"group"</span>, <span class="string">"SHARDING_SPHERE_DEFAULT_GROUP"</span>);</span><br><span class="line">        configService.addListener(dataId, group, <span class="keyword">new</span> Listener() &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Executor <span class="title">getExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveConfigInfo</span><span class="params">(<span class="keyword">final</span> String configInfo)</span> </span>&#123;</span><br><span class="line">                dataChangedEventListener.onChange(<span class="keyword">new</span> DataChangedEvent(key, configInfo, DataChangedEvent.ChangedType.UPDATED));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> NacosException ex) &#123;</span><br><span class="line">        log.debug(<span class="string">"Nacos watch key exception for: &#123;&#125;"</span>, ex.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>ShardingSphere 中事件订阅，例如，在 ShardingProxyContext 需要监听配置信息变化，在构造方法中将当前实例对象（this）注册到 EventBus，通过 @Subscribe 注解监听配置变更，监听到配置变更的数据后发送给 ShardingShere，处理内部相关逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ShardingProxyContext</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ShardingProxyContext INSTANCE = <span class="keyword">new</span> ShardingProxyContext();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> ShardingProperties shardingProperties = <span class="keyword">new</span> ShardingProperties(<span class="keyword">new</span> Properties());</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ShardingProxyContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ShardingOrchestrationEventBus.getInstance().register(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ShardingProxyContext <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Renew properties.</span></span><br><span class="line"><span class="comment">     * 监听事件的变化</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> event properties changed event</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Subscribe</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">renew</span><span class="params">(<span class="keyword">final</span> PropertiesChangedEvent event)</span> </span>&#123;</span><br><span class="line">        ConfigurationLogger.log(event.getProps());</span><br><span class="line">        shardingProperties = <span class="keyword">new</span> ShardingProperties(event.getProps());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="DeadEvent-使用场景"><a href="#DeadEvent-使用场景" class="headerlink" title="DeadEvent 使用场景"></a>DeadEvent 使用场景</h2><blockquote><p>Wraps an event that was posted, but which had no subscribers and thus could not be delivered.Registering a DeadEvent subscriber is useful for debugging or logging, as it can detect misconfigurations in a system’s event distribution.</p></blockquote><blockquote><p>包装了一个被发送的事件，但是这个事件却没有任何订阅者，因此这个事件可能不会被实际发送。注册一个 DeadEvent 事件订阅器对于调试或日志记录很有用，因为它可以检测事件分布系统中的错误配置。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义事件，没有订阅者</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MQEvent</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DeadEvent 处理器</span></span><br><span class="line"><span class="keyword">import</span> com.google.common.eventbus.DeadEvent;</span><br><span class="line"><span class="keyword">import</span> com.google.common.eventbus.Subscribe;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadEventHandler</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 没有订阅者时被触发</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Subscribe</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deadEvent</span><span class="params">(DeadEvent event)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Receive a DeadEvent"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试类</span></span><br><span class="line"><span class="keyword">import</span> com.google.common.eventbus.EventBus;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadEventTest</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化消息总线</span></span><br><span class="line">        EventBus eventBus = <span class="keyword">new</span> EventBus();</span><br><span class="line">        <span class="comment">// 注册 DeadEvent 订阅者</span></span><br><span class="line">        eventBus.register(<span class="keyword">new</span> DeadEventHandler());</span><br><span class="line">        <span class="comment">// MqEvent推送给订阅者</span></span><br><span class="line">        MQEvent mqEvent = <span class="keyword">new</span> MQEvent();</span><br><span class="line">        <span class="comment">// 发布消息，没有订阅者</span></span><br><span class="line">        eventBus.post(mqEvent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其他类使用"><a href="#其他类使用" class="headerlink" title="其他类使用"></a>其他类使用</h2><ul><li><p>AsyncEventBus：异步事件总线，当处理耗时的处理时很有用，我们要依赖Executors来实现异步事件总线。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AsyncEventBus asyncEventBus = <span class="keyword">new</span> AsyncEventBus(executorService);</span><br></pre></td></tr></table></figure></li><li><p>AllowConcurrentEvents：在设置观察者时，需要使用注解类@Subscribe来标识一个订阅者，但在注解中还要一个注解@AllowConcurrentEvents，这个注解是用来标识当前订阅者是线程安全的。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Creates a &#123;<span class="doctag">@code</span> Subscriber&#125; for &#123;<span class="doctag">@code</span> method&#125; on &#123;<span class="doctag">@code</span> listener&#125;. </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Subscriber <span class="title">create</span><span class="params">(EventBus bus, Object listener, Method method)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> isDeclaredThreadSafe(method)</span><br><span class="line">        ? <span class="keyword">new</span> Subscriber(bus, listener, method)</span><br><span class="line">        : <span class="keyword">new</span> SynchronizedSubscriber(bus, listener, method);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://greengerong.github.io/blog/2014/11/27/guava-eventbus/" target="_blank" rel="noopener">Guava - EventBus(事件总线)</a></li><li><a href="https://www.jianshu.com/p/a950d7c294e5" target="_blank" rel="noopener">Guava eventBus 关于@AllowConcurrentEvents 纪实</a></li><li><a href="https://www.iteye.com/blog/uule-2096279" target="_blank" rel="noopener">用guava实现简单的事件驱动</a></li><li><a href="https://www.jianshu.com/p/703fa6cf6e44" target="_blank" rel="noopener">Guava EventBus</a></li><li><a href="https://www.yeetrack.com/?p=1177" target="_blank" rel="noopener">走近Guava(六): 事件总线EventBus</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Guava-EventBus-介绍&quot;&gt;&lt;a href=&quot;#Guava-EventBus-介绍&quot; class=&quot;headerlink&quot; title=&quot;Guava EventBus 介绍&quot;&gt;&lt;/a&gt;Guava EventBus 介绍&lt;/h2&gt;&lt;p&gt;Guava 的 EventBus 可以简化生产/消费模型。EventBus 通过非常简单的方式，实现了观察者模式中的监听注册，事件分发。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Dispatches events to listeners, and provides ways for listeners to register themselves. The EventBus allows publish-subscribe-style communication between components without requiring the components to explicitly register with one another (and thus be aware of each other). It is designed exclusively to replace traditional Java in-processs event distribution using explicit registration. It is not a general-purpose publish-subscribe system, nor is it intended for interprocess communication.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;将事件分发给监听器，同时提供监听器注册监听的方式。EventBus 支持组件之间的发布-订阅式通信，而不需要组件显式地彼此注册（从而彼此感知对方存在）。它是专门为使用显式注册来替代传统的 Java 进程内事件分发而设计的。它不是一个通用的发布订阅系统，也不支持进程间通信。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="web开发" scheme="https://dongzl.github.io/categories/web%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Guava" scheme="https://dongzl.github.io/tags/Guava/"/>
    
      <category term="Google" scheme="https://dongzl.github.io/tags/Google/"/>
    
      <category term="EventBus" scheme="https://dongzl.github.io/tags/EventBus/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://dongzl.github.io/2019/12/26/hello-world/"/>
    <id>https://dongzl.github.io/2019/12/26/hello-world/</id>
    <published>2019-12-26T13:35:58.000Z</published>
    <updated>2020-03-09T13:29:46.081Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;Quick-Start&quot;&gt;&lt;a href=&quot;#Quick-Start&quot; class=&quot;headerlink&quot; title=&quot;Quick Start&quot;&gt;&lt;/a&gt;Quick Start&lt;/h2&gt;&lt;h3 id=&quot;Create-a-new-post&quot;&gt;&lt;a href=&quot;#Create-a-new-post&quot; class=&quot;headerlink&quot; title=&quot;Create a new post&quot;&gt;&lt;/a&gt;Create a new post&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo new &lt;span class=&quot;string&quot;&gt;&quot;My New Post&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="其他" scheme="https://dongzl.github.io/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="hexo" scheme="https://dongzl.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>极客时间 《设计模式之美》 学习笔记</title>
    <link href="https://dongzl.github.io/2019/12/26/08-The-Beauty-Of-Design-Pattern/"/>
    <id>https://dongzl.github.io/2019/12/26/08-The-Beauty-Of-Design-Pattern/</id>
    <published>2019-12-26T13:35:58.000Z</published>
    <updated>2020-03-11T13:09:38.903Z</updated>
    
    <content type="html"><![CDATA[<p>本文是 <a href="https://time.geekbang.org/" target="_blank" rel="noopener">极客时间</a> 上 <a href="https://time.geekbang.org/column/intro/100039001" target="_blank" rel="noopener">设计模式之美</a> 课程的学习笔记内容。</p><a id="more"></a><h2 id="设计原则与思想：设计原则"><a href="#设计原则与思想：设计原则" class="headerlink" title="设计原则与思想：设计原则"></a>设计原则与思想：设计原则</h2><h3 id="15-理论一：对于单一职责原则，如何判定某个类的职责是否够“单一”？"><a href="#15-理论一：对于单一职责原则，如何判定某个类的职责是否够“单一”？" class="headerlink" title="15 | 理论一：对于单一职责原则，如何判定某个类的职责是否够“单一”？"></a>15 | 理论一：对于单一职责原则，如何判定某个类的职责是否够“单一”？</h3><p>单一职责原则：Single Responsibility Principle，缩写为 SRP。</p><p>我们可以现写一个粗粒度的类，满足业务需求。随着业务的发展，如果粗粒度的类越来越大，代码越来越多，这个时候，我们就可以将这个粗粒度的类，拆分成几个更细度的类。</p><p><strong>如何理解单一职责（SRP）</strong></p><p>一个类只负责完成一个职责或者功能。不要设计大而全的类，要设计粒度小、功能单一的类。单一职责原则是为了实现代码高内聚、低耦合，提高代码的复用性、可读性、可维护性。</p><p><strong>如何判断类的职责是否足够单一</strong></p><ul><li>类中的代码行数、函数或者属性过多；</li><li>类依赖的其他类过多，或者依赖类的其他类过多；</li><li>私有方法过多；</li><li>比较难给类起一个合适的名字；</li><li>类中大量的方法都是集中操作类中的某几个属性。</li></ul><hr><h3 id="16-理论二：如何做到“对扩展开放、修改关闭”？扩展和修改各指什么？"><a href="#16-理论二：如何做到“对扩展开放、修改关闭”？扩展和修改各指什么？" class="headerlink" title="16 | 理论二：如何做到“对扩展开放、修改关闭”？扩展和修改各指什么？"></a>16 | 理论二：如何做到“对扩展开放、修改关闭”？扩展和修改各指什么？</h3><p>开闭原则：Open Closed Principle，简写为 OCP。</p><blockquote><p>Software entities (modules, classes, functions, etc.) should be open for extension , but closed for modification。</p></blockquote><p>我们把它翻译成中文就是：软件实体（模块、类、方法等）应该“对扩展开放、对修改关闭”。</p><hr><h3 id="17-理论三：里式替换（LSP）跟多态有何区别？哪些代码违背了LSP？"><a href="#17-理论三：里式替换（LSP）跟多态有何区别？哪些代码违背了LSP？" class="headerlink" title="17 | 理论三：里式替换（LSP）跟多态有何区别？哪些代码违背了LSP？"></a>17 | 理论三：里式替换（LSP）跟多态有何区别？哪些代码违背了LSP？</h3><p>里式替换原则：Liskov Substitution Principle，缩写为 LSP。</p><blockquote><p>Functions that use pointers of references to base classes must be able to use objects of derived classes without knowing it。</p></blockquote><p>子类对象（object of subtype/derived class）能够替换程序（program）中父类对象（object of base/parent class）出现的任何地方，并且保证原来程序的逻辑行为（behavior）不变及正确性不被破坏。</p><p><strong>违反里式替换原则的情况：</strong></p><ul><li>子类违背父类声明要实现的功能；</li><li>子类违背父类对输入、输出、异常的约定；</li><li>子类违背父类注释中所罗列的任何特殊说明。</li></ul><p><strong>多态 &amp; 里式替换原则</strong>：</p><p>多态是面向对象编程的一大特性，也是面向对象编程语言的一种语法。它是一种代码实现的思路。而里式替换是一种设计原则，用来指导继承关系中子类该如何设计，子类的设计要保证在替换父类的时候，不改变原有程序的逻辑及不破坏原有程序的正确性。</p><hr><h3 id="18-理论四：接口隔离原则有哪三种应用？原则中的“接口”该如何理解？"><a href="#18-理论四：接口隔离原则有哪三种应用？原则中的“接口”该如何理解？" class="headerlink" title="18 | 理论四：接口隔离原则有哪三种应用？原则中的“接口”该如何理解？"></a>18 | 理论四：接口隔离原则有哪三种应用？原则中的“接口”该如何理解？</h3><p>接口隔离原则：Interface Segregation Principle”，缩写为 ISP。</p><blockquote><p>Clients should not be forced to depend upon interfaces that they do not use。</p></blockquote><p>如果把“接口”理解为一组接口集合，可以是某个微服务的接口，也可以是某个类库的接口等。如果部分接口只被部分调用者使用，我们就需要将这部分接口隔离出来，单独给这部分调用者使用，而不强迫其他调用者也依赖这部分不会被用到的接口。</p><p>如果把“接口”理解为单个 API 接口或函数，部分调用者只需要函数中的部分功能，那我们就需要把函数拆分成粒度更细的多个函数，让调用者只依赖它需要的那个细粒度函数。</p><p>如果把“接口”理解为 OOP 中的接口，也可以理解为面向对象编程语言中的接口语法。那接口的设计要尽量单一，不要让接口的实现类和调用者，依赖不需要的接口函数。</p><hr><h3 id="19-理论五：控制反转、依赖反转、依赖注入，这三者有何区别和联系？"><a href="#19-理论五：控制反转、依赖反转、依赖注入，这三者有何区别和联系？" class="headerlink" title="19 | 理论五：控制反转、依赖反转、依赖注入，这三者有何区别和联系？"></a>19 | 理论五：控制反转、依赖反转、依赖注入，这三者有何区别和联系？</h3><p>依赖倒置原则：Dependency Inversion Principle，缩写为 DIP。</p><blockquote><p>High-level modules shouldn’t depend on low-level modules. Both modules should depend on abstractions. In addition, abstractions shouldn’t depend on details. Details depend on abstractions.</p></blockquote><p>高层模块（high-level modules）不要依赖低层模块（low-level）。高层模块和低层模块应该通过抽象（abstractions）来互相依赖。除此之外，抽象（abstractions）不要依赖具体实现细节（details），具体实现细节（details）依赖抽象（abstractions）。</p><hr><h3 id="20-理论六：我为何说KISS、YAGNI原则看似简单，却经常被用错？"><a href="#20-理论六：我为何说KISS、YAGNI原则看似简单，却经常被用错？" class="headerlink" title="20 | 理论六：我为何说KISS、YAGNI原则看似简单，却经常被用错？"></a>20 | 理论六：我为何说KISS、YAGNI原则看似简单，却经常被用错？</h3><blockquote><p>Keep It Simple and Stupid. 尽量保持简单。</p></blockquote><p><strong>如何写出满足 KISS 原则的代码？</strong></p><ul><li>不要使用同事可能不懂的技术来实现代码。</li><li>不要重复造轮子，要善于使用已经有的工具类库。</li><li>不要过度优化。不要过度使用一些奇技淫巧来优化代码，牺牲代码的可读性。</li></ul><p><strong>YAGNI 原则</strong>（不要做过度设计）</p><blockquote><p>YAGNI 原则的英文全称是：You Ain’t Gonna Need It。</p></blockquote><hr><h3 id="21-理论七：重复的代码就一定违背DRY吗？如何提高代码的复用性？"><a href="#21-理论七：重复的代码就一定违背DRY吗？如何提高代码的复用性？" class="headerlink" title="21 | 理论七：重复的代码就一定违背DRY吗？如何提高代码的复用性？"></a>21 | 理论七：重复的代码就一定违背DRY吗？如何提高代码的复用性？</h3><p><strong>DRY 原则（Don’t Repeat Yourself）</strong></p><ul><li>实现逻辑重复（不违反 DRY 原则）</li><li>功能语义逻辑（违反 DRY 原则）</li><li>代码执行重复（违反 DRY 原则）</li></ul><p><strong>提高代码可复用性的方法</strong></p><ul><li>减少代码耦合</li><li>满足单一职责原则</li><li>模块化</li><li>业务与非业务逻辑分离</li><li>通用代码下沉</li><li>继承、多态、抽象、封装</li><li>应用模板等设计模式</li></ul><hr><h3 id="22-理论八：如何用迪米特法则（LOD）实现“高内聚、松耦合”？"><a href="#22-理论八：如何用迪米特法则（LOD）实现“高内聚、松耦合”？" class="headerlink" title="22 | 理论八：如何用迪米特法则（LOD）实现“高内聚、松耦合”？"></a>22 | 理论八：如何用迪米特法则（LOD）实现“高内聚、松耦合”？</h3><p>迪米特法则：Law of Demeter，缩写是 LOD。</p><p>最小知识原则：The Least Knowledge Principle。</p><blockquote><p>Each unit should have only limited knowledge about other units: only units “closely” related to the current unit. Or: Each unit should only talk to its friends; Don’t talk to strangers.</p></blockquote><hr><h3 id="23-实战一（上）：针对业务系统的开发，如何做需求分析和设计？"><a href="#23-实战一（上）：针对业务系统的开发，如何做需求分析和设计？" class="headerlink" title="23 | 实战一（上）：针对业务系统的开发，如何做需求分析和设计？"></a>23 | 实战一（上）：针对业务系统的开发，如何做需求分析和设计？</h3><ul><li><p>技术人也要有一些产品思维。对于产品设计、需求分析，我们要学会“借鉴”，一定不要自己闷头想。一方面这样做很难想全面，另一方面从零开始设计也比较浪费时间。除此之外，我们还可以通过线框图和用户用例来细化业务流程，挖掘一些比较细节的、不容易想到的功能点。</p></li><li><p>面向对象设计聚焦在代码层面（主要是针对类），那系统设计就是聚焦在架构层面（主要是针对模块），两者有很多相似之处。很多设计原则和思想不仅仅可以应用到代码设计中，还能用到架构设计中。实际上，我们可以借鉴面向对象设计的步骤，来做系统设计。</p></li><li><p>面向对象设计的本质就是把合适的代码放到合适的类中。合理地划分代码可以实现代码的高内聚、低耦合，类与类之间的交互简单清晰，代码整体结构一目了然。类比面向对象设计，系统设计实际上就是将合适的功能放到合适的模块中。合理地划分模块也可以做到模块层面的高内聚、低耦合，架构整洁清晰。在面向对象设计中，类设计好之后，我们需要设计类之间的交互关系。类比到系统设计，系统职责划分好之后，接下来就是设计系统之间的交互了。</p></li></ul><hr><h3 id="24-实战一（下）：如何实现一个遵从设计原则的积分兑换系统？"><a href="#24-实战一（下）：如何实现一个遵从设计原则的积分兑换系统？" class="headerlink" title="24 | 实战一（下）：如何实现一个遵从设计原则的积分兑换系统？"></a>24 | 实战一（下）：如何实现一个遵从设计原则的积分兑换系统？</h3><p><strong>MVC 三层开发作用：</strong></p><ul><li>分层能起到代码复用的作用</li><li>分层能起到隔离变化的作用</li><li>分层能起到隔离关注点的作用</li><li>分层能提高代码的可测试性</li><li>分层能应对系统的复杂性</li></ul><img src="https://static001.geekbang.org/resource/image/33/61/3332071c82182e72518143d05b8eaa61.jpg"><hr><h3 id="25-实战二（上）：针对非业务的通用框架开发，如何做需求分析和设计？"><a href="#25-实战二（上）：针对非业务的通用框架开发，如何做需求分析和设计？" class="headerlink" title="25 | 实战二（上）：针对非业务的通用框架开发，如何做需求分析和设计？"></a>25 | 实战二（上）：针对非业务的通用框架开发，如何做需求分析和设计？</h3><p>对于非业务通用框架开发：</p><ul><li>首先考虑功能性需求分析；</li><li>还要考虑框架的非功能性需求：易用性、性能、扩展性、容错性、通用性。</li></ul><p>复杂框架设计技巧：</p><ul><li>画产品线框图；</li><li>聚焦简单应用场景；</li><li>设计实现最小原型；</li><li>画系统设计图。</li></ul><hr><h3 id="26-实战二（下）：如何实现一个支持各种统计规则的性能计数器？"><a href="#26-实战二（下）：如何实现一个支持各种统计规则的性能计数器？" class="headerlink" title="26 | 实战二（下）：如何实现一个支持各种统计规则的性能计数器？"></a>26 | 实战二（下）：如何实现一个支持各种统计规则的性能计数器？</h3><hr><h2 id="设计原则与思想：规范与重构"><a href="#设计原则与思想：规范与重构" class="headerlink" title="设计原则与思想：规范与重构"></a>设计原则与思想：规范与重构</h2><h3 id="27-理论一：什么情况下要重构？到底重构什么？又该如何重构？"><a href="#27-理论一：什么情况下要重构？到底重构什么？又该如何重构？" class="headerlink" title="27 | 理论一：什么情况下要重构？到底重构什么？又该如何重构？"></a>27 | 理论一：什么情况下要重构？到底重构什么？又该如何重构？</h3><p>重构是一种对软件内部结构的改变，目的是在不改变软件的可见行为的情况下，使其更易理解，修改成本更低。</p><p>大型重构指的是对顶层代码设计的重构，包括：系统、模块、代码结构、类与类之间的关系等的重构，重构的手段有：分层、模块化、解耦、抽象可复用组件等等。</p><p>小型重构指的是对代码细节的重构，主要是针对类、函数、变量等代码级别的重构，比如规范命名、规范注释、消除超大类或函数、提取重复代码等等。</p><h3 id="28-理论二：为了保证重构不出错，有哪些非常能落地的技术手段？"><a href="#28-理论二：为了保证重构不出错，有哪些非常能落地的技术手段？" class="headerlink" title="28 | 理论二：为了保证重构不出错，有哪些非常能落地的技术手段？"></a>28 | 理论二：为了保证重构不出错，有哪些非常能落地的技术手段？</h3><h3 id="29-理论三：什么是代码的可测试性？如何写出可测试性好的代码？"><a href="#29-理论三：什么是代码的可测试性？如何写出可测试性好的代码？" class="headerlink" title="29 | 理论三：什么是代码的可测试性？如何写出可测试性好的代码？"></a>29 | 理论三：什么是代码的可测试性？如何写出可测试性好的代码？</h3><p>常见的测试不友好的代码有下面这 5 种：</p><ul><li>代码中包含未决行为逻辑</li><li>滥用可变全局变量</li><li>滥用静态方法</li><li>使用复杂的继承关系</li><li>高度耦合的代码</li></ul><h3 id="30-理论四：如何通过封装、抽象、模块化、中间层等解耦代码？"><a href="#30-理论四：如何通过封装、抽象、模块化、中间层等解耦代码？" class="headerlink" title="30 | 理论四：如何通过封装、抽象、模块化、中间层等解耦代码？"></a>30 | 理论四：如何通过封装、抽象、模块化、中间层等解耦代码？</h3><p>如何给代码“解耦”：</p><ul><li>封装与抽象</li><li>中间层</li><li>模块化</li><li>其他设计思想和原值<ul><li>单一职责原则</li><li>基于接口而非实现编程</li><li>依赖注入</li><li>对用组合少用继承</li><li>迪米特法则</li></ul></li></ul><h3 id="31-理论五：让你最快速地改善代码质量的20条编程规范（上）"><a href="#31-理论五：让你最快速地改善代码质量的20条编程规范（上）" class="headerlink" title="31 | 理论五：让你最快速地改善代码质量的20条编程规范（上）"></a>31 | 理论五：让你最快速地改善代码质量的20条编程规范（上）</h3><ul><li><p>关于命名：</p><ul><li>命名的关键是能准确达意。</li><li>借助类的信息来简化属性、函数的命名，利用函数的信息来简化函数参数的命名。</li><li>命名要可读、可搜索。</li><li>接口 &amp; 抽象类命名方式。</li></ul></li><li><p>关于注释：</p><ul><li>注释的目的就是让代码更容易看懂。</li><li>注释本身有一定的维护成本，所以并非越多越好。</li></ul></li></ul><h3 id="32-理论五：让你最快速地改善代码质量的20条编程规范（中）"><a href="#32-理论五：让你最快速地改善代码质量的20条编程规范（中）" class="headerlink" title="32 | 理论五：让你最快速地改善代码质量的20条编程规范（中）"></a>32 | 理论五：让你最快速地改善代码质量的20条编程规范（中）</h3><ul><li>合适的类、函数大小</li><li>一行代码最长不能超过 IDE 显示的宽度。</li><li>善用空行分割单元块</li><li>四格缩进还是两格缩进（分割统一，不用tab）</li><li>大括号所在位置（只要团队统一、业内统一、跟开源项目看齐）</li><li>类中成员的排列顺序（先变量后函数，先静态后普通，作用域由大到小）</li></ul><h3 id="33-理论五：让你最快速地改善代码质量的20条编程规范（下）"><a href="#33-理论五：让你最快速地改善代码质量的20条编程规范（下）" class="headerlink" title="33 | 理论五：让你最快速地改善代码质量的20条编程规范（下）"></a>33 | 理论五：让你最快速地改善代码质量的20条编程规范（下）</h3><ul><li>把代码分割成更小的单元块</li><li>避免函数参数过多</li><li>勿用函数参数来控制逻辑(参数中包含 true | false)</li><li>函数设计要职责单一</li><li>移除过深的嵌套层次</li><li>学会使用解释性变量<ul><li>常量取代魔法数字。</li><li>使用解释性变量来解释复杂表达式。</li></ul></li></ul><h3 id="34-实战一（上）：通过一段ID生成器代码，学习如何发现代码质量问题"><a href="#34-实战一（上）：通过一段ID生成器代码，学习如何发现代码质量问题" class="headerlink" title="34 | 实战一（上）：通过一段ID生成器代码，学习如何发现代码质量问题"></a>34 | 实战一（上）：通过一段ID生成器代码，学习如何发现代码质量问题</h3><p>如何发现代码质量问题：<br>大的方向是否可读、可扩展、可维护、灵活、简洁、可复用、可测试<br>具体落实，通用的关注点有：</p><ul><li>1）目录设置是否合理、模块划分是否清晰、代码结构是否满足“高内聚、松耦合”？</li><li>2）是否遵循经典的设计原则和设计思想（SOLID、DRY、KISS、YAGNI、LOD 等）？</li><li>3）设计模式是否应用得当？是否有过度设计？</li><li>4）代码是否容易扩展？如果要添加新功能，是否容易实现？</li><li>5）代码是否可以复用？是否可以复用已有的项目代码或类库？是否有重复造轮子？</li><li>6）代码是否容易测试？单元测试是否全面覆盖了各种正常和异常的情况？</li><li>7）代码是否易读？是否符合编码规范（比如命名和注释是否恰当、代码风格是否一致等）？</li></ul><p>关于业务的一些通用关注点：</p><ul><li>1）代码是否实现了预期的业务需求？</li><li>2）逻辑是否正确？是否处理了各种异常情况？</li><li>3）日志打印是否得当？是否方便 debug 排查问题？</li><li>4）接口是否易用？是否支持幂等、事务等？</li><li>5）代码是否存在并发问题？是否线程安全？</li><li>6）性能是否有优化空间，比如，SQL、算法是否可以优化？</li><li>7）是否有安全漏洞？比如输入输出校验是否全面？</li></ul><h3 id="35-实战一（下）：手把手带你将ID生成器代码从“能用”重构为“好用”"><a href="#35-实战一（下）：手把手带你将ID生成器代码从“能用”重构为“好用”" class="headerlink" title="35 | 实战一（下）：手把手带你将ID生成器代码从“能用”重构为“好用”"></a>35 | 实战一（下）：手把手带你将ID生成器代码从“能用”重构为“好用”</h3><ul><li>即便是非常简单的需求，不同水平的人写出来的代码，差别可能会很大。</li><li>知其然知其所以然，了解优秀代码设计的演变过程，比学习优秀设计本身更有价值。</li><li>设计思想、原则、模式本身并没有太多“高大上”的东西，都是一些简单的道理。</li><li>高手之间的竞争都是在细节。</li></ul><h3 id="36-实战二（上）：程序出错该返回啥？NULL、异常、错误码、空对象？"><a href="#36-实战二（上）：程序出错该返回啥？NULL、异常、错误码、空对象？" class="headerlink" title="36 | 实战二（上）：程序出错该返回啥？NULL、异常、错误码、空对象？"></a>36 | 实战二（上）：程序出错该返回啥？NULL、异常、错误码、空对象？</h3><p>函数出错返回数据类型：</p><ul><li>返回错误码</li><li>返回 NULL 值</li><li>返回空对象</li><li>抛出异常对象<ul><li>如果 func1() 抛出的异常是可以恢复，且 func2() 的调用方并不关心此异常，我们完全可以在 func2() 内将 func1() 抛出的异常吞掉；</li><li>如果 func1() 抛出的异常对 func2() 的调用方来说，也是可以理解的、关心的 ，并且在业务概念上有一定的相关性，我们可以选择直接将 func1 抛出的异常 re-throw；</li><li>如果 func1() 抛出的异常太底层，对 func2() 的调用方来说，缺乏背景去理解、且业务概念上无关，我们可以将它重新包装成调用方可以理解的新异常，然后 re-throw。</li></ul></li></ul><h3 id="37-实战二（下）：重构ID生成器项目中各函数的异常处理代码"><a href="#37-实战二（下）：重构ID生成器项目中各函数的异常处理代码" class="headerlink" title="37 | 实战二（下）：重构ID生成器项目中各函数的异常处理代码"></a>37 | 实战二（下）：重构ID生成器项目中各函数的异常处理代码</h3><ul><li>再简单的代码，看上去再完美的代码，只要我们下功夫去推敲，总有可以优化的空间，就看你愿不愿把事情做到极致。</li><li>如果你内功不够深厚，理论知识不够扎实，那你就很难参透开源项目的代码到底优秀在哪里。</li><li>作为一名程序员，起码对代码要有追求啊，不然跟咸鱼有啥区别！</li></ul><h2 id="设计原则与思想：总结课"><a href="#设计原则与思想：总结课" class="headerlink" title="设计原则与思想：总结课"></a>设计原则与思想：总结课</h2><h3 id="38-总结回顾面向对象、设计原则、编程规范、重构技巧等知识点"><a href="#38-总结回顾面向对象、设计原则、编程规范、重构技巧等知识点" class="headerlink" title="38 | 总结回顾面向对象、设计原则、编程规范、重构技巧等知识点"></a>38 | 总结回顾面向对象、设计原则、编程规范、重构技巧等知识点</h3><p>最常用到几个评判代码质量的标准有：可维护性、可读性、可扩展性、灵活性、简洁性、可复用性、可测试性。</p><p>面向对象编程相比面向过程编程的优势主要有三个：</p><ul><li>对于大规模复杂程序的开发，程序的处理流程并非单一的一条主线，而是错综复杂的网状结构。面向对象编程比起面向过程编程，更能应对这种复杂类型的程序开发。</li><li>面向对象编程相比面向过程编程，具有更加丰富的特性（封装、抽象、继承、多态）。利用这些特性编写出来的代码，更加易扩展、易复用、易维护。</li><li>从编程语言跟机器打交道方式的演进规律中，我们可以总结出：面向对象编程语言比起面向过程编程语言，更加人性化、更加高级、更加智能。</li></ul><p>面向对象分析（OOA）、面向对象设计（OOD）、面向对象编程（OOP），是面向对象开发的三个主要环节。简单点讲，面向对象分析就是要搞清楚做什么，面向对象设计就是要搞清楚怎么做，面向对象编程就是将分析和设计的的结果翻译成代码的过程。</p><p>UML 统一建模语言中定义了六种类之间的关系。它们分别是：泛化、实现、关联、聚合、组合、依赖。我们从更加贴近编程的角度，对类与类之间的关系做了调整，保留了四个关系：泛化、实现、组合、依赖。</p><p>如果要表示一种 is-a 的关系，并且是为了解决代码复用问题，我们就用抽象类；如果要表示一种 has-a 关系，并且是为了解决抽象而非代码复用问题，那我们就用接口。</p><p>基于充血模型的 DDD 开发模式跟基于贫血模型的传统开发模式相比，Controller 层和 Repository 层的代码基本上相同。这是因为，Repository 层的 Entity 生命周期有限，Controller 层的 VO 只是单纯作为一种 DTO。两部分的业务逻辑都不会太复杂。业务逻辑主要集中在 Service 层。所以，Repository 层和 Controller 层继续沿用贫血模型的设计思路是没有问题的。</p><p>设计原则：</p><ul><li>SRP 单一职责原则</li><li>OCP 开闭原则</li><li>LSP 里氏替换原则</li><li>ISP 接口隔离原则</li><li>DIP 依赖倒置原则</li><li>KISS、YAGNI 原则</li><li>DRY 原则</li><li>LOD 原则</li></ul><h3 id="39-运用学过的设计原则和思想完善之前讲的性能计数器项目（上）"><a href="#39-运用学过的设计原则和思想完善之前讲的性能计数器项目（上）" class="headerlink" title="39 | 运用学过的设计原则和思想完善之前讲的性能计数器项目（上）"></a>39 | 运用学过的设计原则和思想完善之前讲的性能计数器项目（上）</h3><img src="https://static001.geekbang.org/resource/image/13/34/1303d16f75c7266cef9105f540c54834.jpg"><h3 id="40-运用学过的设计原则和思想完善之前讲的性能计数器项目（下）"><a href="#40-运用学过的设计原则和思想完善之前讲的性能计数器项目（下）" class="headerlink" title="40 | 运用学过的设计原则和思想完善之前讲的性能计数器项目（下）"></a>40 | 运用学过的设计原则和思想完善之前讲的性能计数器项目（下）</h3><h2 id="设计模式与规范：创建型"><a href="#设计模式与规范：创建型" class="headerlink" title="设计模式与规范：创建型"></a>设计模式与规范：创建型</h2><h3 id="41-单例模式（上）：为什么说支持懒加载的双重检测不比饿汉式更优？"><a href="#41-单例模式（上）：为什么说支持懒加载的双重检测不比饿汉式更优？" class="headerlink" title="41 | 单例模式（上）：为什么说支持懒加载的双重检测不比饿汉式更优？"></a>41 | 单例模式（上）：为什么说支持懒加载的双重检测不比饿汉式更优？</h3><p><strong>单例设计模式</strong>（Singleton Design Pattern）理解起来非常简单。一个类只允许创建一个对象（或者实例），那这个类就是一个单例类，这种设计模式就叫作单例设计模式，简称单例模式。</p><p>如何实现一个单例类？</p><ul><li>构造函数需要是 private 访问权限的，这样才能避免外部通过 new 创建实例；- 考虑对象创建时的线程安全问题；</li><li>考虑是否支持延迟加载；</li><li>考虑 getInstance() 性能是否高（是否加锁）。</li></ul><p>单例的实现：</p><ul><li>饿汉式；</li><li>懒汉式；</li><li>双重检测；</li><li>静态内部类；</li><li>枚举。</li></ul><h3 id="42-单例模式（中）：我为什么不推荐使用单例模式？又有何替代方案？"><a href="#42-单例模式（中）：我为什么不推荐使用单例模式？又有何替代方案？" class="headerlink" title="42 | 单例模式（中）：我为什么不推荐使用单例模式？又有何替代方案？"></a>42 | 单例模式（中）：我为什么不推荐使用单例模式？又有何替代方案？</h3><ul><li>单例对 OOP 特性的支持不友好</li><li>单例会隐藏类之间的依赖关系</li><li>单例对代码的扩展性不友好</li><li>单例对代码的可测试性不友好</li><li>单例不支持有参数的构造函数</li></ul><h3 id="43-单例模式（下）：如何设计实现一个集群环境下的分布式单例模式？"><a href="#43-单例模式（下）：如何设计实现一个集群环境下的分布式单例模式？" class="headerlink" title="43 | 单例模式（下）：如何设计实现一个集群环境下的分布式单例模式？"></a>43 | 单例模式（下）：如何设计实现一个集群环境下的分布式单例模式？</h3><p>单例类中对象的唯一性的作用范围是进程内的，在进程间是不唯一的。</p><p>进程内唯一：使用单例模式；<br>线程内唯一：使用ThreadLocal；<br>进程间唯一：考虑使用分布式锁。</p><p>单例模式并不是严格意义的进程内唯一，而是同一个 ClassLoader 内唯一。</p><h3 id="44-工厂模式（上）：我为什么说没事不要随便用工厂模式创建对象？"><a href="#44-工厂模式（上）：我为什么说没事不要随便用工厂模式创建对象？" class="headerlink" title="44 | 工厂模式（上）：我为什么说没事不要随便用工厂模式创建对象？"></a>44 | 工厂模式（上）：我为什么说没事不要随便用工厂模式创建对象？</h3><ul><li>简单工厂模式（静态工厂模式）</li><li>工厂模式</li><li>抽象工厂模式</li></ul><p>当每个对象的创建逻辑都比较简单的时候，我推荐使用简单工厂模式，将多个对象的创建逻辑放到一个工厂类中。当每个对象的创建逻辑都比较复杂的时候，为了避免设计一个过于庞大的简单工厂类，我推荐使用工厂方法模式，将创建逻辑拆分得更细，每个对象的创建逻辑独立到各自的工厂类中。</p><ul><li>封装变化：创建逻辑有可能变化，封装成工厂类之后，创建逻辑的变更对调用者透明。</li><li>代码复用：创建代码抽离到独立的工厂类之后可以复用。</li><li>隔离复杂性：封装复杂的创建逻辑，调用者无需了解如何创建对象。</li><li>控制复杂度：将创建代码抽离出来，让原本的函数或类职责更单一，代码更简洁。</li></ul><h3 id="45-工厂模式（下）：如何设计实现一个Dependency-Injection框架？"><a href="#45-工厂模式（下）：如何设计实现一个Dependency-Injection框架？" class="headerlink" title="45 | 工厂模式（下）：如何设计实现一个Dependency Injection框架？"></a>45 | 工厂模式（下）：如何设计实现一个Dependency Injection框架？</h3><p>一个简单的 DI 容器的核心功能一般有三个：配置解析、对象创建和对象生命周期管理。</p><p>Spring 处理循环依赖：</p><ul><li>通过构造器注入的循环依赖，是无法解决的。</li><li>Spring 容器对原型作用域的 bean 是不进行缓存，因此无法提前暴露一个创建中的 bean，所以也是无法解决这种情况的循环依赖。</li><li>对于 setter 注入造成的依赖可以通过 Spring 容器提前暴露刚完成构造器注入但未完成其他步骤（如 setter 注入）的 bean 来完成，而且只能解决单例作用域的 bean 依赖。</li></ul><p><a href="https://juejin.im/post/5d0d8f64f265da1b7b3193ac" target="_blank" rel="noopener">Spring 源码学习(五)循环依赖</a></p><h3 id="46-建造者模式：详解构造函数、set方法、建造者模式三种对象创建方式"><a href="#46-建造者模式：详解构造函数、set方法、建造者模式三种对象创建方式" class="headerlink" title="46 | 建造者模式：详解构造函数、set方法、建造者模式三种对象创建方式"></a>46 | 建造者模式：详解构造函数、set方法、建造者模式三种对象创建方式</h3><p>使用建造者模式创建对象，还能避免对象存在无效状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Rectangle r = <span class="keyword">new</span> Rectange(); <span class="comment">// r is invalid</span></span><br><span class="line">r.setWidth(<span class="number">2</span>); <span class="comment">// r is invalid</span></span><br><span class="line">r.setHeight(<span class="number">3</span>); <span class="comment">// r is valid</span></span><br></pre></td></tr></table></figure><p>工厂模式是用来创建不同但是相关类型的对象（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。建造者模式是用来创建一种类型的复杂对象，通过设置不同的可选参数，“定制化”地创建不同的对象。</p><p>顾客走进一家餐馆点餐，我们利用工厂模式，根据用户不同的选择，来制作不同的食物，比如披萨、汉堡、沙拉。对于披萨来说，用户又有各种配料可以定制，比如奶酪、西红柿、起司，我们通过建造者模式根据用户选择的不同配料来制作披萨。</p><h3 id="47-原型模式：如何最快速地clone一个HashMap散列表？"><a href="#47-原型模式：如何最快速地clone一个HashMap散列表？" class="headerlink" title="47 | 原型模式：如何最快速地clone一个HashMap散列表？"></a>47 | 原型模式：如何最快速地clone一个HashMap散列表？</h3><p>如果对象的创建成本比较大，而同一个类的不同对象之间差别不大（大部分字段都相同），在这种情况下，我们可以利用对已有对象（原型）进行复制（或者叫拷贝）的方式，来创建新对象，以达到节省创建时间的目的。这种基于原型来创建对象的方式就叫作原型设计模式，简称原型模式。</p><p>在 Java 语言中，Object 类的 clone() 方法执行的就是我们刚刚说的浅拷贝。它只会拷贝对象中的基本数据类型的数据（比如，int、long），以及引用对象（SearchWord）的内存地址，不会递归地拷贝引用对象本身。</p><img src="https://static001.geekbang.org/resource/image/74/82/74bceb7a0736957daaa4abeba6826182.jpg"><img src="https://static001.geekbang.org/resource/image/b9/1b/b978d054ab3183b9e0ae461e6abac81b.jpg"><h2 id="设计模式与规范：结构型"><a href="#设计模式与规范：结构型" class="headerlink" title="设计模式与规范：结构型"></a>设计模式与规范：结构型</h2><h3 id="48-代理模式：代理在RPC、缓存、监控等场景中的应用"><a href="#48-代理模式：代理在RPC、缓存、监控等场景中的应用" class="headerlink" title="48 | 代理模式：代理在RPC、缓存、监控等场景中的应用"></a>48 | 代理模式：代理在RPC、缓存、监控等场景中的应用</h3><p>在不改变原始类（或叫被代理类）的情况下，通过引入代理类来给原始类附加功能。一般情况下，我们让代理类和原始类实现同样的接口。但是，如果原始类并没有定义接口，并且原始类代码并不是我们开发维护的。在这种情况下，我们可以通过让代理类继承原始类的方法来实现代理模式。</p><p>静态代理需要针对每个类都创建一个代理类，并且每个代理类中的代码都有点像模板式的”重复“代码，增加了维护成本和开发成本。对于静态代理存在的问题，我们可以通过动态代理来解决。我们不事先为每个原始类编写代理类，而是在运行的时候动态地创建原始类对应的代理类，然后在系统中用代理类替换掉原始类。</p><h3 id="49-桥接模式：如何实现支持不同类型和渠道的消息推送系统？"><a href="#49-桥接模式：如何实现支持不同类型和渠道的消息推送系统？" class="headerlink" title="49 | 桥接模式：如何实现支持不同类型和渠道的消息推送系统？"></a>49 | 桥接模式：如何实现支持不同类型和渠道的消息推送系统？</h3><p>Decouple an abstraction from its implementation so that the two can vary independently。（将抽象和实现解耦，让它们可以独立变化。）</p><h3 id="50-装饰器模式：通过剖析Java-IO类库源码学习装饰器模式"><a href="#50-装饰器模式：通过剖析Java-IO类库源码学习装饰器模式" class="headerlink" title="50 | 装饰器模式：通过剖析Java IO类库源码学习装饰器模式"></a>50 | 装饰器模式：通过剖析Java IO类库源码学习装饰器模式</h3><p>装饰器类和原始类继承同样的父类，这样我们可以对原始类“嵌套”多个装饰器类。</p><p>装饰器类是对功能的增强，这也是装饰器模式应用场景的一个重要特点。</p><p>代理模式中，代理类附加的是跟原始类无关的功能，而在装饰器模式中，装饰器类附加的是跟原始类相关的增强功能。</p><img src="https://static001.geekbang.org/resource/image/50/05/507526c2e4b255a45c60722df14f9a05.jpg"><img src="https://static001.geekbang.org/resource/image/50/13/5082df8e7d5a4d44a34811b9f562d613.jpg"><h3 id="51-适配器模式：代理、适配器、桥接、装饰，这四个模式有何区别？"><a href="#51-适配器模式：代理、适配器、桥接、装饰，这四个模式有何区别？" class="headerlink" title="51 | 适配器模式：代理、适配器、桥接、装饰，这四个模式有何区别？"></a>51 | 适配器模式：代理、适配器、桥接、装饰，这四个模式有何区别？</h3><p>适配器模式有两种实现方式：类适配器和对象适配器。其中，类适配器使用继承关系来实现，对象适配器使用组合关系来实现。</p><p><strong>代理模式</strong>：代理模式在不改变原始类接口的条件下，为原始类定义一个代理类，主要目的是控制访问，而非加强功能，这是它跟装饰器模式最大的不同。<br><strong>桥接模式</strong>：桥接模式的目的是将接口部分和实现部分分离，从而让它们可以较为容易、也相对独立地加以改变。<br><strong>装饰器模式</strong>：装饰者模式在不改变原始类接口的情况下，对原始类功能进行增强，并且支持多个装饰器的嵌套使用。<br><strong>适配器模式</strong>：适配器模式是一种事后的补救策略。适配器提供跟原始类不同的接口，而代理模式、装饰器模式提供的都是跟原始类相同的接口。</p><h3 id="52-门面模式：如何设计合理的接口粒度以兼顾接口的易用性和通用性？"><a href="#52-门面模式：如何设计合理的接口粒度以兼顾接口的易用性和通用性？" class="headerlink" title="52 | 门面模式：如何设计合理的接口粒度以兼顾接口的易用性和通用性？"></a>52 | 门面模式：如何设计合理的接口粒度以兼顾接口的易用性和通用性？</h3><p><strong>门面模式</strong>：</p><ul><li>Provide a unified interface to a set of interfaces in a subsystem. Facade Pattern defines a higher-level interface that makes the subsystem easier to use.</li><li>门面模式为子系统提供一组统一的接口，定义一组高层接口让子系统更易用。</li></ul><p>完成接口设计，就相当于完成了一半的开发任务。只要接口设计得好，那代码就差不到哪里去。</p><p>尽量保持接口的可复用性，但针对特殊情况，允许提供冗余的门面接口，来提供更易用的接口。</p><ul><li>当要为一个复杂子系统提供一个简单接口时可以使用外观模式。</li><li>客户程序与多个子系统之间存在很大的依赖性。</li><li>使用外观模式定义系统中每一层的入口，层与层之间不直接产生联系，而通过外观类建立联系，降低层之间的耦合度。</li></ul><p>增加新的子系统可能需要修改外观类或客户端的源代码，<strong>违背了“开闭原则”</strong>。</p><h3 id="53-组合模式：如何设计实现支持递归遍历的文件系统目录树结构？"><a href="#53-组合模式：如何设计实现支持递归遍历的文件系统目录树结构？" class="headerlink" title="53 | 组合模式：如何设计实现支持递归遍历的文件系统目录树结构？"></a>53 | 组合模式：如何设计实现支持递归遍历的文件系统目录树结构？</h3><p>组合模式：Compose objects into tree structure to represent part-whole hierarchies. Composite lets client treat individual objects and compositions of objects uniformly.</p><p>将一组对象组织（Compose）成树形结构，以表示一种“部分 - 整体”的层次结构。组合让客户端（在很多设计模式书籍中，“客户端”代指代码的使用者。）可以统一单个对象和组合对象的处理逻辑。</p><h3 id="54-享元模式（上）：如何利用享元模式优化文本编辑器的内存占用？"><a href="#54-享元模式（上）：如何利用享元模式优化文本编辑器的内存占用？" class="headerlink" title="54 | 享元模式（上）：如何利用享元模式优化文本编辑器的内存占用？"></a>54 | 享元模式（上）：如何利用享元模式优化文本编辑器的内存占用？</h3><p>享元模式(Flyweight Pattern)：运用共享技术有效地支持大量细粒度对象的复用。(Use sharing to support large numbers of fine-grained objects efficiently.)</p><p>享元模式的代码实现非常简单，主要是通过工厂模式，在工厂类中，通过一个 Map 或者 List 来缓存已经创建好的享元对象，以达到复用的目的。</p><h3 id="55-享元模式（下）：剖析享元模式在Java-Integer、String中的应用"><a href="#55-享元模式（下）：剖析享元模式在Java-Integer、String中的应用" class="headerlink" title="55 | 享元模式（下）：剖析享元模式在Java Integer、String中的应用"></a>55 | 享元模式（下）：剖析享元模式在Java Integer、String中的应用</h3><p>JDK 设置 Integer 缓存参数：</p><ul><li>方法一：-Djava.lang.Integer.IntegerCache.high=255</li><li>方法二：-XX:AutoBoxCacheMax=255</li></ul><p>JDK 中 Integer 对象缓存，String 常量池，都是使用的享元模式。</p><h2 id="设计模式与规范：行为型"><a href="#设计模式与规范：行为型" class="headerlink" title="设计模式与规范：行为型"></a>设计模式与规范：行为型</h2><h3 id="56-观察者模式（上）：详解各种应用场景下观察者模式的不同实现方式"><a href="#56-观察者模式（上）：详解各种应用场景下观察者模式的不同实现方式" class="headerlink" title="56 | 观察者模式（上）：详解各种应用场景下观察者模式的不同实现方式"></a>56 | 观察者模式（上）：详解各种应用场景下观察者模式的不同实现方式</h3><p><strong>设计模式要干的事情就是解耦。创建型模式是将创建和使用代码解耦，结构型模式是将不同功能代码解耦，行为型模式是将不同的行为代码解耦，具体到观察者模式，它是将观察者和被观察者代码解耦。</strong></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://blog.cleancoder.com/uncle-bob/2014/05/08/SingleReponsibilityPrinciple.html" target="_blank" rel="noopener">The Clean Code Blog</a></li><li><a href="https://unbug.github.io/codelf/" target="_blank" rel="noopener">Codelf(变量命名神器)</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是 &lt;a href=&quot;https://time.geekbang.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;极客时间&lt;/a&gt; 上 &lt;a href=&quot;https://time.geekbang.org/column/intro/100039001&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;设计模式之美&lt;/a&gt; 课程的学习笔记内容。&lt;/p&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="https://dongzl.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://dongzl.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="设计原则" scheme="https://dongzl.github.io/tags/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>Lombok 框架使用总结</title>
    <link href="https://dongzl.github.io/2019/11/30/12-Lombok-Use-Summary/"/>
    <id>https://dongzl.github.io/2019/11/30/12-Lombok-Use-Summary/</id>
    <published>2019-11-30T12:38:18.000Z</published>
    <updated>2020-03-09T14:23:23.166Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景描述"><a href="#背景描述" class="headerlink" title="背景描述"></a>背景描述</h2><p>最近一直在参与 <a href="https://github.com/apache/incubator-shardingsphere" target="_blank" rel="noopener">ShardingSphere</a> 开源项目的一些工作，在 ShardingSphere 项目中大量的使用了 <a href="https://projectlombok.org/" target="_blank" rel="noopener">Lombok</a> 框架，对于 Lombok 框架只是有个大概了解，并没有实际的使用，也没有做过深入的研究，正好借参与 ShardingSphere 项目的机会对 Lombok 框架做一个学习和总结，先总结一下自己目前使用中遇到的问题，后续持续不断更新。</p><a id="more"></a><p>首先，来看一下 Lombok 官方对这个框架的介绍：</p><blockquote><p>Project Lombok is a java library that automatically plugs into your editor and build tools, spicing up your java.<br>Never write another getter or equals method again, with one annotation your class has a fully featured builder, Automate your logging variables, and much more.</p></blockquote><p>Lombok 是一个 java 类库，它可以自动插入到编辑器和构建工具中，对 java 代码进行增强。</p><p>使用 Lombok 后不需要再实现 getter 或者 equals 方法，使用一个注解，您的类就可以拥有一个功能齐全的构造器，自动生成一个日志变量等等功能。</p><blockquote><p>测试 Lombok 版本：1.18.10</p></blockquote><h2 id="构造方法相关注解"><a href="#构造方法相关注解" class="headerlink" title="构造方法相关注解"></a>构造方法相关注解</h2><h3 id="NoArgsConstructor"><a href="#NoArgsConstructor" class="headerlink" title="@NoArgsConstructor"></a>@NoArgsConstructor</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.AccessLevel;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NoArgsConstructor</span>(access = AccessLevel.PRIVATE, staticName = <span class="string">"of"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@NoArgsConstructor 用于生成无参构造器，如果类中存在 final 字段，则会报编译错误。</p><ul><li><code>access</code> 参数用于指定构造器的访问权限，默认为 <code>AccessLevel.PUBLIC</code> 表示生成 public 访问权限的构造器；</li><li><code>staticName</code> 参数用于自动生成一个静态的“构造器”工厂，其内部包裹着一个私有的构造器，对外提供创建对象的功能，这是明显的工厂模式。</li></ul><h3 id="RequiredArgsConstructor"><a href="#RequiredArgsConstructor" class="headerlink" title="@RequiredArgsConstructor"></a>@RequiredArgsConstructor</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.AccessLevel;</span><br><span class="line"><span class="keyword">import</span> lombok.NonNull;</span><br><span class="line"><span class="keyword">import</span> lombok.RequiredArgsConstructor;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span>(access = AccessLevel.PUBLIC, staticName = <span class="string">"of"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Integer id;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        User user = User.of(<span class="number">1</span>, <span class="string">"test"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@RequiredArgsConstructor 用于按照要求生成部分参数构造器，所谓的要求就是包含 final 和 @NonNull 约束标注的字段，会对 @NonNull 字段进行明确的 null 检查。</p><h3 id="AllArgsConstructor"><a href="#AllArgsConstructor" class="headerlink" title="@AllArgsConstructor"></a>@AllArgsConstructor</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.AccessLevel;</span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.NonNull;</span><br><span class="line"><span class="keyword">import</span> lombok.RequiredArgsConstructor;</span><br><span class="line"></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span>(access = AccessLevel.PUBLIC, staticName = <span class="string">"of"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Integer id;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        User user = User.of(<span class="number">1</span>, <span class="string">"test"</span>);</span><br><span class="line">        User user2 = <span class="keyword">new</span> User(<span class="number">1</span>, <span class="string">"test"</span>, <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@AllArgsConstructor 用于生成包含所有字段的构造器。</p><h2 id="Getter-amp-Setter"><a href="#Getter-amp-Setter" class="headerlink" title="@Getter &amp; @Setter"></a>@Getter &amp; @Setter</h2><p>@Getter &amp; @Setter 标注在字段上，用于自动生成 get、set 方法，boolean 类型字段 get 方法为 isXXX() 方法。</p><p>生成的 get、set 方法默认情况下都是 public 的，但也可以手动指定以下四种范围：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">AccessLevel.PUBLIC</span><br><span class="line">AccessLevel.MODULE</span><br><span class="line">AccessLevel.PROTECTED</span><br><span class="line">AccessLevel.PACKAGE</span><br><span class="line">AccessLevel.PRIVATE</span><br></pre></td></tr></table></figure><p>@Getter &amp; @Setter 也可以标注在类上，表示针对该类中所有的非静态字段进行 get、set 方法自动生成。如果指定某个字段的 <code>AccessLevel = AccessLevel.NONE</code>，则可以使该生成动作失效，此时可以手动实现get、set方法，AccessLevel.NONE 可以应用于在某些方法中有一些自定义逻辑的情况下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.AccessLevel;</span><br><span class="line"><span class="keyword">import</span> lombok.Getter;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Setter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Setter</span>(value = AccessLevel.PRIVATE)</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Getter</span>(value = AccessLevel.PACKAGE)</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Getter</span>(value = AccessLevel.NONE)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> student;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isStudent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (age &lt; <span class="number">18</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ToString"><a href="#ToString" class="headerlink" title="@ToString"></a>@ToString</h2><p>@ToString 标注于类之上，用于生成 toString() 方法。</p><ul><li>includeFieldNames：默认为 true，表示在 toString 输出时输出字段名称；</li><li>exclude：字符串数组，表示在 toString 输出时排除掉字段名称，这个属性将要被废弃了，用 @ToString.Exclude 来代替；</li><li>of：字符串数组，明确的列出在 toString 输出时输出字段名称，这个属性将要被废弃了，用 @ToString.Include 来代替；</li><li>callSuper：默认为 false，表示生成 toString 时不输出超类中的字段内容；</li><li>doNotUseGetters：默认为 false，表示获取字段值时通过 get 方法获取，设置为 true 表示直接通过字段获取；</li><li>onlyExplicitlyIncluded：默认为 false，表示在 toString 输出时输出全部非静态字段；设置为 true 时，表示只输出 @ToString.Include 标识的字段；</li><li>Exclude：标识属性，表示在 toString 输出时排除该字段；</li><li></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.ToString;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@ToString</span>(includeFieldNames = <span class="keyword">true</span>, exclude = &#123;<span class="string">"id"</span>, <span class="string">"name"</span>&#125;, of = &#123;&#125;, callSuper = <span class="keyword">true</span>, doNotUseGetters = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> student;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="EqualsAndHashCode"><a href="#EqualsAndHashCode" class="headerlink" title="@EqualsAndHashCode"></a>@EqualsAndHashCode</h2><p>@EqualsAndHashCode 标注于类之上用于生成hashCode方法和equals方法。</p><ul><li>exclude：字符串数组，表示在 toString 输出时排除掉字段名称；</li><li>of：</li><li>callSuper：默认为 false，表示生成 toString 时不输出超类中的字段内容；</li><li>doNotUseGetters：默认为 false，表示获取字段值时通过 get 方法获取，设置为 true 表示直接通过字段获取。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.EqualsAndHashCode;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@EqualsAndHashCode</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Data"><a href="#Data" class="headerlink" title="@Data"></a>@Data</h2><p>@Data 标注于类之上，是 @ToString、@EqualsAndHashCode、@Getter、@Setter、@RequiredArgsConstructor的综合体</p><ul><li>staticConstructor：类似于 @RequiredArgsConstructor 中 staticName 参数。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span>(staticConstructor = <span class="string">"of"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SneakyThrows"><a href="#SneakyThrows" class="headerlink" title="@SneakyThrows"></a>@SneakyThrows</h2><p>@SneakyThrows 标注于方法之上用于隐藏异常抛出语句。</p><h2 id="Log-日志"><a href="#Log-日志" class="headerlink" title="Log 日志"></a>Log 日志</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">lombok.extern.apachecommons.CommonsLog;</span><br><span class="line">lombok.extern.flogger.Flogger;</span><br><span class="line">lombok.extern.java.Log;</span><br><span class="line">lombok.extern.jbosslog.JBossLog;</span><br><span class="line">lombok.extern.log4j.Log4j;</span><br><span class="line">lombok.extern.log4j.Log4j2;</span><br><span class="line">lombok.extern.slf4j.Slf4j;</span><br><span class="line">lombok.extern.slf4j.XSlf4j;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://projectlombok.org/" target="_blank" rel="noopener">Project Lombok</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景描述&quot;&gt;&lt;a href=&quot;#背景描述&quot; class=&quot;headerlink&quot; title=&quot;背景描述&quot;&gt;&lt;/a&gt;背景描述&lt;/h2&gt;&lt;p&gt;最近一直在参与 &lt;a href=&quot;https://github.com/apache/incubator-shardingsphere&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ShardingSphere&lt;/a&gt; 开源项目的一些工作，在 ShardingSphere 项目中大量的使用了 &lt;a href=&quot;https://projectlombok.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Lombok&lt;/a&gt; 框架，对于 Lombok 框架只是有个大概了解，并没有实际的使用，也没有做过深入的研究，正好借参与 ShardingSphere 项目的机会对 Lombok 框架做一个学习和总结，先总结一下自己目前使用中遇到的问题，后续持续不断更新。&lt;/p&gt;
    
    </summary>
    
    
      <category term="web开发" scheme="https://dongzl.github.io/categories/web%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Lombok" scheme="https://dongzl.github.io/tags/Lombok/"/>
    
  </entry>
  
</feed>
