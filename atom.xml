<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>董宗磊的博客</title>
  
  <subtitle>董宗磊的博客--善积跬步，方以千里</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://dongzl.github.io/"/>
  <updated>2020-03-09T13:32:28.199Z</updated>
  <id>https://dongzl.github.io/</id>
  
  <author>
    <name>[object Object]</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>论“茴”字的四种写法：一道面试题总结线程间通信的几种方式</title>
    <link href="https://dongzl.github.io/2020/03/07/07-Several-Methods-Of-Communication-Between-Thread/"/>
    <id>https://dongzl.github.io/2020/03/07/07-Several-Methods-Of-Communication-Between-Thread/</id>
    <published>2020-03-07T13:35:58.000Z</published>
    <updated>2020-03-09T13:32:28.199Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景描述"><a href="#背景描述" class="headerlink" title="背景描述"></a>背景描述</h2><blockquote><p>用两个线程，一个输出字母，一个输出数字，交替输出：1A2B3C4D5E…26Z。</p></blockquote><img src="https://gitee.com/dongzl/article-images/raw/master/2020/07-Several-Methods-Of-Communication-Between-Thread/Several-Methods-Of-Communication-Between-Thread.png"><p>这是一道典型的线程间通信的面试题，两个线程交替<strong>运行-暂停</strong>，并且当一个线程运行后需要暂停，同时要通知另外一个线程运行；另外一个线程得到通知后开始运行，运行后暂停并通知对方线程运行，彼此交替运行，直至打印完整结果。对于这个问题有很多中解法，下面我们就一一分析这些方法。</p><a id="more"></a><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="LockSupport-类实现"><a href="#LockSupport-类实现" class="headerlink" title="LockSupport 类实现"></a>LockSupport 类实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.LockSupport;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockSupportDemo</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Thread t1, t2;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] digit = <span class="keyword">new</span> String[]&#123;<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"5"</span>, <span class="string">"6"</span>, <span class="string">"7"</span>, <span class="string">"8"</span>, <span class="string">"9"</span>, <span class="string">"10"</span>&#125;;</span><br><span class="line">        String[] alphabet = <span class="keyword">new</span> String[]&#123;<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>, <span class="string">"E"</span>, <span class="string">"F"</span>, <span class="string">"G"</span>, <span class="string">"H"</span>, <span class="string">"I"</span>, <span class="string">"J"</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (String d : digit) &#123;</span><br><span class="line">                    System.out.println(d);</span><br><span class="line">                    LockSupport.unpark(t2);</span><br><span class="line">                    LockSupport.park(t1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t1"</span>);</span><br><span class="line">        </span><br><span class="line">        t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (String a : alphabet) &#123;</span><br><span class="line">                    LockSupport.park(t2);</span><br><span class="line">                    System.out.println(a);</span><br><span class="line">                    LockSupport.unpark(t1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t2"</span>);</span><br><span class="line">        </span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>LockSupport</code> 中的 <code>park</code> 和 <code>unpark</code> 可以实现线程的阻塞与唤醒。</p><ul><li><p><code>park</code>: Disables the current thread for thread scheduling purposes unless the permit is available.</p></li><li><p><code>unpark</code>: Makes available the permit for the given thread, if it was not already available.</p></li></ul><h3 id="while-循环-volatile-变量实现"><a href="#while-循环-volatile-变量实现" class="headerlink" title="while 循环 + volatile 变量实现"></a>while 循环 + volatile 变量实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WhileCycleDemo</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">enum</span> RunThreadEnum &#123;T1, T2&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> RunThreadEnum run = RunThreadEnum.T1;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] digit = <span class="keyword">new</span> String[]&#123;<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"5"</span>, <span class="string">"6"</span>, <span class="string">"7"</span>, <span class="string">"8"</span>, <span class="string">"9"</span>, <span class="string">"10"</span>&#125;;</span><br><span class="line">        String[] alphabet = <span class="keyword">new</span> String[]&#123;<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>, <span class="string">"E"</span>, <span class="string">"F"</span>, <span class="string">"G"</span>, <span class="string">"H"</span>, <span class="string">"I"</span>, <span class="string">"J"</span>&#125;;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (String d : digit) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (run != RunThreadEnum.T1) &#123;&#125;</span><br><span class="line">                    System.out.println(d);</span><br><span class="line">                    run = RunThreadEnum.T2;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t1"</span>).start();</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (String a : alphabet) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (run != RunThreadEnum.T2) &#123;&#125;</span><br><span class="line">                    System.out.println(a);</span><br><span class="line">                    run = RunThreadEnum.T1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 <code>while 循环 + volatile 变量</code> 这种实现方案，程序并不难理解，通过交替设置某个变量值的方式实现效果，不过这种方式实现需要注意一点就是 <code>run</code> 变量一定要使用 <code>volatile</code> 关键字修饰，保证变量的内存可见性。</p><h3 id="AtomicBoolean-类实现"><a href="#AtomicBoolean-类实现" class="headerlink" title="AtomicBoolean 类实现"></a>AtomicBoolean 类实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicBoolean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicBooleanDemo</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> AtomicBoolean run = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] digit = <span class="keyword">new</span> String[]&#123;<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"5"</span>, <span class="string">"6"</span>, <span class="string">"7"</span>, <span class="string">"8"</span>, <span class="string">"9"</span>, <span class="string">"10"</span>&#125;;</span><br><span class="line">        String[] alphabet = <span class="keyword">new</span> String[]&#123;<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>, <span class="string">"E"</span>, <span class="string">"F"</span>, <span class="string">"G"</span>, <span class="string">"H"</span>, <span class="string">"I"</span>, <span class="string">"J"</span>&#125;;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (String d : digit) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (run.get()) &#123;&#125;</span><br><span class="line">                    System.out.println(d);</span><br><span class="line">                    run.set(<span class="keyword">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t1"</span>).start();</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (String a : alphabet) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (!run.get()) &#123;&#125;</span><br><span class="line">                    System.out.println(a);</span><br><span class="line">                    run.set(<span class="keyword">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>AtomicBoolean</code> 类实现也比较好理解，主要是借助内部API实现来保证变量在线程之间的可见性。</p><h3 id="BlockingQueue-阻塞队列实现"><a href="#BlockingQueue-阻塞队列实现" class="headerlink" title="BlockingQueue 阻塞队列实现"></a>BlockingQueue 阻塞队列实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockingQueueDemo</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> BlockingQueue&lt;String&gt; queue1 = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">static</span> BlockingQueue&lt;String&gt; queue2 = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] digit = <span class="keyword">new</span> String[]&#123;<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"5"</span>, <span class="string">"6"</span>, <span class="string">"7"</span>, <span class="string">"8"</span>, <span class="string">"9"</span>, <span class="string">"10"</span>&#125;;</span><br><span class="line">        String[] alphabet = <span class="keyword">new</span> String[]&#123;<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>, <span class="string">"E"</span>, <span class="string">"F"</span>, <span class="string">"G"</span>, <span class="string">"H"</span>, <span class="string">"I"</span>, <span class="string">"J"</span>&#125;;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (String d : digit) &#123;</span><br><span class="line">                    System.out.println(d);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        queue1.put(<span class="string">"ok"</span>);</span><br><span class="line">                        queue2.take();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t1"</span>).start();</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (String a : alphabet) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        queue1.take();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(a);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        queue2.put(<span class="string">"ok"</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>借助 <code>BlockingQueue</code> 类实现，主要是借助阻塞队列的阻塞特性，当队列为空时，调用阻塞队列的 <code>take</code> 方法，会阻塞当前线程的执行，直到队列不为空后唤醒当前线程继续执行。</p><h3 id="PipedInputStream-amp-PipedOutputStream-实现"><a href="#PipedInputStream-amp-PipedOutputStream-实现" class="headerlink" title="PipedInputStream &amp; PipedOutputStream 实现"></a>PipedInputStream &amp; PipedOutputStream 实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PipedInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.PipedOutputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PipedStreamDemo</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String[] digit = <span class="keyword">new</span> String[]&#123;<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"5"</span>, <span class="string">"6"</span>, <span class="string">"7"</span>, <span class="string">"8"</span>, <span class="string">"9"</span>, <span class="string">"10"</span>&#125;;</span><br><span class="line">        String[] alphabet = <span class="keyword">new</span> String[]&#123;<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>, <span class="string">"E"</span>, <span class="string">"F"</span>, <span class="string">"G"</span>, <span class="string">"H"</span>, <span class="string">"I"</span>, <span class="string">"J"</span>&#125;;</span><br><span class="line">    </span><br><span class="line">        PipedInputStream input1 = <span class="keyword">new</span> PipedInputStream();</span><br><span class="line">        PipedInputStream input2 = <span class="keyword">new</span> PipedInputStream();</span><br><span class="line">        PipedOutputStream output1 = <span class="keyword">new</span> PipedOutputStream();</span><br><span class="line">        PipedOutputStream output2 = <span class="keyword">new</span> PipedOutputStream();</span><br><span class="line">        </span><br><span class="line">        input1.connect(output2);</span><br><span class="line">        input2.connect(output1);</span><br><span class="line">        </span><br><span class="line">        String msg = <span class="string">"exchange"</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">8</span>];</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (String d : digit) &#123;</span><br><span class="line">                        System.out.println(d);</span><br><span class="line">                        output1.write(msg.getBytes());</span><br><span class="line">                        input1.read(buffer);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t1"</span>).start();</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">8</span>];</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (String a : alphabet) &#123;</span><br><span class="line">                        input2.read(buffer);</span><br><span class="line">                        System.out.println(a);</span><br><span class="line">                        output2.write(msg.getBytes());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种事借助了 <code>java.io</code> 包中的 <code>PipedInputStream &amp; PipedOutputStream</code> 来实现，这两个类在实际中真是没有使用过，而且从程序运行效果来看，上述代码执行效率非常之低，其实这种实现方案只是一个凑数，开脑洞的方案。</p><h3 id="synchronized-wait-notifyAll-实现"><a href="#synchronized-wait-notifyAll-实现" class="headerlink" title="synchronized + wait() + notifyAll() 实现"></a>synchronized + wait() + notifyAll() 实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitNotifyDemo</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        Object o = <span class="keyword">new</span> Object();</span><br><span class="line">        </span><br><span class="line">        String[] digit = <span class="keyword">new</span> String[]&#123;<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"5"</span>, <span class="string">"6"</span>, <span class="string">"7"</span>, <span class="string">"8"</span>, <span class="string">"9"</span>, <span class="string">"10"</span>&#125;;</span><br><span class="line">        String[] alphabet = <span class="keyword">new</span> String[]&#123;<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>, <span class="string">"E"</span>, <span class="string">"F"</span>, <span class="string">"G"</span>, <span class="string">"H"</span>, <span class="string">"I"</span>, <span class="string">"J"</span>&#125;;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (o) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (String d : digit) &#123;</span><br><span class="line">                        System.out.println(d);</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            o.notifyAll();</span><br><span class="line">                            o.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    o.notifyAll(); <span class="comment">//一定再调用一次，否则程序无法退出执行</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t1"</span>).start();</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (o) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (String a : alphabet) &#123;</span><br><span class="line">                        System.out.println(a);</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            o.notifyAll();</span><br><span class="line">                            o.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    o.notifyAll();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 <code>Object</code> 类中 <code>wait()</code> &amp; <code>notifyAll()</code> 方法使用，也可以达到交替打印的效果。其中 <code>wait()</code> 方法作用是使当前线程阻塞，释放资源对象 o，<code>notifyAll()</code> 方法作用是唤醒正在等待资源对象 o 的线程，使其继续向下执行。这里需要注意一点是在循环打印输出之后，一定要再次调用<code>notifyAll()</code> 方法，因为两个线程交替<strong>执行-等待</strong>，最后一定会有一个线程处于等待状态，如果不最后再调用一次<code>notifyAll()</code> 方法，那么一定会有一个线程无法退出执行，程序也就无法终止。</p><p>PS. 这里还有一点需要注意就是上述程序无法控制<strong>数字和字母输出先后顺序，也行是数字先输出，也许是字母先输出</strong>，因为线程两断代码完全一致，执行先后顺序无法确定，这个问题我们可以借助 <code>CountDownLatch</code> 工具类或者通过一个标志变量来处理，程序如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitNotifyDemo</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        Object o = <span class="keyword">new</span> Object();</span><br><span class="line">    </span><br><span class="line">        CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        String[] digit = <span class="keyword">new</span> String[]&#123;<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"5"</span>, <span class="string">"6"</span>, <span class="string">"7"</span>, <span class="string">"8"</span>, <span class="string">"9"</span>, <span class="string">"10"</span>&#125;;</span><br><span class="line">        String[] alphabet = <span class="keyword">new</span> String[]&#123;<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>, <span class="string">"E"</span>, <span class="string">"F"</span>, <span class="string">"G"</span>, <span class="string">"H"</span>, <span class="string">"I"</span>, <span class="string">"J"</span>&#125;;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">//latch.await(); //借助 CountDownLatch 工具解决先后顺序问题(需要处理异常)</span></span><br><span class="line">                <span class="keyword">synchronized</span> (o) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (!flag) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            o.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">for</span> (String d : digit) &#123;</span><br><span class="line">                        System.out.println(d);</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            o.notifyAll();</span><br><span class="line">                            o.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    o.notifyAll(); <span class="comment">//一定再调用一次，否则程序无法退出执行</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t1"</span>).start();</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (o) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (String a : alphabet) &#123;</span><br><span class="line">                        System.out.println(a);</span><br><span class="line">                        <span class="comment">//latch.countDown();</span></span><br><span class="line">                        flag = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            o.notifyAll();</span><br><span class="line">                            o.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    o.notifyAll();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Lock-Condition-实现"><a href="#Lock-Condition-实现" class="headerlink" title="Lock + Condition 实现"></a>Lock + Condition 实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockConditionDemo</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        String[] digit = <span class="keyword">new</span> String[]&#123;<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"5"</span>, <span class="string">"6"</span>, <span class="string">"7"</span>, <span class="string">"8"</span>, <span class="string">"9"</span>, <span class="string">"10"</span>&#125;;</span><br><span class="line">        String[] alphabet = <span class="keyword">new</span> String[]&#123;<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>, <span class="string">"E"</span>, <span class="string">"F"</span>, <span class="string">"G"</span>, <span class="string">"H"</span>, <span class="string">"I"</span>, <span class="string">"J"</span>&#125;;</span><br><span class="line">    </span><br><span class="line">        Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        Condition condition1 = lock.newCondition();</span><br><span class="line">        Condition condition2 = lock.newCondition();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    lock.lock();</span><br><span class="line">                    <span class="keyword">for</span> (String d : digit) &#123;</span><br><span class="line">                        System.out.println(d);</span><br><span class="line">                        condition2.signalAll();</span><br><span class="line">                        condition1.await();</span><br><span class="line">                    &#125;</span><br><span class="line">                    condition2.signalAll(); <span class="comment">// 需要调用一次，否则程序无法终止</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t1"</span>).start();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    lock.lock();</span><br><span class="line">                    <span class="keyword">for</span> (String a : alphabet) &#123;</span><br><span class="line">                        System.out.println(a);</span><br><span class="line">                        condition1.signalAll();</span><br><span class="line">                        condition2.await();</span><br><span class="line">                    &#125;</span><br><span class="line">                    condition1.signalAll();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Lock + Condition</code> 实现方案与 <code>synchronized + wait() + notifyAll()</code>实现方案非常类似，包括使用的API都存在相似的对应关系：</p><ul><li>synchronized 关键字 VS Lock 类</li><li>Condition.await() VS Object.wait()</li><li>Condition.signalAll() VS Object.notifyAll()</li></ul><p>包括需要注意的问题，在使用 <code>Lock + Condition</code> 时我们也需要在循环执行最后在调用一次 <code>signalAll()</code> 方法，否则程序无法终止运行。</p><h2 id="最后总结"><a href="#最后总结" class="headerlink" title="最后总结"></a>最后总结</h2><p>对于这道面试题，主要还是考察线程之间通信问题，主要的考点应该是在<code>synchronized + wait() + notifyAll()</code> 的使用上，当然对于其他实现方案，比较好的是：</p><ul><li>Lock + Condition 实现</li><li>LockSupport 类实现</li></ul><p>对于其它的方案，有的是使用了一些编程技巧，有的是利用 JDK 中现有类的一些实现，并不是重点考察方向，像 <code>PipedInputStream &amp; PipedOutputStream</code> 的实现方案，虽然可以达到效果，其实有些充数的嫌疑，如果有面试官硬扣这种实现，就有点像鲁迅笔下的孔乙己先生在和你讨论“茴”字有几种写法的味道了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景描述&quot;&gt;&lt;a href=&quot;#背景描述&quot; class=&quot;headerlink&quot; title=&quot;背景描述&quot;&gt;&lt;/a&gt;背景描述&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;用两个线程，一个输出字母，一个输出数字，交替输出：1A2B3C4D5E…26Z。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;img src=&quot;https://gitee.com/dongzl/article-images/raw/master/2020/07-Several-Methods-Of-Communication-Between-Thread/Several-Methods-Of-Communication-Between-Thread.png&quot;&gt;

&lt;p&gt;这是一道典型的线程间通信的面试题，两个线程交替&lt;strong&gt;运行-暂停&lt;/strong&gt;，并且当一个线程运行后需要暂停，同时要通知另外一个线程运行；另外一个线程得到通知后开始运行，运行后暂停并通知对方线程运行，彼此交替运行，直至打印完整结果。对于这个问题有很多中解法，下面我们就一一分析这些方法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java开发" scheme="https://dongzl.github.io/categories/java%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Thread" scheme="https://dongzl.github.io/tags/Thread/"/>
    
      <category term="Lock" scheme="https://dongzl.github.io/tags/Lock/"/>
    
      <category term="synchronized" scheme="https://dongzl.github.io/tags/synchronized/"/>
    
  </entry>
  
  <entry>
    <title>极客时间 《数据结构与算法之美》 学习笔记</title>
    <link href="https://dongzl.github.io/2020/03/05/06-The-Beauty-Of-Data-Structures-And-Algorithms/"/>
    <id>https://dongzl.github.io/2020/03/05/06-The-Beauty-Of-Data-Structures-And-Algorithms/</id>
    <published>2020-03-05T01:36:44.000Z</published>
    <updated>2020-03-09T14:18:41.064Z</updated>
    
    <content type="html"><![CDATA[<p>本文是 <a href="https://time.geekbang.org/" target="_blank" rel="noopener">极客时间</a> 上 <a href="https://time.geekbang.org/column/intro/126" target="_blank" rel="noopener">数据结构与算法之美</a> 课程的学习笔记内容。</p><a id="more"></a><h2 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h2><h3 id="10-递归：如何用三行代码找到“最终推荐人”？"><a href="#10-递归：如何用三行代码找到“最终推荐人”？" class="headerlink" title="10 | 递归：如何用三行代码找到“最终推荐人”？"></a>10 | 递归：如何用三行代码找到“最终推荐人”？</h3><p><strong>递归需要满足的三个条件</strong>：</p><ul><li>一个问题的解可以分解为几个子问题的解</li><li>这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样</li><li>存在递归终止条件</li></ul><p><font color="red">写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码</font></p><p><strong>编写递归代码的关键是，只要遇到递归，我们就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤。</strong></p><p><strong>使用递归可能需要规避的问题</strong>：</p><ul><li>递归代码要警惕堆栈溢出</li><li>递归代码要警惕重复计算</li></ul><p><a href="https://mp.weixin.qq.com/s/Ki3WN2AJ5HhxxmaQ0lVh3Q" target="_blank" rel="noopener">还有程序员天真地以为”尾递归“真的可以避免堆栈溢出！</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是 &lt;a href=&quot;https://time.geekbang.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;极客时间&lt;/a&gt; 上 &lt;a href=&quot;https://time.geekbang.org/column/intro/126&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;数据结构与算法之美&lt;/a&gt; 课程的学习笔记内容。&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://dongzl.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="https://dongzl.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="https://dongzl.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>聊聊代理模式（Proxy）的使用</title>
    <link href="https://dongzl.github.io/2020/02/29/05-Design-Pattern-Proxy/"/>
    <id>https://dongzl.github.io/2020/02/29/05-Design-Pattern-Proxy/</id>
    <published>2020-02-29T06:44:21.000Z</published>
    <updated>2020-03-09T13:35:42.159Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>最近在学习 <a href="https://time.geekbang.org/" target="_blank" rel="noopener">极客时间</a> 的 <a href="https://time.geekbang.org/column/intro/250" target="_blank" rel="noopener">设计模式之美</a> 课程，这一篇算是自己的学习总结。代理模式（Proxy）在很多非常优秀框架中都有他的身影，比如，大名鼎鼎的 Spring AOP 就是使用动态代理（Dynamic Proxy）模式；还有就是在一些微服务框架中，如果调用一个远程服务接口，RPC 框架一般都会使用代理模式。</p><a id="more"></a><h2 id="代理模式介绍"><a href="#代理模式介绍" class="headerlink" title="代理模式介绍"></a>代理模式介绍</h2><p><strong>代理模式定义</strong></p><p><strong>Proxy Pattern</strong>: Provide a surrogate or placeholder for another object to control access to it.（为其他对象提供一种代理以控制对这个对象的访问。）</p><img src="https://gitee.com/dongzl/article-images/raw/master/2020/05-Design-Pattern-Proxy/Design-Pattern-Proxy_01.png" width="600px"><ul><li>Subject：定义 RealSubject 对外的接口，且这些接口必须被 Proxy 实现，这样外部调用 proxy 的接口最终都被转化为对 RealSubject 的调用。</li><li>RealSubject：真正的目标对象（被代理对象）。</li><li>Proxy：目标对象的代理，负责控制和管理目标对象，并间接地传递外部对目标对象的访问。</li></ul><h2 id="静态代理实现"><a href="#静态代理实现" class="headerlink" title="静态代理实现"></a>静态代理实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticProxy</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> ProxyExecute(<span class="keyword">new</span> RemoteExecute()).execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Executable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RemoteExecute</span> <span class="keyword">implements</span> <span class="title">Executable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">        System.out.println(<span class="string">"Remote execute ......"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProxyExecute</span> <span class="keyword">implements</span> <span class="title">Executable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Executable executable;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxyExecute</span><span class="params">(Executable executable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.executable = executable;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        executable.execute();</span><br><span class="line">        System.out.println(<span class="string">"Time: "</span> + (System.currentTimeMillis() - start));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码就是静态代理个一个简单实现，由于在静态代理模式中 Proxy 只能代理固定实现某个接口的被代理对象，所以并不十分灵活，所以在这个静态代理的基础上就衍生出了动态代理（Dynamic Proxy）。</p><h2 id="JDK-动态代理实现"><a href="#JDK-动态代理实现" class="headerlink" title="JDK 动态代理实现"></a>JDK 动态代理实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDKDynamicProxy</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Executable remote = <span class="keyword">new</span> RemoteExecute();</span><br><span class="line">        </span><br><span class="line">        System.getProperties().setProperty(<span class="string">"sun.misc.ProxyGenerator.saveGeneratedFiles"</span>, <span class="string">"true"</span>);</span><br><span class="line">        </span><br><span class="line">        Executable executable = (Executable)Proxy.newProxyInstance(JDKDynamicProxy.class.getClassLoader(), <span class="keyword">new</span> Class[]&#123;Executable.class&#125;, <span class="keyword">new</span> ExecuteInvocationHandler(remote));</span><br><span class="line">        executable.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExecuteInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Executable executable;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExecuteInvocationHandler</span><span class="params">(Executable executable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.executable = executable;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        Object result = method.invoke(executable, args);</span><br><span class="line">        System.out.println(<span class="string">"Time: "</span> + (System.currentTimeMillis() - start));</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Executable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RemoteExecute</span> <span class="keyword">implements</span> <span class="title">Executable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">        System.out.println(<span class="string">"Remote execute ......"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JDK 的动态代理是通过 Proxy 类来实现的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</span> </span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> IllegalArgumentException</span></span><br></pre></td></tr></table></figure><p>newProxyInstance 方法需要三个参数，</p><ul><li>loader 是生成代理类的类加载器；</li><li>interfaces 指定被代理类实现的接口（所以很多资料都说 JDK 的动态代理需要被代理类必须实现某一个接口，其实证据就在这里）；</li><li>h 调用处理器（实现 InvocationHandler 接口，InvocationHandler 接口中定义了 invoke 方法）。</li></ul><p>通过设置 JDK 属性，我们可以将动态代理过程中生成的代理类保存下来，观察 JDK 动态生成的代理类的一些实现细节：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.getProperties().setProperty(<span class="string">"sun.misc.ProxyGenerator.saveGeneratedFiles"</span>, <span class="string">"true"</span>);</span><br></pre></td></tr></table></figure><p>PS. <strong>这个属性值在不同 JDK 版本名称不同，JDK8 中为 <code>sun.misc.ProxyGenerator.saveGeneratedFiles</code>，JDK12 中是 <code>jdk.proxy.ProxyGenerator.saveGeneratedFiles</code>，没有深究是从 JDK 哪个版本改的这个属性名。</strong></p><p>通过设置这个参数，在程序运行后会生成一个 <code>$Proxy0.class</code> 文件，我们通过工具反编译文件后内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Source code recreated from a .class file by IntelliJ IDEA</span></span><br><span class="line"><span class="comment">// (powered by Fernflower decompiler)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> design.pattern.proxy.v2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.UndeclaredThrowableException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> $<span class="title">Proxy0</span> <span class="keyword">extends</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Executable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> $Proxy0(InvocationHandler var1) <span class="keyword">throws</span>  &#123;</span><br><span class="line">        <span class="keyword">super</span>(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略 equals 方法</span></span><br><span class="line">    <span class="comment">// 省略 toString 方法</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m3, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略 hashCode 方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            m1 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"equals"</span>, Class.forName(<span class="string">"java.lang.Object"</span>));</span><br><span class="line">            m2 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"toString"</span>);</span><br><span class="line">            m3 = Class.forName(<span class="string">"design.pattern.proxy.v2.Executable"</span>).getMethod(<span class="string">"execute"</span>);</span><br><span class="line">            m0 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"hashCode"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodError(var2.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoClassDefFoundError(var3.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过类的结构我们可以知道动态生成代理类 <code>$Proxy0</code> 继承自 <code>Proxy</code> 类，同时实现了我们自定义的 <code>Executable</code> 接口，并重写了其中的 <code>execute</code> 方法，<code>execute</code> 方法实现很简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m3, (Object[])<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p>调用父类中 <code>h</code> 变量的 <code>invoke</code> 方法，其中 <code>h</code> 变量就是我们实现的 <code>InvocationHandler</code> 接口的 <code>ExecuteInvocationHandler</code> 类变量。</p><p>JDK 动态代理实现流程图：</p><img src="https://gitee.com/dongzl/article-images/raw/master/2020/05-Design-Pattern-Proxy/Design-Pattern-Proxy_02.png"><h2 id="cglib-动态代理"><a href="#cglib-动态代理" class="headerlink" title="cglib 动态代理"></a>cglib 动态代理</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CGlibDynamicProxy</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setSuperclass(RemoteExecute.class);</span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> ExecuteMethodInterceptor());</span><br><span class="line">        RemoteExecute execute = (RemoteExecute)enhancer.create();</span><br><span class="line">        execute.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExecuteMethodInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(o.getClass().getSuperclass().getName());</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        Object result = methodProxy.invokeSuper(o, objects);</span><br><span class="line">        System.out.println(<span class="string">"Time: "</span> + (System.currentTimeMillis() - start));</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RemoteExecute</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">        System.out.println(<span class="string">"Remote execute ......"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>cglib 实现的动态代理功能使用的是 <code>Enhancer</code> 类，其中需要定义 <code>MethodInterceptor</code> 接口实现类，<code>MethodInterceptor</code> 接口与 JDK 动态代理中的 InvocationHandler 接口作用非常类型，内部通过反射调用被代理类的方法。</p><p><code>cglib</code> 动态代理一个比较的的优势是被代理类（RemoteExecute）不需要实现任何接口，这个就是很多资料上说的 <code>cglib</code> 动态代理与 <code>JDK</code> 动态代理的一个很大区别就是：<strong>cglib 动态代理不需要被代理类实现任何接口，而 JDK 动态代理需要被代理类必须要实现一个接口。</strong> 由于 <code>cglib</code> 动态代理的这个优势，所以 <code>Spring AOP</code> 的动态代理就是通过 <code>cglib</code> 来实现的。</p><h2 id="代理模式使用总结"><a href="#代理模式使用总结" class="headerlink" title="代理模式使用总结"></a>代理模式使用总结</h2><p>代理模式的目的：</p><ul><li>为外部调用者提供一个访问服务提供者的代理对象。</li></ul><p>代理模式的动机：</p><ul><li>限制对目标对象的直接访问，降低耦合度。</li></ul><p>代理模式优点：</p><ul><li>低耦合（协调调用者和被调用者）</li><li>易扩展</li><li>灵活度高</li></ul><p>代理模式缺点：</p><ul><li>间接访问可能会延迟请求相应</li><li>增加工作量</li></ul><p>代理模式分类：</p><ul><li>静态代理</li><li>动态代理</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><p><a href="https://www.cnblogs.com/yssjun/archive/2019/05/31/10889022.html" target="_blank" rel="noopener">设计模式之代理模式（proxy pattern）</a></p></li><li><p><a href="https://www.cnblogs.com/liuyun1995/p/8144628.html" target="_blank" rel="noopener">JDK动态代理</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景介绍&quot;&gt;&lt;a href=&quot;#背景介绍&quot; class=&quot;headerlink&quot; title=&quot;背景介绍&quot;&gt;&lt;/a&gt;背景介绍&lt;/h2&gt;&lt;p&gt;最近在学习 &lt;a href=&quot;https://time.geekbang.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;极客时间&lt;/a&gt; 的 &lt;a href=&quot;https://time.geekbang.org/column/intro/250&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;设计模式之美&lt;/a&gt; 课程，这一篇算是自己的学习总结。代理模式（Proxy）在很多非常优秀框架中都有他的身影，比如，大名鼎鼎的 Spring AOP 就是使用动态代理（Dynamic Proxy）模式；还有就是在一些微服务框架中，如果调用一个远程服务接口，RPC 框架一般都会使用代理模式。&lt;/p&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="https://dongzl.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://dongzl.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="代理模式" scheme="https://dongzl.github.io/tags/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Proxy" scheme="https://dongzl.github.io/tags/Proxy/"/>
    
  </entry>
  
  <entry>
    <title>极客时间 《深入浅出计算机组成原理》 学习笔记</title>
    <link href="https://dongzl.github.io/2020/02/21/04-On-The-Principle-Of-Computer-Composition/"/>
    <id>https://dongzl.github.io/2020/02/21/04-On-The-Principle-Of-Computer-Composition/</id>
    <published>2020-02-21T12:54:33.000Z</published>
    <updated>2020-03-10T02:25:46.323Z</updated>
    
    <content type="html"><![CDATA[<p>本文是 <a href="https://time.geekbang.org/" target="_blank" rel="noopener">极客时间</a> 上 <a href="https://time.geekbang.org/column/intro/170" target="_blank" rel="noopener">深入浅出计算机组成原理</a> 课程的学习笔记内容。</p><a id="more"></a><h2 id="入门篇"><a href="#入门篇" class="headerlink" title="入门篇"></a>入门篇</h2><h3 id><a href="#" class="headerlink" title></a></h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是 &lt;a href=&quot;https://time.geekbang.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;极客时间&lt;/a&gt; 上 &lt;a href=&quot;https://time.geekbang.org/column/intro/170&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;深入浅出计算机组成原理&lt;/a&gt; 课程的学习笔记内容。&lt;/p&gt;
    
    </summary>
    
    
      <category term="其他" scheme="https://dongzl.github.io/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="计算机组成原理" scheme="https://dongzl.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>计算机中常用数学公式汇总</title>
    <link href="https://dongzl.github.io/2020/02/17/03-The-Mathematical-Formula-Summary/"/>
    <id>https://dongzl.github.io/2020/02/17/03-The-Mathematical-Formula-Summary/</id>
    <published>2020-02-17T14:04:54.000Z</published>
    <updated>2020-03-09T14:20:17.388Z</updated>
    
    <content type="html"><![CDATA[<ul><li>斐波那契数列通向公式：</li></ul><p>$$a_n=\frac{1}{\sqrt{5}} \begin{bmatrix} \begin{pmatrix} \frac{1 + \sqrt{5}}{2} \end{pmatrix}^n - \begin{pmatrix} \frac{1 - \sqrt{5}}{2} \end{pmatrix}^n\end{bmatrix}$$</p><ul><li>斐波那契数列矩阵方程：</li></ul><p>$$\begin{bmatrix} f(n)\\ f(n - 1) \end{bmatrix} = \begin{bmatrix} 1&amp;1\\ 1&amp;0 \end{bmatrix} \begin{bmatrix} f(n - 1)\\ f(n - 2) \end{bmatrix} = \begin{bmatrix} 1&amp;1\\ 1&amp;0 \end{bmatrix}^{n + 1} \begin{bmatrix} f(1)\\ f(0) \end{bmatrix}$$</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;斐波那契数列通向公式：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$$a_n=\frac{1}{\sqrt{5}} \begin{bmatrix} \begin{pmatrix} \frac{1 + \sqrt{5}}{2} \end{pmatrix}^n - \begin{
      
    
    </summary>
    
    
      <category term="其他" scheme="https://dongzl.github.io/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="数学公式" scheme="https://dongzl.github.io/tags/%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>各种算法的复杂度</title>
    <link href="https://dongzl.github.io/2020/02/13/02-Know-Thy-Complexities/"/>
    <id>https://dongzl.github.io/2020/02/13/02-Know-Thy-Complexities/</id>
    <published>2020-02-13T02:17:58.000Z</published>
    <updated>2020-03-09T14:18:35.599Z</updated>
    
    <content type="html"><![CDATA[<p>你好，这个页面涵盖了计算机科学中常用算法的时间和空间复杂度。在准备过去的技术采访中，我自己花了几个小时爬取网页，把搜索、排序算法中最好情况、最坏情况以及平均情况时间复杂度的内容汇总到一起，这样我就不会在被问及这些问题时被难住了。在过去的几年里，我采访了硅谷的几家初创公司，以及一些大公司，例如谷歌、Facebook、雅虎、LinkedIn和Uber，每次我准备采访时，我都会想“为什么没有人创建一个好的大O备忘单呢？”。所以，为了给你们这些好人节省很多时间，我创造了一个。享受吧！</p><a id="more"></a><blockquote><p>Hi there!  This webpage covers the space and time Big-O complexities of common algorithms used in Computer Science.  When preparing for technical interviews in the past, I found myself spending hours crawling the internet putting together the best, average, and worst case complexities for search and sorting algorithms so that I wouldn’t be stumped when asked about them.  Over the last few years, I’ve interviewed at several Silicon Valley startups, and also some bigger companies, like Google, Facebook, Yahoo, LinkedIn, and Uber, and each time that I prepared for an interview, I thought to myself “Why hasn’t someone created a nice Big-O cheat sheet?”.  So, to save all of you fine folks a ton of time, I went ahead and created one.  Enjoy!</p></blockquote><h2 id="大O复杂度统计图"><a href="#大O复杂度统计图" class="headerlink" title="大O复杂度统计图"></a>大O复杂度统计图</h2><p>Big-O Complexity Chart</p><img src="https://gitee.com/dongzl/article-images/raw/master/2020/02-Know-Thy-Complexities/Big-O-Complexity-Chart.png" width="1000px"><h2 id="常用数据结构操作"><a href="#常用数据结构操作" class="headerlink" title="常用数据结构操作"></a>常用数据结构操作</h2><p>Common Data Structure Operations</p><img src="https://gitee.com/dongzl/article-images/raw/master/2020/02-Know-Thy-Complexities/Common-Data-Structure-Operations.png" width="1000px"><h2 id="线性排序算法"><a href="#线性排序算法" class="headerlink" title="线性排序算法"></a>线性排序算法</h2><p>Array Sorting Algorithms</p><img src="https://gitee.com/dongzl/article-images/raw/master/2020/02-Know-Thy-Complexities/Array-Sorting-Algorithms.png" width="1000px"><h2 id="官方网站-Big-O-统计数据图"><a href="#官方网站-Big-O-统计数据图" class="headerlink" title="官方网站 Big-O 统计数据图"></a>官方网站 Big-O 统计数据图</h2><p>Get the Official Big-O Cheat Sheet Poster</p><img src="https://gitee.com/dongzl/article-images/raw/master/2020/02-Know-Thy-Complexities/Big-O-Cheat-Sheet-Poster.png" width="1000px"><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.bigocheatsheet.com/" target="_blank" rel="noopener">Know Thy Complexities!</a></li><li><a href="https://blog.csdn.net/herorenme/article/details/8919095" target="_blank" rel="noopener">Know Thy Complexities! (各种算法的复杂度)</a></li><li><a href="https://www.cnblogs.com/datascientist/p/3557401.html" target="_blank" rel="noopener">Know Thy Complexities!</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;你好，这个页面涵盖了计算机科学中常用算法的时间和空间复杂度。在准备过去的技术采访中，我自己花了几个小时爬取网页，把搜索、排序算法中最好情况、最坏情况以及平均情况时间复杂度的内容汇总到一起，这样我就不会在被问及这些问题时被难住了。在过去的几年里，我采访了硅谷的几家初创公司，以及一些大公司，例如谷歌、Facebook、雅虎、LinkedIn和Uber，每次我准备采访时，我都会想“为什么没有人创建一个好的大O备忘单呢？”。所以，为了给你们这些好人节省很多时间，我创造了一个。享受吧！&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://dongzl.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Big-O" scheme="https://dongzl.github.io/tags/Big-O/"/>
    
  </entry>
  
  <entry>
    <title>Google Guava EventBus 在 ShardingShere 中的应用</title>
    <link href="https://dongzl.github.io/2020/02/01/01-Google-Guava-EventBus-ShardingSphere/"/>
    <id>https://dongzl.github.io/2020/02/01/01-Google-Guava-EventBus-ShardingSphere/</id>
    <published>2020-02-01T10:02:52.000Z</published>
    <updated>2020-03-09T13:37:28.929Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Guava-EventBus-介绍"><a href="#Guava-EventBus-介绍" class="headerlink" title="Guava EventBus 介绍"></a>Guava EventBus 介绍</h2><p>Guava 的 EventBus 可以简化生产/消费模型。EventBus 通过非常简单的方式，实现了观察者模式中的监听注册，事件分发。</p><blockquote><p>Dispatches events to listeners, and provides ways for listeners to register themselves. The EventBus allows publish-subscribe-style communication between components without requiring the components to explicitly register with one another (and thus be aware of each other). It is designed exclusively to replace traditional Java in-processs event distribution using explicit registration. It is not a general-purpose publish-subscribe system, nor is it intended for interprocess communication.</p></blockquote><blockquote><p>将事件分发给监听器，同时提供监听器注册监听的方式。EventBus 支持组件之间的发布-订阅式通信，而不需要组件显式地彼此注册（从而彼此感知对方存在）。它是专门为使用显式注册来替代传统的 Java 进程内事件分发而设计的。它不是一个通用的发布订阅系统，也不支持进程间通信。</p></blockquote><a id="more"></a><img src="https://gitee.com/dongzl/article-images/raw/master/2020/01-Google-Guava-EventBus-ShardingSphere/Google-Guava-EventBus.png" width="600px"><p>通过阅读 Guava 的 EventBus 源码，EventBus 支持的操作如下：</p><ul><li>Receiving Events（接收事件）</li><li>Posting Events （发布事件）</li><li>Subscriber Methods （订阅事件）</li><li>Dead Events （没有订阅者的事件）</li></ul><h2 id="EventBus-发布-订阅使用"><a href="#EventBus-发布-订阅使用" class="headerlink" title="EventBus 发布/订阅使用"></a>EventBus 发布/订阅使用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 订阅者</span></span><br><span class="line"><span class="keyword">import</span> com.google.common.eventbus.Subscribe;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EventHandler</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Subscribe</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mq</span><span class="params">(MQEvent mq)</span> </span>&#123;</span><br><span class="line">        System.out.println(mq.getClass().getCanonicalName() + <span class="string">" work"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 订阅事件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MQEvent</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试类</span></span><br><span class="line"><span class="keyword">import</span> com.google.common.eventbus.EventBus;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EventTest</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//初始化消息总线</span></span><br><span class="line">        EventBus eventBus = <span class="keyword">new</span> EventBus();</span><br><span class="line">        <span class="comment">// 注册订阅者</span></span><br><span class="line">        eventBus.register(<span class="keyword">new</span> EventHandler());</span><br><span class="line">        <span class="comment">//MqEvent推送给订阅者</span></span><br><span class="line">        MQEvent mqEvent = <span class="keyword">new</span> MQEvent();</span><br><span class="line">        <span class="comment">//发布消息</span></span><br><span class="line">        eventBus.post(mqEvent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="EventBus-在-ShardingSphere-中的实际应用"><a href="#EventBus-在-ShardingSphere-中的实际应用" class="headerlink" title="EventBus 在 ShardingSphere 中的实际应用"></a>EventBus 在 ShardingSphere 中的实际应用</h2><p>在 <a href="https://github.com/apache/incubator-shardingsphere" target="_blank" rel="noopener">ShardingSphere</a> 项目中需要将数据库配置信息存储到统一配置中心（例如：ZooKeeper、nacos、Apollo），对于统一的配置中心可以通过监听机制，监听配置中心配置信息的变化，将配置中心变更的信息推送给 ShardingSphere，对于这种情况就是一个典型的发布-订阅模型，在 ShardingSphere 就是通过 EventBus 来完成这个功能的，我们来看一下 ShardingSphere 的代码实现：</p><ul><li><p>系统启动时，通过 ShardingOrchestrationFacade.init() 方法注册监听内容，ConfigurationChangedListenerManager.initListeners() 方法用于启动对于系统配置的监听。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigurationChangedListenerManager</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    ... ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Initialize all configuration changed listeners.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initListeners</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        schemaChangedListener.watch(ChangedType.UPDATED, ChangedType.DELETED);</span><br><span class="line">        propertiesChangedListener.watch(ChangedType.UPDATED);</span><br><span class="line">        authenticationChangedListener.watch(ChangedType.UPDATED);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>例如在 PropertiesChangedListener.watch() 方法中，通过调用父类的 PostShardingConfigCenterEventListener.watch(final ChangedType… watchedChangedTypes) 方法完成监听，在 PostShardingConfigCenterEventListener 方法中使用了 EventBus，注册监听配置中心中某个 Key 的变化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">watch</span><span class="params">(<span class="keyword">final</span> String watchKey, <span class="keyword">final</span> Collection&lt;ChangedType&gt; watchedChangedTypeList)</span> </span>&#123;</span><br><span class="line">    configCenter.watch(watchKey, <span class="keyword">new</span> DataChangedEventListener() &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onChange</span><span class="params">(<span class="keyword">final</span> DataChangedEvent dataChangedEvent)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (watchedChangedTypeList.contains(dataChangedEvent.getChangedType())) &#123;</span><br><span class="line">                eventBus.post(createShardingOrchestrationEvent(dataChangedEvent));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>对于配置中心监听配置信息的变化都是由不同的框架（ZooKeeper、nacos、Apollo）来完成的，下面以 nacos 为例，看一下监听实现，nacos 中配置信息发生变化后对通过 receiveConfigInfo 方法推送给 ShardingShpere，ShardingShpere 接收到变更后通过 EventBus 的 post 方法发送变更事件，订阅事件的类接收到变更后会进行相应逻辑处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">watch</span><span class="params">(<span class="keyword">final</span> String key, <span class="keyword">final</span> DataChangedEventListener dataChangedEventListener)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String dataId = key.replace(<span class="string">"/"</span>, <span class="string">"."</span>);</span><br><span class="line">        String group = properties.getProperty(<span class="string">"group"</span>, <span class="string">"SHARDING_SPHERE_DEFAULT_GROUP"</span>);</span><br><span class="line">        configService.addListener(dataId, group, <span class="keyword">new</span> Listener() &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Executor <span class="title">getExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveConfigInfo</span><span class="params">(<span class="keyword">final</span> String configInfo)</span> </span>&#123;</span><br><span class="line">                dataChangedEventListener.onChange(<span class="keyword">new</span> DataChangedEvent(key, configInfo, DataChangedEvent.ChangedType.UPDATED));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> NacosException ex) &#123;</span><br><span class="line">        log.debug(<span class="string">"Nacos watch key exception for: &#123;&#125;"</span>, ex.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>ShardingSphere 中事件订阅，例如，在 ShardingProxyContext 需要监听配置信息变化，在构造方法中将当前实例对象（this）注册到 EventBus，通过 @Subscribe 注解监听配置变更，监听到配置变更的数据后发送给 ShardingShere，处理内部相关逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ShardingProxyContext</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ShardingProxyContext INSTANCE = <span class="keyword">new</span> ShardingProxyContext();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> ShardingProperties shardingProperties = <span class="keyword">new</span> ShardingProperties(<span class="keyword">new</span> Properties());</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ShardingProxyContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ShardingOrchestrationEventBus.getInstance().register(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ShardingProxyContext <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Renew properties.</span></span><br><span class="line"><span class="comment">     * 监听事件的变化</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> event properties changed event</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Subscribe</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">renew</span><span class="params">(<span class="keyword">final</span> PropertiesChangedEvent event)</span> </span>&#123;</span><br><span class="line">        ConfigurationLogger.log(event.getProps());</span><br><span class="line">        shardingProperties = <span class="keyword">new</span> ShardingProperties(event.getProps());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="DeadEvent-使用场景"><a href="#DeadEvent-使用场景" class="headerlink" title="DeadEvent 使用场景"></a>DeadEvent 使用场景</h2><blockquote><p>Wraps an event that was posted, but which had no subscribers and thus could not be delivered.Registering a DeadEvent subscriber is useful for debugging or logging, as it can detect misconfigurations in a system’s event distribution.</p></blockquote><blockquote><p>包装了一个被发送的事件，但是这个事件却没有任何订阅者，因此这个事件可能不会被实际发送。注册一个 DeadEvent 事件订阅器对于调试或日志记录很有用，因为它可以检测事件分布系统中的错误配置。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义事件，没有订阅者</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MQEvent</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DeadEvent 处理器</span></span><br><span class="line"><span class="keyword">import</span> com.google.common.eventbus.DeadEvent;</span><br><span class="line"><span class="keyword">import</span> com.google.common.eventbus.Subscribe;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadEventHandler</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 没有订阅者时被触发</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Subscribe</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deadEvent</span><span class="params">(DeadEvent event)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Receive a DeadEvent"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试类</span></span><br><span class="line"><span class="keyword">import</span> com.google.common.eventbus.EventBus;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadEventTest</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化消息总线</span></span><br><span class="line">        EventBus eventBus = <span class="keyword">new</span> EventBus();</span><br><span class="line">        <span class="comment">// 注册 DeadEvent 订阅者</span></span><br><span class="line">        eventBus.register(<span class="keyword">new</span> DeadEventHandler());</span><br><span class="line">        <span class="comment">// MqEvent推送给订阅者</span></span><br><span class="line">        MQEvent mqEvent = <span class="keyword">new</span> MQEvent();</span><br><span class="line">        <span class="comment">// 发布消息，没有订阅者</span></span><br><span class="line">        eventBus.post(mqEvent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其他类使用"><a href="#其他类使用" class="headerlink" title="其他类使用"></a>其他类使用</h2><ul><li><p>AsyncEventBus：异步事件总线，当处理耗时的处理时很有用，我们要依赖Executors来实现异步事件总线。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AsyncEventBus asyncEventBus = <span class="keyword">new</span> AsyncEventBus(executorService);</span><br></pre></td></tr></table></figure></li><li><p>AllowConcurrentEvents：在设置观察者时，需要使用注解类@Subscribe来标识一个订阅者，但在注解中还要一个注解@AllowConcurrentEvents，这个注解是用来标识当前订阅者是线程安全的。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Creates a &#123;<span class="doctag">@code</span> Subscriber&#125; for &#123;<span class="doctag">@code</span> method&#125; on &#123;<span class="doctag">@code</span> listener&#125;. </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Subscriber <span class="title">create</span><span class="params">(EventBus bus, Object listener, Method method)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> isDeclaredThreadSafe(method)</span><br><span class="line">        ? <span class="keyword">new</span> Subscriber(bus, listener, method)</span><br><span class="line">        : <span class="keyword">new</span> SynchronizedSubscriber(bus, listener, method);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://greengerong.github.io/blog/2014/11/27/guava-eventbus/" target="_blank" rel="noopener">Guava - EventBus(事件总线)</a></li><li><a href="https://www.jianshu.com/p/a950d7c294e5" target="_blank" rel="noopener">Guava eventBus 关于@AllowConcurrentEvents 纪实</a></li><li><a href="https://www.iteye.com/blog/uule-2096279" target="_blank" rel="noopener">用guava实现简单的事件驱动</a></li><li><a href="https://www.jianshu.com/p/703fa6cf6e44" target="_blank" rel="noopener">Guava EventBus</a></li><li><a href="https://www.yeetrack.com/?p=1177" target="_blank" rel="noopener">走近Guava(六): 事件总线EventBus</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Guava-EventBus-介绍&quot;&gt;&lt;a href=&quot;#Guava-EventBus-介绍&quot; class=&quot;headerlink&quot; title=&quot;Guava EventBus 介绍&quot;&gt;&lt;/a&gt;Guava EventBus 介绍&lt;/h2&gt;&lt;p&gt;Guava 的 EventBus 可以简化生产/消费模型。EventBus 通过非常简单的方式，实现了观察者模式中的监听注册，事件分发。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Dispatches events to listeners, and provides ways for listeners to register themselves. The EventBus allows publish-subscribe-style communication between components without requiring the components to explicitly register with one another (and thus be aware of each other). It is designed exclusively to replace traditional Java in-processs event distribution using explicit registration. It is not a general-purpose publish-subscribe system, nor is it intended for interprocess communication.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;将事件分发给监听器，同时提供监听器注册监听的方式。EventBus 支持组件之间的发布-订阅式通信，而不需要组件显式地彼此注册（从而彼此感知对方存在）。它是专门为使用显式注册来替代传统的 Java 进程内事件分发而设计的。它不是一个通用的发布订阅系统，也不支持进程间通信。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="web开发" scheme="https://dongzl.github.io/categories/web%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Google" scheme="https://dongzl.github.io/tags/Google/"/>
    
      <category term="Guava" scheme="https://dongzl.github.io/tags/Guava/"/>
    
      <category term="EventBus" scheme="https://dongzl.github.io/tags/EventBus/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://dongzl.github.io/2019/12/26/hello-world/"/>
    <id>https://dongzl.github.io/2019/12/26/hello-world/</id>
    <published>2019-12-26T13:35:58.000Z</published>
    <updated>2020-03-09T13:29:46.081Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;Quick-Start&quot;&gt;&lt;a href=&quot;#Quick-Start&quot; class=&quot;headerlink&quot; title=&quot;Quick Start&quot;&gt;&lt;/a&gt;Quick Start&lt;/h2&gt;&lt;h3 id=&quot;Create-a-new-post&quot;&gt;&lt;a href=&quot;#Create-a-new-post&quot; class=&quot;headerlink&quot; title=&quot;Create a new post&quot;&gt;&lt;/a&gt;Create a new post&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo new &lt;span class=&quot;string&quot;&gt;&quot;My New Post&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="其他" scheme="https://dongzl.github.io/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="hexo" scheme="https://dongzl.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>极客时间 《设计模式之美》 学习笔记</title>
    <link href="https://dongzl.github.io/2019/12/26/08-The-Beauty-Of-Design-Pattern/"/>
    <id>https://dongzl.github.io/2019/12/26/08-The-Beauty-Of-Design-Pattern/</id>
    <published>2019-12-26T13:35:58.000Z</published>
    <updated>2020-03-09T13:31:01.589Z</updated>
    
    <content type="html"><![CDATA[<p>本文是 <a href="https://time.geekbang.org/" target="_blank" rel="noopener">极客时间</a> 上 <a href="https://time.geekbang.org/column/intro/100039001" target="_blank" rel="noopener">设计模式之美</a> 课程的学习笔记内容。</p><a id="more"></a><h2 id="设计原则与思想：设计原则"><a href="#设计原则与思想：设计原则" class="headerlink" title="设计原则与思想：设计原则"></a>设计原则与思想：设计原则</h2><h3 id="15-理论一：对于单一职责原则，如何判定某个类的职责是否够“单一”？"><a href="#15-理论一：对于单一职责原则，如何判定某个类的职责是否够“单一”？" class="headerlink" title="15 | 理论一：对于单一职责原则，如何判定某个类的职责是否够“单一”？"></a>15 | 理论一：对于单一职责原则，如何判定某个类的职责是否够“单一”？</h3><p>单一职责原则：Single Responsibility Principle，缩写为 SRP。</p><p>我们可以现写一个粗粒度的类，满足业务需求。随着业务的发展，如果粗粒度的类越来越大，代码越来越多，这个时候，我们就可以将这个粗粒度的类，拆分成几个更细度的类。</p><p><strong>如何理解单一职责（SRP）</strong></p><p>一个类只负责完成一个职责或者功能。不要设计大而全的类，要设计粒度小、功能单一的类。单一职责原则是为了实现代码高内聚、低耦合，提高代码的复用性、可读性、可维护性。</p><p><strong>如何判断类的职责是否足够单一</strong></p><ul><li>类中的代码行数、函数或者属性过多；</li><li>类依赖的其他类过多，或者依赖类的其他类过多；</li><li>私有方法过多；</li><li>比较难给类起一个合适的名字；</li><li>类中大量的方法都是集中操作类中的某几个属性。</li></ul><hr><h3 id="16-理论二：如何做到“对扩展开放、修改关闭”？扩展和修改各指什么？"><a href="#16-理论二：如何做到“对扩展开放、修改关闭”？扩展和修改各指什么？" class="headerlink" title="16 | 理论二：如何做到“对扩展开放、修改关闭”？扩展和修改各指什么？"></a>16 | 理论二：如何做到“对扩展开放、修改关闭”？扩展和修改各指什么？</h3><p>开闭原则：Open Closed Principle，简写为 OCP。</p><blockquote><p>Software entities (modules, classes, functions, etc.) should be open for extension , but closed for modification。</p></blockquote><p>我们把它翻译成中文就是：软件实体（模块、类、方法等）应该“对扩展开放、对修改关闭”。</p><hr><h3 id="17-理论三：里式替换（LSP）跟多态有何区别？哪些代码违背了LSP？"><a href="#17-理论三：里式替换（LSP）跟多态有何区别？哪些代码违背了LSP？" class="headerlink" title="17 | 理论三：里式替换（LSP）跟多态有何区别？哪些代码违背了LSP？"></a>17 | 理论三：里式替换（LSP）跟多态有何区别？哪些代码违背了LSP？</h3><p>里式替换原则：Liskov Substitution Principle，缩写为 LSP。</p><blockquote><p>Functions that use pointers of references to base classes must be able to use objects of derived classes without knowing it。</p></blockquote><p>子类对象（object of subtype/derived class）能够替换程序（program）中父类对象（object of base/parent class）出现的任何地方，并且保证原来程序的逻辑行为（behavior）不变及正确性不被破坏。</p><p><strong>违反里式替换原则的情况：</strong></p><ul><li>子类违背父类声明要实现的功能；</li><li>子类违背父类对输入、输出、异常的约定；</li><li>子类违背父类注释中所罗列的任何特殊说明。</li></ul><p><strong>多态 &amp; 里式替换原则</strong>：</p><p>多态是面向对象编程的一大特性，也是面向对象编程语言的一种语法。它是一种代码实现的思路。而里式替换是一种设计原则，用来指导继承关系中子类该如何设计，子类的设计要保证在替换父类的时候，不改变原有程序的逻辑及不破坏原有程序的正确性。</p><hr><h3 id="18-理论四：接口隔离原则有哪三种应用？原则中的“接口”该如何理解？"><a href="#18-理论四：接口隔离原则有哪三种应用？原则中的“接口”该如何理解？" class="headerlink" title="18 | 理论四：接口隔离原则有哪三种应用？原则中的“接口”该如何理解？"></a>18 | 理论四：接口隔离原则有哪三种应用？原则中的“接口”该如何理解？</h3><p>接口隔离原则：Interface Segregation Principle”，缩写为 ISP。</p><blockquote><p>Clients should not be forced to depend upon interfaces that they do not use。</p></blockquote><p>如果把“接口”理解为一组接口集合，可以是某个微服务的接口，也可以是某个类库的接口等。如果部分接口只被部分调用者使用，我们就需要将这部分接口隔离出来，单独给这部分调用者使用，而不强迫其他调用者也依赖这部分不会被用到的接口。</p><p>如果把“接口”理解为单个 API 接口或函数，部分调用者只需要函数中的部分功能，那我们就需要把函数拆分成粒度更细的多个函数，让调用者只依赖它需要的那个细粒度函数。</p><p>如果把“接口”理解为 OOP 中的接口，也可以理解为面向对象编程语言中的接口语法。那接口的设计要尽量单一，不要让接口的实现类和调用者，依赖不需要的接口函数。</p><hr><h3 id="19-理论五：控制反转、依赖反转、依赖注入，这三者有何区别和联系？"><a href="#19-理论五：控制反转、依赖反转、依赖注入，这三者有何区别和联系？" class="headerlink" title="19 | 理论五：控制反转、依赖反转、依赖注入，这三者有何区别和联系？"></a>19 | 理论五：控制反转、依赖反转、依赖注入，这三者有何区别和联系？</h3><p>依赖倒置原则：Dependency Inversion Principle，缩写为 DIP。</p><blockquote><p>High-level modules shouldn’t depend on low-level modules. Both modules should depend on abstractions. In addition, abstractions shouldn’t depend on details. Details depend on abstractions.</p></blockquote><p>高层模块（high-level modules）不要依赖低层模块（low-level）。高层模块和低层模块应该通过抽象（abstractions）来互相依赖。除此之外，抽象（abstractions）不要依赖具体实现细节（details），具体实现细节（details）依赖抽象（abstractions）。</p><hr><h3 id="20-理论六：我为何说KISS、YAGNI原则看似简单，却经常被用错？"><a href="#20-理论六：我为何说KISS、YAGNI原则看似简单，却经常被用错？" class="headerlink" title="20 | 理论六：我为何说KISS、YAGNI原则看似简单，却经常被用错？"></a>20 | 理论六：我为何说KISS、YAGNI原则看似简单，却经常被用错？</h3><blockquote><p>Keep It Simple and Stupid. 尽量保持简单。</p></blockquote><p><strong>如何写出满足 KISS 原则的代码？</strong></p><ul><li>不要使用同事可能不懂的技术来实现代码。</li><li>不要重复造轮子，要善于使用已经有的工具类库。</li><li>不要过度优化。不要过度使用一些奇技淫巧来优化代码，牺牲代码的可读性。</li></ul><p><strong>YAGNI 原则</strong>（不要做过度设计）</p><blockquote><p>YAGNI 原则的英文全称是：You Ain’t Gonna Need It。</p></blockquote><hr><h3 id="21-理论七：重复的代码就一定违背DRY吗？如何提高代码的复用性？"><a href="#21-理论七：重复的代码就一定违背DRY吗？如何提高代码的复用性？" class="headerlink" title="21 | 理论七：重复的代码就一定违背DRY吗？如何提高代码的复用性？"></a>21 | 理论七：重复的代码就一定违背DRY吗？如何提高代码的复用性？</h3><p><strong>DRY 原则（Don’t Repeat Yourself）</strong></p><ul><li>实现逻辑重复（不违反 DRY 原则）</li><li>功能语义逻辑（违反 DRY 原则）</li><li>代码执行重复（违反 DRY 原则）</li></ul><p><strong>提高代码可复用性的方法</strong></p><ul><li>减少代码耦合</li><li>满足单一职责原则</li><li>模块化</li><li>业务与非业务逻辑分离</li><li>通用代码下沉</li><li>继承、多态、抽象、封装</li><li>应用模板等设计模式</li></ul><hr><h3 id="22-理论八：如何用迪米特法则（LOD）实现“高内聚、松耦合”？"><a href="#22-理论八：如何用迪米特法则（LOD）实现“高内聚、松耦合”？" class="headerlink" title="22 | 理论八：如何用迪米特法则（LOD）实现“高内聚、松耦合”？"></a>22 | 理论八：如何用迪米特法则（LOD）实现“高内聚、松耦合”？</h3><p>迪米特法则：Law of Demeter，缩写是 LOD。</p><p>最小知识原则：The Least Knowledge Principle。</p><blockquote><p>Each unit should have only limited knowledge about other units: only units “closely” related to the current unit. Or: Each unit should only talk to its friends; Don’t talk to strangers.</p></blockquote><hr><h3 id="23-实战一（上）：针对业务系统的开发，如何做需求分析和设计？"><a href="#23-实战一（上）：针对业务系统的开发，如何做需求分析和设计？" class="headerlink" title="23 | 实战一（上）：针对业务系统的开发，如何做需求分析和设计？"></a>23 | 实战一（上）：针对业务系统的开发，如何做需求分析和设计？</h3><ul><li><p>技术人也要有一些产品思维。对于产品设计、需求分析，我们要学会“借鉴”，一定不要自己闷头想。一方面这样做很难想全面，另一方面从零开始设计也比较浪费时间。除此之外，我们还可以通过线框图和用户用例来细化业务流程，挖掘一些比较细节的、不容易想到的功能点。</p></li><li><p>面向对象设计聚焦在代码层面（主要是针对类），那系统设计就是聚焦在架构层面（主要是针对模块），两者有很多相似之处。很多设计原则和思想不仅仅可以应用到代码设计中，还能用到架构设计中。实际上，我们可以借鉴面向对象设计的步骤，来做系统设计。</p></li><li><p>面向对象设计的本质就是把合适的代码放到合适的类中。合理地划分代码可以实现代码的高内聚、低耦合，类与类之间的交互简单清晰，代码整体结构一目了然。类比面向对象设计，系统设计实际上就是将合适的功能放到合适的模块中。合理地划分模块也可以做到模块层面的高内聚、低耦合，架构整洁清晰。在面向对象设计中，类设计好之后，我们需要设计类之间的交互关系。类比到系统设计，系统职责划分好之后，接下来就是设计系统之间的交互了。</p></li></ul><hr><h3 id="24-实战一（下）：如何实现一个遵从设计原则的积分兑换系统？"><a href="#24-实战一（下）：如何实现一个遵从设计原则的积分兑换系统？" class="headerlink" title="24 | 实战一（下）：如何实现一个遵从设计原则的积分兑换系统？"></a>24 | 实战一（下）：如何实现一个遵从设计原则的积分兑换系统？</h3><p><strong>MVC 三层开发作用：</strong></p><ul><li>分层能起到代码复用的作用</li><li>分层能起到隔离变化的作用</li><li>分层能起到隔离关注点的作用</li><li>分层能提高代码的可测试性</li><li>分层能应对系统的复杂性</li></ul><img src="https://static001.geekbang.org/resource/image/33/61/3332071c82182e72518143d05b8eaa61.jpg"><hr><h3 id="25-实战二（上）：针对非业务的通用框架开发，如何做需求分析和设计？"><a href="#25-实战二（上）：针对非业务的通用框架开发，如何做需求分析和设计？" class="headerlink" title="25 | 实战二（上）：针对非业务的通用框架开发，如何做需求分析和设计？"></a>25 | 实战二（上）：针对非业务的通用框架开发，如何做需求分析和设计？</h3><p>对于非业务通用框架开发：</p><ul><li>首先考虑功能性需求分析；</li><li>还要考虑框架的非功能性需求：易用性、性能、扩展性、容错性、通用性。</li></ul><p>复杂框架设计技巧：</p><ul><li>画产品线框图；</li><li>聚焦简单应用场景；</li><li>设计实现最小原型；</li><li>画系统设计图。</li></ul><hr><h3 id="26-实战二（下）：如何实现一个支持各种统计规则的性能计数器？"><a href="#26-实战二（下）：如何实现一个支持各种统计规则的性能计数器？" class="headerlink" title="26 | 实战二（下）：如何实现一个支持各种统计规则的性能计数器？"></a>26 | 实战二（下）：如何实现一个支持各种统计规则的性能计数器？</h3><hr><h2 id="设计原则与思想：规范与重构"><a href="#设计原则与思想：规范与重构" class="headerlink" title="设计原则与思想：规范与重构"></a>设计原则与思想：规范与重构</h2><h3 id="27-理论一：什么情况下要重构？到底重构什么？又该如何重构？"><a href="#27-理论一：什么情况下要重构？到底重构什么？又该如何重构？" class="headerlink" title="27 | 理论一：什么情况下要重构？到底重构什么？又该如何重构？"></a>27 | 理论一：什么情况下要重构？到底重构什么？又该如何重构？</h3><p>重构是一种对软件内部结构的改变，目的是在不改变软件的可见行为的情况下，使其更易理解，修改成本更低。</p><p>大型重构指的是对顶层代码设计的重构，包括：系统、模块、代码结构、类与类之间的关系等的重构，重构的手段有：分层、模块化、解耦、抽象可复用组件等等。</p><p>小型重构指的是对代码细节的重构，主要是针对类、函数、变量等代码级别的重构，比如规范命名、规范注释、消除超大类或函数、提取重复代码等等。</p><h3 id="28-理论二：为了保证重构不出错，有哪些非常能落地的技术手段？"><a href="#28-理论二：为了保证重构不出错，有哪些非常能落地的技术手段？" class="headerlink" title="28 | 理论二：为了保证重构不出错，有哪些非常能落地的技术手段？"></a>28 | 理论二：为了保证重构不出错，有哪些非常能落地的技术手段？</h3><h3 id="29-理论三：什么是代码的可测试性？如何写出可测试性好的代码？"><a href="#29-理论三：什么是代码的可测试性？如何写出可测试性好的代码？" class="headerlink" title="29 | 理论三：什么是代码的可测试性？如何写出可测试性好的代码？"></a>29 | 理论三：什么是代码的可测试性？如何写出可测试性好的代码？</h3><p>常见的测试不友好的代码有下面这 5 种：</p><ul><li>代码中包含未决行为逻辑</li><li>滥用可变全局变量</li><li>滥用静态方法</li><li>使用复杂的继承关系</li><li>高度耦合的代码</li></ul><h3 id="30-理论四：如何通过封装、抽象、模块化、中间层等解耦代码？"><a href="#30-理论四：如何通过封装、抽象、模块化、中间层等解耦代码？" class="headerlink" title="30 | 理论四：如何通过封装、抽象、模块化、中间层等解耦代码？"></a>30 | 理论四：如何通过封装、抽象、模块化、中间层等解耦代码？</h3><p>如何给代码“解耦”：</p><ul><li>封装与抽象</li><li>中间层</li><li>模块化</li><li>其他设计思想和原值<ul><li>单一职责原则</li><li>基于接口而非实现编程</li><li>依赖注入</li><li>对用组合少用继承</li><li>迪米特法则</li></ul></li></ul><h3 id="31-理论五：让你最快速地改善代码质量的20条编程规范（上）"><a href="#31-理论五：让你最快速地改善代码质量的20条编程规范（上）" class="headerlink" title="31 | 理论五：让你最快速地改善代码质量的20条编程规范（上）"></a>31 | 理论五：让你最快速地改善代码质量的20条编程规范（上）</h3><ul><li><p>关于命名：</p><ul><li>命名的关键是能准确达意。</li><li>借助类的信息来简化属性、函数的命名，利用函数的信息来简化函数参数的命名。</li><li>命名要可读、可搜索。</li><li>接口 &amp; 抽象类命名方式。</li></ul></li><li><p>关于注释：</p><ul><li>注释的目的就是让代码更容易看懂。</li><li>注释本身有一定的维护成本，所以并非越多越好。</li></ul></li></ul><h3 id="32-理论五：让你最快速地改善代码质量的20条编程规范（中）"><a href="#32-理论五：让你最快速地改善代码质量的20条编程规范（中）" class="headerlink" title="32 | 理论五：让你最快速地改善代码质量的20条编程规范（中）"></a>32 | 理论五：让你最快速地改善代码质量的20条编程规范（中）</h3><ul><li>合适的类、函数大小</li><li>一行代码最长不能超过 IDE 显示的宽度。</li><li>善用空行分割单元块</li><li>四格缩进还是两格缩进（分割统一，不用tab）</li><li>大括号所在位置（只要团队统一、业内统一、跟开源项目看齐）</li><li>类中成员的排列顺序（先变量后函数，先静态后普通，作用域由大到小）</li></ul><h3 id="33-理论五：让你最快速地改善代码质量的20条编程规范（下）"><a href="#33-理论五：让你最快速地改善代码质量的20条编程规范（下）" class="headerlink" title="33 | 理论五：让你最快速地改善代码质量的20条编程规范（下）"></a>33 | 理论五：让你最快速地改善代码质量的20条编程规范（下）</h3><ul><li>把代码分割成更小的单元块</li><li>避免函数参数过多</li><li>勿用函数参数来控制逻辑(参数中包含 true | false)</li><li>函数设计要职责单一</li><li>移除过深的嵌套层次</li><li>学会使用解释性变量<ul><li>常量取代魔法数字。</li><li>使用解释性变量来解释复杂表达式。</li></ul></li></ul><h3 id="34-实战一（上）：通过一段ID生成器代码，学习如何发现代码质量问题"><a href="#34-实战一（上）：通过一段ID生成器代码，学习如何发现代码质量问题" class="headerlink" title="34 | 实战一（上）：通过一段ID生成器代码，学习如何发现代码质量问题"></a>34 | 实战一（上）：通过一段ID生成器代码，学习如何发现代码质量问题</h3><p>如何发现代码质量问题：<br>大的方向是否可读、可扩展、可维护、灵活、简洁、可复用、可测试<br>具体落实，通用的关注点有：</p><ul><li>1）目录设置是否合理、模块划分是否清晰、代码结构是否满足“高内聚、松耦合”？</li><li>2）是否遵循经典的设计原则和设计思想（SOLID、DRY、KISS、YAGNI、LOD 等）？</li><li>3）设计模式是否应用得当？是否有过度设计？</li><li>4）代码是否容易扩展？如果要添加新功能，是否容易实现？</li><li>5）代码是否可以复用？是否可以复用已有的项目代码或类库？是否有重复造轮子？</li><li>6）代码是否容易测试？单元测试是否全面覆盖了各种正常和异常的情况？</li><li>7）代码是否易读？是否符合编码规范（比如命名和注释是否恰当、代码风格是否一致等）？</li></ul><p>关于业务的一些通用关注点：</p><ul><li>1）代码是否实现了预期的业务需求？</li><li>2）逻辑是否正确？是否处理了各种异常情况？</li><li>3）日志打印是否得当？是否方便 debug 排查问题？</li><li>4）接口是否易用？是否支持幂等、事务等？</li><li>5）代码是否存在并发问题？是否线程安全？</li><li>6）性能是否有优化空间，比如，SQL、算法是否可以优化？</li><li>7）是否有安全漏洞？比如输入输出校验是否全面？</li></ul><h3 id="35-实战一（下）：手把手带你将ID生成器代码从“能用”重构为“好用”"><a href="#35-实战一（下）：手把手带你将ID生成器代码从“能用”重构为“好用”" class="headerlink" title="35 | 实战一（下）：手把手带你将ID生成器代码从“能用”重构为“好用”"></a>35 | 实战一（下）：手把手带你将ID生成器代码从“能用”重构为“好用”</h3><ul><li>即便是非常简单的需求，不同水平的人写出来的代码，差别可能会很大。</li><li>知其然知其所以然，了解优秀代码设计的演变过程，比学习优秀设计本身更有价值。</li><li>设计思想、原则、模式本身并没有太多“高大上”的东西，都是一些简单的道理。</li><li>高手之间的竞争都是在细节。</li></ul><h3 id="36-实战二（上）：程序出错该返回啥？NULL、异常、错误码、空对象？"><a href="#36-实战二（上）：程序出错该返回啥？NULL、异常、错误码、空对象？" class="headerlink" title="36 | 实战二（上）：程序出错该返回啥？NULL、异常、错误码、空对象？"></a>36 | 实战二（上）：程序出错该返回啥？NULL、异常、错误码、空对象？</h3><p>函数出错返回数据类型：</p><ul><li>返回错误码</li><li>返回 NULL 值</li><li>返回空对象</li><li>抛出异常对象<ul><li>如果 func1() 抛出的异常是可以恢复，且 func2() 的调用方并不关心此异常，我们完全可以在 func2() 内将 func1() 抛出的异常吞掉；</li><li>如果 func1() 抛出的异常对 func2() 的调用方来说，也是可以理解的、关心的 ，并且在业务概念上有一定的相关性，我们可以选择直接将 func1 抛出的异常 re-throw；</li><li>如果 func1() 抛出的异常太底层，对 func2() 的调用方来说，缺乏背景去理解、且业务概念上无关，我们可以将它重新包装成调用方可以理解的新异常，然后 re-throw。</li></ul></li></ul><h3 id="37-实战二（下）：重构ID生成器项目中各函数的异常处理代码"><a href="#37-实战二（下）：重构ID生成器项目中各函数的异常处理代码" class="headerlink" title="37 | 实战二（下）：重构ID生成器项目中各函数的异常处理代码"></a>37 | 实战二（下）：重构ID生成器项目中各函数的异常处理代码</h3><ul><li>再简单的代码，看上去再完美的代码，只要我们下功夫去推敲，总有可以优化的空间，就看你愿不愿把事情做到极致。</li><li>如果你内功不够深厚，理论知识不够扎实，那你就很难参透开源项目的代码到底优秀在哪里。</li><li>作为一名程序员，起码对代码要有追求啊，不然跟咸鱼有啥区别！</li></ul><h2 id="设计原则与思想：总结课"><a href="#设计原则与思想：总结课" class="headerlink" title="设计原则与思想：总结课"></a>设计原则与思想：总结课</h2><h3 id="38-总结回顾面向对象、设计原则、编程规范、重构技巧等知识点"><a href="#38-总结回顾面向对象、设计原则、编程规范、重构技巧等知识点" class="headerlink" title="38 | 总结回顾面向对象、设计原则、编程规范、重构技巧等知识点"></a>38 | 总结回顾面向对象、设计原则、编程规范、重构技巧等知识点</h3><p>最常用到几个评判代码质量的标准有：可维护性、可读性、可扩展性、灵活性、简洁性、可复用性、可测试性。</p><p>面向对象编程相比面向过程编程的优势主要有三个：</p><ul><li>对于大规模复杂程序的开发，程序的处理流程并非单一的一条主线，而是错综复杂的网状结构。面向对象编程比起面向过程编程，更能应对这种复杂类型的程序开发。</li><li>面向对象编程相比面向过程编程，具有更加丰富的特性（封装、抽象、继承、多态）。利用这些特性编写出来的代码，更加易扩展、易复用、易维护。</li><li>从编程语言跟机器打交道方式的演进规律中，我们可以总结出：面向对象编程语言比起面向过程编程语言，更加人性化、更加高级、更加智能。</li></ul><p>面向对象分析（OOA）、面向对象设计（OOD）、面向对象编程（OOP），是面向对象开发的三个主要环节。简单点讲，面向对象分析就是要搞清楚做什么，面向对象设计就是要搞清楚怎么做，面向对象编程就是将分析和设计的的结果翻译成代码的过程。</p><p>UML 统一建模语言中定义了六种类之间的关系。它们分别是：泛化、实现、关联、聚合、组合、依赖。我们从更加贴近编程的角度，对类与类之间的关系做了调整，保留了四个关系：泛化、实现、组合、依赖。</p><p>如果要表示一种 is-a 的关系，并且是为了解决代码复用问题，我们就用抽象类；如果要表示一种 has-a 关系，并且是为了解决抽象而非代码复用问题，那我们就用接口。</p><p>基于充血模型的 DDD 开发模式跟基于贫血模型的传统开发模式相比，Controller 层和 Repository 层的代码基本上相同。这是因为，Repository 层的 Entity 生命周期有限，Controller 层的 VO 只是单纯作为一种 DTO。两部分的业务逻辑都不会太复杂。业务逻辑主要集中在 Service 层。所以，Repository 层和 Controller 层继续沿用贫血模型的设计思路是没有问题的。</p><p>设计原则：</p><ul><li>SRP 单一职责原则</li><li>OCP 开闭原则</li><li>LSP 里氏替换原则</li><li>ISP 接口隔离原则</li><li>DIP 依赖倒置原则</li><li>KISS、YAGNI 原则</li><li>DRY 原则</li><li>LOD 原则</li></ul><h3 id="39-运用学过的设计原则和思想完善之前讲的性能计数器项目（上）"><a href="#39-运用学过的设计原则和思想完善之前讲的性能计数器项目（上）" class="headerlink" title="39 | 运用学过的设计原则和思想完善之前讲的性能计数器项目（上）"></a>39 | 运用学过的设计原则和思想完善之前讲的性能计数器项目（上）</h3><img src="https://static001.geekbang.org/resource/image/13/34/1303d16f75c7266cef9105f540c54834.jpg"><h3 id="40-运用学过的设计原则和思想完善之前讲的性能计数器项目（下）"><a href="#40-运用学过的设计原则和思想完善之前讲的性能计数器项目（下）" class="headerlink" title="40 | 运用学过的设计原则和思想完善之前讲的性能计数器项目（下）"></a>40 | 运用学过的设计原则和思想完善之前讲的性能计数器项目（下）</h3><h2 id="设计模式与规范：创建型"><a href="#设计模式与规范：创建型" class="headerlink" title="设计模式与规范：创建型"></a>设计模式与规范：创建型</h2><h3 id="41-单例模式（上）：为什么说支持懒加载的双重检测不比饿汉式更优？"><a href="#41-单例模式（上）：为什么说支持懒加载的双重检测不比饿汉式更优？" class="headerlink" title="41 | 单例模式（上）：为什么说支持懒加载的双重检测不比饿汉式更优？"></a>41 | 单例模式（上）：为什么说支持懒加载的双重检测不比饿汉式更优？</h3><p><strong>单例设计模式</strong>（Singleton Design Pattern）理解起来非常简单。一个类只允许创建一个对象（或者实例），那这个类就是一个单例类，这种设计模式就叫作单例设计模式，简称单例模式。</p><p>如何实现一个单例类？</p><ul><li>构造函数需要是 private 访问权限的，这样才能避免外部通过 new 创建实例；- 考虑对象创建时的线程安全问题；</li><li>考虑是否支持延迟加载；</li><li>考虑 getInstance() 性能是否高（是否加锁）。</li></ul><p>单例的实现：</p><ul><li>饿汉式；</li><li>懒汉式；</li><li>双重检测；</li><li>静态内部类；</li><li>枚举。</li></ul><h3 id="42-单例模式（中）：我为什么不推荐使用单例模式？又有何替代方案？"><a href="#42-单例模式（中）：我为什么不推荐使用单例模式？又有何替代方案？" class="headerlink" title="42 | 单例模式（中）：我为什么不推荐使用单例模式？又有何替代方案？"></a>42 | 单例模式（中）：我为什么不推荐使用单例模式？又有何替代方案？</h3><ul><li>单例对 OOP 特性的支持不友好</li><li>单例会隐藏类之间的依赖关系</li><li>单例对代码的扩展性不友好</li><li>单例对代码的可测试性不友好</li><li>单例不支持有参数的构造函数</li></ul><h3 id="43-单例模式（下）：如何设计实现一个集群环境下的分布式单例模式？"><a href="#43-单例模式（下）：如何设计实现一个集群环境下的分布式单例模式？" class="headerlink" title="43 | 单例模式（下）：如何设计实现一个集群环境下的分布式单例模式？"></a>43 | 单例模式（下）：如何设计实现一个集群环境下的分布式单例模式？</h3><p>单例类中对象的唯一性的作用范围是进程内的，在进程间是不唯一的。</p><p>进程内唯一：使用单例模式；<br>线程内唯一：使用ThreadLocal；<br>进程间唯一：考虑使用分布式锁。</p><p>单例模式并不是严格意义的进程内唯一，而是同一个 ClassLoader 内唯一。</p><h3 id="44-工厂模式（上）：我为什么说没事不要随便用工厂模式创建对象？"><a href="#44-工厂模式（上）：我为什么说没事不要随便用工厂模式创建对象？" class="headerlink" title="44 | 工厂模式（上）：我为什么说没事不要随便用工厂模式创建对象？"></a>44 | 工厂模式（上）：我为什么说没事不要随便用工厂模式创建对象？</h3><ul><li>简单工厂模式（静态工厂模式）</li><li>工厂模式</li><li>抽象工厂模式</li></ul><p>当每个对象的创建逻辑都比较简单的时候，我推荐使用简单工厂模式，将多个对象的创建逻辑放到一个工厂类中。当每个对象的创建逻辑都比较复杂的时候，为了避免设计一个过于庞大的简单工厂类，我推荐使用工厂方法模式，将创建逻辑拆分得更细，每个对象的创建逻辑独立到各自的工厂类中。</p><ul><li>封装变化：创建逻辑有可能变化，封装成工厂类之后，创建逻辑的变更对调用者透明。</li><li>代码复用：创建代码抽离到独立的工厂类之后可以复用。</li><li>隔离复杂性：封装复杂的创建逻辑，调用者无需了解如何创建对象。</li><li>控制复杂度：将创建代码抽离出来，让原本的函数或类职责更单一，代码更简洁。</li></ul><h3 id="45-工厂模式（下）：如何设计实现一个Dependency-Injection框架？"><a href="#45-工厂模式（下）：如何设计实现一个Dependency-Injection框架？" class="headerlink" title="45 | 工厂模式（下）：如何设计实现一个Dependency Injection框架？"></a>45 | 工厂模式（下）：如何设计实现一个Dependency Injection框架？</h3><p>一个简单的 DI 容器的核心功能一般有三个：配置解析、对象创建和对象生命周期管理。</p><p>Spring 处理循环依赖：</p><ul><li>通过构造器注入的循环依赖，是无法解决的。</li><li>Spring 容器对原型作用域的 bean 是不进行缓存，因此无法提前暴露一个创建中的 bean，所以也是无法解决这种情况的循环依赖。</li><li>对于 setter 注入造成的依赖可以通过 Spring 容器提前暴露刚完成构造器注入但未完成其他步骤（如 setter 注入）的 bean 来完成，而且只能解决单例作用域的 bean 依赖。</li></ul><p><a href="https://juejin.im/post/5d0d8f64f265da1b7b3193ac" target="_blank" rel="noopener">Spring 源码学习(五)循环依赖</a></p><h3 id="46-建造者模式：详解构造函数、set方法、建造者模式三种对象创建方式"><a href="#46-建造者模式：详解构造函数、set方法、建造者模式三种对象创建方式" class="headerlink" title="46 | 建造者模式：详解构造函数、set方法、建造者模式三种对象创建方式"></a>46 | 建造者模式：详解构造函数、set方法、建造者模式三种对象创建方式</h3><p>使用建造者模式创建对象，还能避免对象存在无效状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Rectangle r = <span class="keyword">new</span> Rectange(); <span class="comment">// r is invalid</span></span><br><span class="line">r.setWidth(<span class="number">2</span>); <span class="comment">// r is invalid</span></span><br><span class="line">r.setHeight(<span class="number">3</span>); <span class="comment">// r is valid</span></span><br></pre></td></tr></table></figure><p>工厂模式是用来创建不同但是相关类型的对象（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。建造者模式是用来创建一种类型的复杂对象，通过设置不同的可选参数，“定制化”地创建不同的对象。</p><p>顾客走进一家餐馆点餐，我们利用工厂模式，根据用户不同的选择，来制作不同的食物，比如披萨、汉堡、沙拉。对于披萨来说，用户又有各种配料可以定制，比如奶酪、西红柿、起司，我们通过建造者模式根据用户选择的不同配料来制作披萨。</p><h3 id="47-原型模式：如何最快速地clone一个HashMap散列表？"><a href="#47-原型模式：如何最快速地clone一个HashMap散列表？" class="headerlink" title="47 | 原型模式：如何最快速地clone一个HashMap散列表？"></a>47 | 原型模式：如何最快速地clone一个HashMap散列表？</h3><p>如果对象的创建成本比较大，而同一个类的不同对象之间差别不大（大部分字段都相同），在这种情况下，我们可以利用对已有对象（原型）进行复制（或者叫拷贝）的方式，来创建新对象，以达到节省创建时间的目的。这种基于原型来创建对象的方式就叫作原型设计模式，简称原型模式。</p><p>在 Java 语言中，Object 类的 clone() 方法执行的就是我们刚刚说的浅拷贝。它只会拷贝对象中的基本数据类型的数据（比如，int、long），以及引用对象（SearchWord）的内存地址，不会递归地拷贝引用对象本身。</p><img src="https://static001.geekbang.org/resource/image/74/82/74bceb7a0736957daaa4abeba6826182.jpg"><img src="https://static001.geekbang.org/resource/image/b9/1b/b978d054ab3183b9e0ae461e6abac81b.jpg"><h2 id="设计模式与规范：结构型"><a href="#设计模式与规范：结构型" class="headerlink" title="设计模式与规范：结构型"></a>设计模式与规范：结构型</h2><h3 id="48-代理模式：代理在RPC、缓存、监控等场景中的应用"><a href="#48-代理模式：代理在RPC、缓存、监控等场景中的应用" class="headerlink" title="48 | 代理模式：代理在RPC、缓存、监控等场景中的应用"></a>48 | 代理模式：代理在RPC、缓存、监控等场景中的应用</h3><p>在不改变原始类（或叫被代理类）的情况下，通过引入代理类来给原始类附加功能。一般情况下，我们让代理类和原始类实现同样的接口。但是，如果原始类并没有定义接口，并且原始类代码并不是我们开发维护的。在这种情况下，我们可以通过让代理类继承原始类的方法来实现代理模式。</p><p>静态代理需要针对每个类都创建一个代理类，并且每个代理类中的代码都有点像模板式的”重复“代码，增加了维护成本和开发成本。对于静态代理存在的问题，我们可以通过动态代理来解决。我们不事先为每个原始类编写代理类，而是在运行的时候动态地创建原始类对应的代理类，然后在系统中用代理类替换掉原始类。</p><h3 id="49-桥接模式：如何实现支持不同类型和渠道的消息推送系统？"><a href="#49-桥接模式：如何实现支持不同类型和渠道的消息推送系统？" class="headerlink" title="49 | 桥接模式：如何实现支持不同类型和渠道的消息推送系统？"></a>49 | 桥接模式：如何实现支持不同类型和渠道的消息推送系统？</h3><p>Decouple an abstraction from its implementation so that the two can vary independently。（将抽象和实现解耦，让它们可以独立变化。）</p><h3 id="50-装饰器模式：通过剖析Java-IO类库源码学习装饰器模式"><a href="#50-装饰器模式：通过剖析Java-IO类库源码学习装饰器模式" class="headerlink" title="50 | 装饰器模式：通过剖析Java IO类库源码学习装饰器模式"></a>50 | 装饰器模式：通过剖析Java IO类库源码学习装饰器模式</h3><p>装饰器类和原始类继承同样的父类，这样我们可以对原始类“嵌套”多个装饰器类。</p><p>装饰器类是对功能的增强，这也是装饰器模式应用场景的一个重要特点。</p><p>代理模式中，代理类附加的是跟原始类无关的功能，而在装饰器模式中，装饰器类附加的是跟原始类相关的增强功能。</p><img src="https://static001.geekbang.org/resource/image/50/05/507526c2e4b255a45c60722df14f9a05.jpg"><img src="https://static001.geekbang.org/resource/image/50/13/5082df8e7d5a4d44a34811b9f562d613.jpg"><h3 id="51-适配器模式：代理、适配器、桥接、装饰，这四个模式有何区别？"><a href="#51-适配器模式：代理、适配器、桥接、装饰，这四个模式有何区别？" class="headerlink" title="51 | 适配器模式：代理、适配器、桥接、装饰，这四个模式有何区别？"></a>51 | 适配器模式：代理、适配器、桥接、装饰，这四个模式有何区别？</h3><p>适配器模式有两种实现方式：类适配器和对象适配器。其中，类适配器使用继承关系来实现，对象适配器使用组合关系来实现。</p><p><strong>代理模式</strong>：代理模式在不改变原始类接口的条件下，为原始类定义一个代理类，主要目的是控制访问，而非加强功能，这是它跟装饰器模式最大的不同。<br><strong>桥接模式</strong>：桥接模式的目的是将接口部分和实现部分分离，从而让它们可以较为容易、也相对独立地加以改变。<br><strong>装饰器模式</strong>：装饰者模式在不改变原始类接口的情况下，对原始类功能进行增强，并且支持多个装饰器的嵌套使用。<br><strong>适配器模式</strong>：适配器模式是一种事后的补救策略。适配器提供跟原始类不同的接口，而代理模式、装饰器模式提供的都是跟原始类相同的接口。</p><h3 id="52-门面模式：如何设计合理的接口粒度以兼顾接口的易用性和通用性？"><a href="#52-门面模式：如何设计合理的接口粒度以兼顾接口的易用性和通用性？" class="headerlink" title="52 | 门面模式：如何设计合理的接口粒度以兼顾接口的易用性和通用性？"></a>52 | 门面模式：如何设计合理的接口粒度以兼顾接口的易用性和通用性？</h3><p><strong>门面模式</strong>：</p><ul><li>Provide a unified interface to a set of interfaces in a subsystem. Facade Pattern defines a higher-level interface that makes the subsystem easier to use.</li><li>门面模式为子系统提供一组统一的接口，定义一组高层接口让子系统更易用。</li></ul><p>完成接口设计，就相当于完成了一半的开发任务。只要接口设计得好，那代码就差不到哪里去。</p><p>尽量保持接口的可复用性，但针对特殊情况，允许提供冗余的门面接口，来提供更易用的接口。</p><ul><li>当要为一个复杂子系统提供一个简单接口时可以使用外观模式。</li><li>客户程序与多个子系统之间存在很大的依赖性。</li><li>使用外观模式定义系统中每一层的入口，层与层之间不直接产生联系，而通过外观类建立联系，降低层之间的耦合度。</li></ul><p>增加新的子系统可能需要修改外观类或客户端的源代码，<strong>违背了“开闭原则”</strong>。</p><h3 id="53-组合模式：如何设计实现支持递归遍历的文件系统目录树结构？"><a href="#53-组合模式：如何设计实现支持递归遍历的文件系统目录树结构？" class="headerlink" title="53 | 组合模式：如何设计实现支持递归遍历的文件系统目录树结构？"></a>53 | 组合模式：如何设计实现支持递归遍历的文件系统目录树结构？</h3><p>组合模式：Compose objects into tree structure to represent part-whole hierarchies. Composite lets client treat individual objects and compositions of objects uniformly.</p><p>将一组对象组织（Compose）成树形结构，以表示一种“部分 - 整体”的层次结构。组合让客户端（在很多设计模式书籍中，“客户端”代指代码的使用者。）可以统一单个对象和组合对象的处理逻辑。</p><h3 id="54-享元模式（上）：如何利用享元模式优化文本编辑器的内存占用？"><a href="#54-享元模式（上）：如何利用享元模式优化文本编辑器的内存占用？" class="headerlink" title="54 | 享元模式（上）：如何利用享元模式优化文本编辑器的内存占用？"></a>54 | 享元模式（上）：如何利用享元模式优化文本编辑器的内存占用？</h3><p>享元模式(Flyweight Pattern)：运用共享技术有效地支持大量细粒度对象的复用。(Use sharing to support large numbers of fine-grained objects efficiently.)</p><p>享元模式的代码实现非常简单，主要是通过工厂模式，在工厂类中，通过一个 Map 或者 List 来缓存已经创建好的享元对象，以达到复用的目的。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://blog.cleancoder.com/uncle-bob/2014/05/08/SingleReponsibilityPrinciple.html" target="_blank" rel="noopener">The Clean Code Blog</a></li><li><a href="https://unbug.github.io/codelf/" target="_blank" rel="noopener">Codelf(变量命名神器)</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是 &lt;a href=&quot;https://time.geekbang.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;极客时间&lt;/a&gt; 上 &lt;a href=&quot;https://time.geekbang.org/column/intro/100039001&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;设计模式之美&lt;/a&gt; 课程的学习笔记内容。&lt;/p&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="https://dongzl.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://dongzl.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="设计原则" scheme="https://dongzl.github.io/tags/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>Lombok 框架使用总结</title>
    <link href="https://dongzl.github.io/2019/11/30/12-Lombok-Use-Summary/"/>
    <id>https://dongzl.github.io/2019/11/30/12-Lombok-Use-Summary/</id>
    <published>2019-11-30T12:38:18.000Z</published>
    <updated>2020-03-09T14:23:23.166Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景描述"><a href="#背景描述" class="headerlink" title="背景描述"></a>背景描述</h2><p>最近一直在参与 <a href="https://github.com/apache/incubator-shardingsphere" target="_blank" rel="noopener">ShardingSphere</a> 开源项目的一些工作，在 ShardingSphere 项目中大量的使用了 <a href="https://projectlombok.org/" target="_blank" rel="noopener">Lombok</a> 框架，对于 Lombok 框架只是有个大概了解，并没有实际的使用，也没有做过深入的研究，正好借参与 ShardingSphere 项目的机会对 Lombok 框架做一个学习和总结，先总结一下自己目前使用中遇到的问题，后续持续不断更新。</p><a id="more"></a><p>首先，来看一下 Lombok 官方对这个框架的介绍：</p><blockquote><p>Project Lombok is a java library that automatically plugs into your editor and build tools, spicing up your java.<br>Never write another getter or equals method again, with one annotation your class has a fully featured builder, Automate your logging variables, and much more.</p></blockquote><p>Lombok 是一个 java 类库，它可以自动插入到编辑器和构建工具中，对 java 代码进行增强。</p><p>使用 Lombok 后不需要再实现 getter 或者 equals 方法，使用一个注解，您的类就可以拥有一个功能齐全的构造器，自动生成一个日志变量等等功能。</p><blockquote><p>测试 Lombok 版本：1.18.10</p></blockquote><h2 id="构造方法相关注解"><a href="#构造方法相关注解" class="headerlink" title="构造方法相关注解"></a>构造方法相关注解</h2><h3 id="NoArgsConstructor"><a href="#NoArgsConstructor" class="headerlink" title="@NoArgsConstructor"></a>@NoArgsConstructor</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.AccessLevel;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NoArgsConstructor</span>(access = AccessLevel.PRIVATE, staticName = <span class="string">"of"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@NoArgsConstructor 用于生成无参构造器，如果类中存在 final 字段，则会报编译错误。</p><ul><li><code>access</code> 参数用于指定构造器的访问权限，默认为 <code>AccessLevel.PUBLIC</code> 表示生成 public 访问权限的构造器；</li><li><code>staticName</code> 参数用于自动生成一个静态的“构造器”工厂，其内部包裹着一个私有的构造器，对外提供创建对象的功能，这是明显的工厂模式。</li></ul><h3 id="RequiredArgsConstructor"><a href="#RequiredArgsConstructor" class="headerlink" title="@RequiredArgsConstructor"></a>@RequiredArgsConstructor</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.AccessLevel;</span><br><span class="line"><span class="keyword">import</span> lombok.NonNull;</span><br><span class="line"><span class="keyword">import</span> lombok.RequiredArgsConstructor;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span>(access = AccessLevel.PUBLIC, staticName = <span class="string">"of"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Integer id;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        User user = User.of(<span class="number">1</span>, <span class="string">"test"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@RequiredArgsConstructor 用于按照要求生成部分参数构造器，所谓的要求就是包含 final 和 @NonNull 约束标注的字段，会对 @NonNull 字段进行明确的 null 检查。</p><h3 id="AllArgsConstructor"><a href="#AllArgsConstructor" class="headerlink" title="@AllArgsConstructor"></a>@AllArgsConstructor</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.AccessLevel;</span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.NonNull;</span><br><span class="line"><span class="keyword">import</span> lombok.RequiredArgsConstructor;</span><br><span class="line"></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span>(access = AccessLevel.PUBLIC, staticName = <span class="string">"of"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Integer id;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        User user = User.of(<span class="number">1</span>, <span class="string">"test"</span>);</span><br><span class="line">        User user2 = <span class="keyword">new</span> User(<span class="number">1</span>, <span class="string">"test"</span>, <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@AllArgsConstructor 用于生成包含所有字段的构造器。</p><h2 id="Getter-amp-Setter"><a href="#Getter-amp-Setter" class="headerlink" title="@Getter &amp; @Setter"></a>@Getter &amp; @Setter</h2><p>@Getter &amp; @Setter 标注在字段上，用于自动生成 get、set 方法，boolean 类型字段 get 方法为 isXXX() 方法。</p><p>生成的 get、set 方法默认情况下都是 public 的，但也可以手动指定以下四种范围：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">AccessLevel.PUBLIC</span><br><span class="line">AccessLevel.MODULE</span><br><span class="line">AccessLevel.PROTECTED</span><br><span class="line">AccessLevel.PACKAGE</span><br><span class="line">AccessLevel.PRIVATE</span><br></pre></td></tr></table></figure><p>@Getter &amp; @Setter 也可以标注在类上，表示针对该类中所有的非静态字段进行 get、set 方法自动生成。如果指定某个字段的 <code>AccessLevel = AccessLevel.NONE</code>，则可以使该生成动作失效，此时可以手动实现get、set方法，AccessLevel.NONE 可以应用于在某些方法中有一些自定义逻辑的情况下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.AccessLevel;</span><br><span class="line"><span class="keyword">import</span> lombok.Getter;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Setter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Setter</span>(value = AccessLevel.PRIVATE)</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Getter</span>(value = AccessLevel.PACKAGE)</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Getter</span>(value = AccessLevel.NONE)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> student;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isStudent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (age &lt; <span class="number">18</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ToString"><a href="#ToString" class="headerlink" title="@ToString"></a>@ToString</h2><p>@ToString 标注于类之上，用于生成 toString() 方法。</p><ul><li>includeFieldNames：默认为 true，表示在 toString 输出时输出字段名称；</li><li>exclude：字符串数组，表示在 toString 输出时排除掉字段名称，这个属性将要被废弃了，用 @ToString.Exclude 来代替；</li><li>of：字符串数组，明确的列出在 toString 输出时输出字段名称，这个属性将要被废弃了，用 @ToString.Include 来代替；</li><li>callSuper：默认为 false，表示生成 toString 时不输出超类中的字段内容；</li><li>doNotUseGetters：默认为 false，表示获取字段值时通过 get 方法获取，设置为 true 表示直接通过字段获取；</li><li>onlyExplicitlyIncluded：默认为 false，表示在 toString 输出时输出全部非静态字段；设置为 true 时，表示只输出 @ToString.Include 标识的字段；</li><li>Exclude：标识属性，表示在 toString 输出时排除该字段；</li><li></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.ToString;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@ToString</span>(includeFieldNames = <span class="keyword">true</span>, exclude = &#123;<span class="string">"id"</span>, <span class="string">"name"</span>&#125;, of = &#123;&#125;, callSuper = <span class="keyword">true</span>, doNotUseGetters = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> student;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="EqualsAndHashCode"><a href="#EqualsAndHashCode" class="headerlink" title="@EqualsAndHashCode"></a>@EqualsAndHashCode</h2><p>@EqualsAndHashCode 标注于类之上用于生成hashCode方法和equals方法。</p><ul><li>exclude：字符串数组，表示在 toString 输出时排除掉字段名称；</li><li>of：</li><li>callSuper：默认为 false，表示生成 toString 时不输出超类中的字段内容；</li><li>doNotUseGetters：默认为 false，表示获取字段值时通过 get 方法获取，设置为 true 表示直接通过字段获取。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.EqualsAndHashCode;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@EqualsAndHashCode</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Data"><a href="#Data" class="headerlink" title="@Data"></a>@Data</h2><p>@Data 标注于类之上，是 @ToString、@EqualsAndHashCode、@Getter、@Setter、@RequiredArgsConstructor的综合体</p><ul><li>staticConstructor：类似于 @RequiredArgsConstructor 中 staticName 参数。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span>(staticConstructor = <span class="string">"of"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SneakyThrows"><a href="#SneakyThrows" class="headerlink" title="@SneakyThrows"></a>@SneakyThrows</h2><p>@SneakyThrows 标注于方法之上用于隐藏异常抛出语句。</p><h2 id="Log-日志"><a href="#Log-日志" class="headerlink" title="Log 日志"></a>Log 日志</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">lombok.extern.apachecommons.CommonsLog;</span><br><span class="line">lombok.extern.flogger.Flogger;</span><br><span class="line">lombok.extern.java.Log;</span><br><span class="line">lombok.extern.jbosslog.JBossLog;</span><br><span class="line">lombok.extern.log4j.Log4j;</span><br><span class="line">lombok.extern.log4j.Log4j2;</span><br><span class="line">lombok.extern.slf4j.Slf4j;</span><br><span class="line">lombok.extern.slf4j.XSlf4j;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://projectlombok.org/" target="_blank" rel="noopener">Project Lombok</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景描述&quot;&gt;&lt;a href=&quot;#背景描述&quot; class=&quot;headerlink&quot; title=&quot;背景描述&quot;&gt;&lt;/a&gt;背景描述&lt;/h2&gt;&lt;p&gt;最近一直在参与 &lt;a href=&quot;https://github.com/apache/incubator-shardingsphere&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ShardingSphere&lt;/a&gt; 开源项目的一些工作，在 ShardingSphere 项目中大量的使用了 &lt;a href=&quot;https://projectlombok.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Lombok&lt;/a&gt; 框架，对于 Lombok 框架只是有个大概了解，并没有实际的使用，也没有做过深入的研究，正好借参与 ShardingSphere 项目的机会对 Lombok 框架做一个学习和总结，先总结一下自己目前使用中遇到的问题，后续持续不断更新。&lt;/p&gt;
    
    </summary>
    
    
      <category term="web开发" scheme="https://dongzl.github.io/categories/web%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Lombok" scheme="https://dongzl.github.io/tags/Lombok/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 环境搭建 &amp; 常用插件集成</title>
    <link href="https://dongzl.github.io/2019/11/20/11-Hexo-Environment-Building/"/>
    <id>https://dongzl.github.io/2019/11/20/11-Hexo-Environment-Building/</id>
    <published>2019-11-20T11:12:09.000Z</published>
    <updated>2020-03-09T14:25:07.446Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景描述"><a href="#背景描述" class="headerlink" title="背景描述"></a>背景描述</h2><p>本文主要记录 Hexo 博客系统搭建过程，以及一些常用插件的集成和使用过程，后续会一直迭代更新。</p><a id="more"></a><h2 id="常用插件集成"><a href="#常用插件集成" class="headerlink" title="常用插件集成"></a>常用插件集成</h2><h3 id="PlantUml-安装使用"><a href="#PlantUml-安装使用" class="headerlink" title="PlantUml 安装使用"></a>PlantUml 安装使用</h3><p><strong>作用：</strong> 在 Hexo 中识别并生成由 flow 编写的图表。</p><p><strong>网址：</strong> <a href="http://plantuml.com/zh/" target="_blank" rel="noopener">http://plantuml.com/zh/</a></p><p><strong>Github地址：</strong> 暂无</p><p><strong>Hexo插件：</strong> <a href="https://github.com/two/hexo-tag-plantuml" target="_blank" rel="noopener">two/hexo-tag-plantuml</a></p><p><strong>Install：</strong> <code>npm hexo-tag-plantuml --save</code></p><p><strong>示例：</strong></p><img src="http://www.plantuml.com/plantuml/svg/JK_12i8m3BttAnuxku4UPGoy28BCYqSlTSrqeoJI1b7musqt1q8WoKjUtelfl8qHf-j8dQAkSIEcO3sQnYpWfonBx4Amx-CGrHWM9QWy8Fr2tEB06EtJha1F2czCPozCBoLs4NeV8eIf-h6BSmPIMFHUh0vyGnuKi17j-dzfAbFkX3b9aRkm2cAMIJPbqe_LJDmidgigD-qc5t_EvsVt8hE0frwtE34Ih73K3qnkjcw-"><h3 id="flowchart-安装使用"><a href="#flowchart-安装使用" class="headerlink" title="flowchart 安装使用"></a>flowchart 安装使用</h3><p><strong>作用：</strong> 在 Hexo 中识别并生成由 flow 编写的图表。</p><p><strong>网址：</strong> <a href="http://flowchart.js.org/" target="_blank" rel="noopener">http://flowchart.js.org/</a></p><p><strong>Github地址：</strong> <a href="https://github.com/adrai/flowchart.js" target="_blank" rel="noopener">adrai/flowchart.js</a></p><p><strong>Hexo插件：</strong> <a href="https://github.com/bubkoo/hexo-filter-flowchart" target="_blank" rel="noopener">bubkoo/hexo-filter-flowchart</a></p><p><strong>Install：</strong> <code>npm install hexo-filter-flowchart --save</code></p><p><strong>示例：</strong></p><div id="flowchart-0" class="flow-chart"></div><h3 id="mermaid-安装使用"><a href="#mermaid-安装使用" class="headerlink" title="mermaid 安装使用"></a>mermaid 安装使用</h3><p><strong>作用：</strong> 在 Hexo 中识别并生成由 mermaid 编写的图表。</p><p><strong>网址：</strong> <a href="https://mermaidjs.github.io/" target="_blank" rel="noopener">https://mermaidjs.github.io/</a></p><p><strong>Github地址：</strong> <a href="https://github.com/mermaid-js/mermaid" target="_blank" rel="noopener">mermaid-js/mermaid</a></p><p><strong>Hexo插件：</strong> <a href="https://github.com/webappdevelp/hexo-filter-mermaid-diagrams" target="_blank" rel="noopener">webappdevelp/hexo-filter-mermaid-diagrams</a></p><p><strong>Install：</strong> <code>npm install hexo-filter-mermaid-diagrams --save</code></p><p><strong>示例：</strong></p><pre class="mermaid">sequenceDiagramAlice->>John: Hello John, how are you?loop Healthcheck    John->>John: Fight against hypochondriaendNote right of John: Rational thoughts!John-->>Alice: Great!John->>Bob: How about you?Bob-->>John: Jolly good!</pre><pre class="mermaid">ganttsection SectionCompleted :done,    des1, 2014-01-06,2014-01-08Active        :active,  des2, 2014-01-07, 3dParallel 1   :         des3, after des1, 1dParallel 2   :         des4, after des1, 1dParallel 3   :         des5, after des3, 1dParallel 4   :         des6, after des4, 1d</pre><h3 id="MathJax-安装使用"><a href="#MathJax-安装使用" class="headerlink" title="MathJax 安装使用"></a>MathJax 安装使用</h3><p><strong>作用：</strong> MathJax is an open-source JavaScript display engine for LaTeX, MathML, and AsciiMath notation that works in all modern browsers.</p><p><strong>网址：</strong> <a href="https://www.mathjax.org/" target="_blank" rel="noopener">https://www.mathjax.org/</a></p><p><strong>Github地址：</strong> <a href="https://github.com/mathjax/MathJax" target="_blank" rel="noopener">mathjax/MathJax</a></p><p><strong>Hexo插件：</strong> <a href="https://github.com/phoenixcw/hexo-renderer-mathjax" target="_blank" rel="noopener">phoenixcw/hexo-renderer-mathjax</a> | <a href="https://github.com/hexojs/hexo-math" target="_blank" rel="noopener">hexojs/hexo-math</a></p><p><strong>Install：</strong> <code>npm install hexo-renderer-mathjax --save</code> | <code>npm install hexo-math --save</code></p><p><font color="red"><strong>PS. 对于 MathJax 功能的支持，有一些不同的 hexo 插件，根据使用的插件不同需要不同的配置。我使用的 <a href="https://github.com/sanonz/hexo-theme-concise" target="_blank" rel="noopener">hexo-theme-concise</a> 主题，在这个 issue 中解决了 MathJax 支持问题：<a href="https://github.com/sanonz/hexo-theme-concise/issues/33" target="_blank" rel="noopener">issue33</a></strong></font></p><p><strong>示例：</strong></p><ul><li><p>行内表达式：</p><ul><li><p>$MEMORY*(单节点总核数/NPROC)\leq单节点总内存$</p></li><li><p>$f(x_1,x_x,\ldots,x_n) = x_1^2 + x_2^2 + \cdots + x_n^2$</p></li><li><p>$a = b + c$</p></li><li><p>$F_a = F_b + F_c + F_{\mu}$</p></li></ul></li><li><p>块表达式：</p><ul><li><p>$$ x = {-b \pm \sqrt{b^2-4ac} \over 2a} $$</p></li><li><p>$$ f(x_1,x_x,\ldots,x_n) = x_1^2 + x_2^2 + \cdots + x_n^2 $$</p></li><li><p>$$f(x) = 3x + 7$$</p></li><li><p>$$\frac{\partial u}{\partial t}<br>= h^2 \left( \frac{\partial^2 u}{\partial x^2} +<br>\frac{\partial^2 u}{\partial y^2} +<br>\frac{\partial^2 u}{\partial z^2}\right)$$</p></li><li><p>$$lim_{1\to+\infty}P(|\frac{1}{n}\sum_i^nX_i-\mu|&lt;\epsilon)=1, i=1,…,n$$</p></li></ul></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.jianshu.com/p/7ab21c7f0674" target="_blank" rel="noopener">在Hexo中渲染MathJax数学公式</a></li><li><a href="https://segmentfault.com/a/1190000020123689?utm_source=tag-newest" target="_blank" rel="noopener">在Hexo中使用Markdown绘制图表</a></li><li><a href="https://blog.csdn.net/u014630987/article/details/78670258" target="_blank" rel="noopener">如何在 hexo 中支持 Mathjax？</a></li><li><a href="https://blog.csdn.net/crazy_scott/article/details/79293576" target="_blank" rel="noopener">hexo下LaTeX无法显示的解决方案</a></li></ul><script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">st=>start: Start|past:>http://www.google.com[blank]e=>end: End:>http://www.google.comop1=>operation: My Operation|pastop2=>operation: Stuff|currentsub1=>subroutine: My Subroutine|invalidcond=>condition: Yesor No?|approved:>http://www.google.comc2=>condition: Good idea|rejectedio=>inputoutput: catch something...|requestst->op1(right)->condcond(yes, right)->c2cond(no)->sub1(left)->op1c2(yes)->io->ec2(no)->op2->e</textarea><textarea id="flowchart-0-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景描述&quot;&gt;&lt;a href=&quot;#背景描述&quot; class=&quot;headerlink&quot; title=&quot;背景描述&quot;&gt;&lt;/a&gt;背景描述&lt;/h2&gt;&lt;p&gt;本文主要记录 Hexo 博客系统搭建过程，以及一些常用插件的集成和使用过程，后续会一直迭代更新。&lt;/p&gt;
    
    </summary>
    
    
      <category term="其他" scheme="https://dongzl.github.io/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="Hexo" scheme="https://dongzl.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>10-MySQL-InnoDB-Transaction</title>
    <link href="https://dongzl.github.io/2019/11/19/10-MySQL-InnoDB-Transaction/"/>
    <id>https://dongzl.github.io/2019/11/19/10-MySQL-InnoDB-Transaction/</id>
    <published>2019-11-19T11:08:31.000Z</published>
    <updated>2020-03-10T01:08:49.055Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景描述"><a href="#背景描述" class="headerlink" title="背景描述"></a>背景描述</h2><p>目前在维护的 APP 进行了整体重构（其实不能算重构，应该是重新开发），新的服务端系统根据业务场景进行了功能拆分，实现了微服务，结束了以前服务端大一统的部署模式；伴随着微服务的上线，分布式事务也成了一个绕不开的问题。最近的几篇文章计划结合目前项目中的分布式事务的代码实现逻辑，对数据库事务的知识进行系统的学习和整理，当然数据库事务方面的知识很多，所以肯定不是一篇文章可以搞定的，<strong>分布式</strong> 就是要 <strong>“分布试”</strong>。</p><p><strong>PS.数据库事务的知识有哪些，一起来整理一下，今天先以 MySQL 数据库 InnoDB 存储引擎为例，总结一下单数据库事务。</strong></p><a id="more"></a><h2 id="事务的ACID特性"><a href="#事务的ACID特性" class="headerlink" title="事务的ACID特性"></a>事务的ACID特性</h2><h3 id="A：原子性（Atomicity）"><a href="#A：原子性（Atomicity）" class="headerlink" title="A：原子性（Atomicity）"></a>A：原子性（Atomicity）</h3><p>事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。</p><h3 id="C：一致性（Consistency）"><a href="#C：一致性（Consistency）" class="headerlink" title="C：一致性（Consistency）"></a>C：一致性（Consistency）</h3><p>一致性指事务将数据库从一种状态转变为下一种一致的状态。在事务开始之前和事务结束之后，数据库的完整性约束没有被破坏。在一致性状态下，所有事务对一个数据的读取结果都是相同的。</p><h3 id="I：隔离性（Isolation）"><a href="#I：隔离性（Isolation）" class="headerlink" title="I：隔离性（Isolation）"></a>I：隔离性（Isolation）</h3><p>一个事务所做的修改在最终提交以前，对其它事务是不可见的。</p><h3 id="D：持久性（Durability）"><a href="#D：持久性（Durability）" class="headerlink" title="D：持久性（Durability）"></a>D：持久性（Durability）</h3><p>一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务的执行结果页不能丢失。</p><h2 id="事务的并发一致性问题"><a href="#事务的并发一致性问题" class="headerlink" title="事务的并发一致性问题"></a>事务的并发一致性问题</h2><h3 id="丢失更新"><a href="#丢失更新" class="headerlink" title="丢失更新"></a>丢失更新</h3><h4 id="第一类丢失更新"><a href="#第一类丢失更新" class="headerlink" title="第一类丢失更新"></a>第一类丢失更新</h4><p>一个事务（A）更新某条记录数据，此时还未提交，这时另外一个事务（B）也更新了该记录数据并提交事务成功，这时 A 撤销事务，此时 B 更新成功的数据会丢失。</p><table><thead><tr><th>时间</th><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td>T1</td><td>开启事务</td><td></td></tr><tr><td>T2</td><td></td><td>开启事务</td></tr><tr><td>T3</td><td>查询账户余额为 100</td><td></td></tr><tr><td>T4</td><td></td><td>查询账户余额为 100</td></tr><tr><td>T5</td><td></td><td>更新数据 + 10 结果为 110</td></tr><tr><td>T6</td><td></td><td>提交事务</td></tr><tr><td>T7</td><td>更新数据 - 10 结果为 90</td><td></td></tr><tr><td>T8</td><td>撤销事务</td><td></td></tr><tr><td>T7</td><td>数据恢复为100（丢失更新）</td><td></td></tr></tbody></table><h4 id="第二类丢失更新"><a href="#第二类丢失更新" class="headerlink" title="第二类丢失更新"></a>第二类丢失更新</h4><p>一个事务（A）更新某条记录数据，此时还未提交，这时另外一个事务（B）也更新了该记录数据并提交事务成功，此时 A 提交事务，此时 B 更新成功的数据会丢失。</p><table><thead><tr><th>时间</th><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td>T1</td><td>开启事务</td><td></td></tr><tr><td>T2</td><td></td><td>开启事务</td></tr><tr><td>T3</td><td>查询账户余额为100</td><td></td></tr><tr><td>T4</td><td></td><td>查询账户余额为100</td></tr><tr><td>T5</td><td></td><td>更新数据 - 10 结果为 90</td></tr><tr><td>T6</td><td></td><td>提交事务</td></tr><tr><td>T7</td><td>更新数据 + 10 结果 为 110</td><td></td></tr><tr><td>T8</td><td>提交事务</td><td></td></tr><tr><td>T7</td><td>数据结果为110（丢失更新）</td><td></td></tr></tbody></table><h3 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h3><p>脏读是指一个事务读取到了另外一个事务未提交的数据。一个事务正在对一条记录进行修改，在这个事务提交并完成前，这条记录的数据就处于不一致状态。这时， 另一个事务也来读取同一条记录，如果不加控制，第二个事务读取了这些“脏”数据，并据此做进一步的处理，就会产生未提交的数据依赖关系。</p><table><thead><tr><th>时间</th><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td>T1</td><td>开启事务</td><td></td></tr><tr><td>T2</td><td>查询账户余额为100</td><td>开启事务</td></tr><tr><td>T3</td><td>充值50，余额修改为150</td><td></td></tr><tr><td>T4</td><td></td><td>查询余额为150</td></tr><tr><td>T5</td><td>撤销事务，余额改回100</td><td></td></tr><tr><td>T6</td><td></td><td>汇入50，余额修改为200</td></tr><tr><td>T7</td><td></td><td>提交事务</td></tr></tbody></table><h3 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h3><p>不可重复读是指一个事务读取到了另外一个事务已提交的数据。一个事务（A）读取某一个数据后，另外一个事务（B）对该数据进行了修改，当 A 再读取这个数据时，发现前后两次读取的数据不一致。</p><table><thead><tr><th>时间</th><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td>T1</td><td>开启事务</td><td></td></tr><tr><td>T2</td><td>查询账户余额为100</td><td>开启事务</td></tr><tr><td>T3</td><td></td><td>更新账户余额为150</td></tr><tr><td>T4</td><td></td><td>提交事务</td></tr><tr><td>T5</td><td>查询账户余额为150</td><td></td></tr><tr><td>T6</td><td>…</td><td></td></tr><tr><td>T7</td><td>提交事务</td><td></td></tr></tbody></table><h3 id="幻读（幻影读）"><a href="#幻读（幻影读）" class="headerlink" title="幻读（幻影读）"></a>幻读（幻影读）</h3><p>一个事务（A）按某一条件检索到 N 条数据，另外一个事务（B）新增或删除了满足条件的数据，这时 A 再按相同条件检索数据，查询到的结果 != N。</p><table><thead><tr><th>时间</th><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td>T1</td><td>开启事务</td><td>开启事务</td></tr><tr><td>T2</td><td>select * from table where condition = ‘xxx’ 返回 N 条记录</td><td></td></tr><tr><td>T3</td><td></td><td>向 table 表插入一条满足 condition = ‘xxx’ 的数据</td></tr><tr><td>T4</td><td></td><td>提交事务</td></tr><tr><td>T5</td><td>select * from table where condition = ‘xxx’ 返回 N + 1 条记录</td><td></td></tr><tr><td>T6</td><td>…</td><td></td></tr><tr><td>T7</td><td>提交事务</td><td></td></tr></tbody></table><h3 id="总结说明"><a href="#总结说明" class="headerlink" title="总结说明"></a>总结说明</h3><ul><li><p>幻读和不可重复读的区别：</p><ul><li>不可重复读的重点是更新：在同一事务中，相同的条件，第一次和第二次读取到的数据不一致（中间有其它事务提交了更新）；</li><li>幻读的重点是新增或删除：在同一事务中，相同的条件，第一次和第二次读到的记录数据不一样（中间有其它事务提交了新增或者删除）。</li></ul></li><li><p>两类丢失更新问题：</p><ul><li>第一类丢失更新 （通过设置 <strong>Repeatable Read</strong> 隔离级别解决）</li><li>第二类丢失更新 （需要应用程序控制，使用乐观锁解决）</li></ul></li></ul><h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><p>SQL 标准定义了四种数据库事务的隔离级别，每一种级别中都规定了一个事务中所做的修改，哪些在事务内和事务间是可见的，哪些是不可见的。</p><ul><li>Read Uncommitted：所有事务都可以看到其它事务未提交的执行结果。</li><li>Read Committed（RC）：一个事务能够看到其它事务已提交的执行结果。</li><li>Repeatable Read（RR）：在一个事务内多次执行同一个查询操作，前后几次获取的结果相同。</li><li>Serializable：串行化，每次读都需要获得表级共享锁，读写相互阻塞。</li></ul><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>Read Uncommitted</td><td>YES</td><td>YES</td><td>YES</td></tr><tr><td>Read Committed</td><td>NO</td><td>YES</td><td>YES</td></tr><tr><td>Repeatable Read</td><td>NO</td><td>NO</td><td>YES</td></tr><tr><td>Serializable</td><td>NO</td><td>NO</td><td>NO</td></tr></tbody></table><p>四种数据库事务的隔离级别只是 SQL 标准的定义，对于不同的数据库也会有不同的实现，比如：Oracle 仅支持 Read Committed 和 Serializable 隔离级别，其中 Read Committed 是默认的隔离级别；对于 MySQL 支持 SQL 标准的四种隔离级别，其中 Repeatable Read 为默认的隔离级别。</p><p><a href="https://github.com/ctripcorp/apollo/wiki/Java%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97#1241-environment" target="_blank" rel="noopener">https://github.com/ctripcorp/apollo/wiki/Java%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97#1241-environment</a></p><p><a href="https://github.com/ctripcorp/apollo/wiki/Apollo%E5%BC%80%E6%94%BE%E5%B9%B3%E5%8F%B0" target="_blank" rel="noopener">https://github.com/ctripcorp/apollo/wiki/Apollo%E5%BC%80%E6%94%BE%E5%B9%B3%E5%8F%B0</a></p><p><a href="https://www.jianshu.com/p/03d1bf80f7e8" target="_blank" rel="noopener">https://www.jianshu.com/p/03d1bf80f7e8</a></p><p><a href="https://blog.csdn.net/z69183787/article/details/52213670" target="_blank" rel="noopener">https://blog.csdn.net/z69183787/article/details/52213670</a></p><p><a href="https://www.jianshu.com/p/592b2cdbc589" target="_blank" rel="noopener">https://www.jianshu.com/p/592b2cdbc589</a></p><p><a href="https://www.jianshu.com/p/d829df873332" target="_blank" rel="noopener">https://www.jianshu.com/p/d829df873332</a></p><p><a href="https://blog.csdn.net/weixin_28760063/article/details/81369266" target="_blank" rel="noopener">https://blog.csdn.net/weixin_28760063/article/details/81369266</a></p><p><a href="https://juejin.im/post/5b5a0bf9f265da0f6523913b" target="_blank" rel="noopener">https://juejin.im/post/5b5a0bf9f265da0f6523913b</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景描述&quot;&gt;&lt;a href=&quot;#背景描述&quot; class=&quot;headerlink&quot; title=&quot;背景描述&quot;&gt;&lt;/a&gt;背景描述&lt;/h2&gt;&lt;p&gt;目前在维护的 APP 进行了整体重构（其实不能算重构，应该是重新开发），新的服务端系统根据业务场景进行了功能拆分，实现了微服务，结束了以前服务端大一统的部署模式；伴随着微服务的上线，分布式事务也成了一个绕不开的问题。最近的几篇文章计划结合目前项目中的分布式事务的代码实现逻辑，对数据库事务的知识进行系统的学习和整理，当然数据库事务方面的知识很多，所以肯定不是一篇文章可以搞定的，&lt;strong&gt;分布式&lt;/strong&gt; 就是要 &lt;strong&gt;“分布试”&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;PS.数据库事务的知识有哪些，一起来整理一下，今天先以 MySQL 数据库 InnoDB 存储引擎为例，总结一下单数据库事务。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="https://dongzl.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库事务" scheme="https://dongzl.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/"/>
    
      <category term="ACID" scheme="https://dongzl.github.io/tags/ACID/"/>
    
  </entry>
  
  <entry>
    <title>从一个功能设计聊聊策略模式的使用</title>
    <link href="https://dongzl.github.io/2019/11/06/09-design-pattern-strategy/"/>
    <id>https://dongzl.github.io/2019/11/06/09-design-pattern-strategy/</id>
    <published>2019-11-06T08:25:58.000Z</published>
    <updated>2020-03-10T01:11:40.249Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景描述"><a href="#背景描述" class="headerlink" title="背景描述"></a>背景描述</h2><p>线上业务销售一种 VIP 虚拟卡，对于已售出的 VIP 虚拟卡在给供应商结算时需要根据销售渠道不同进行区分，例如，Android 端销售的虚拟卡按实际销售金额结算；iOS端销售的虚拟卡按实际销售金额 70% 结算（做苹果开发的都知道，苹果公司雁过拔毛，要拔走 30%）；还有就是可能与其他商品捆绑销售，捆绑销售的金额根据合作不同部门、不同商品金额都不同。目前情况即是如此，虚拟卡销售渠道很多，不同渠道结算金额不同，而且还会扩展（最近就在经历扩展，华为属于 Android 渠道，但是也开始玩苹果那套规则，拔 30% 的毛）。</p><p><strong>PS. 一句话需求，销售商品结算，不同销售渠道销售金额不同，而且随时会扩展新的渠道。</strong></p><a id="more"></a><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>如果设计模式玩溜了，对于这种业务场景，很容易想到使用策略（Strategy）模式来完成功能，所以这里也直接上代码实现：</p><h3 id="策略接口定义"><a href="#策略接口定义" class="headerlink" title="策略接口定义"></a>策略接口定义</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CalculateStrategy</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算金额</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> param 参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 计算结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">calculate</span><span class="params">(StrategyParam param)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="策略实现类"><a href="#策略实现类" class="headerlink" title="策略实现类"></a>策略实现类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Android 渠道结算策略</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AndroidVipOrderStrategy</span> <span class="keyword">implements</span> <span class="title">CalculateStrategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">calculate</span><span class="params">(StrategyParam param)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Order order = queryOrder(param);</span><br><span class="line">        <span class="keyword">return</span> order.getOnlineAmount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// iOS 渠道结算策略</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IOSVipOrderStrategy</span> <span class="keyword">implements</span> <span class="title">CalculateStrategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">calculate</span><span class="params">(StrategyParam param)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Order order = queryOrder(param);</span><br><span class="line">        <span class="keyword">return</span> order.getOnlineAmount * <span class="number">0.7</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 捆绑组合渠道结算策略</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BindVipOrderStrategy</span> <span class="keyword">implements</span> <span class="title">CalculateStrategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">calculate</span><span class="params">(StrategyParam param)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">199</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="策略Context类"><a href="#策略Context类" class="headerlink" title="策略Context类"></a>策略Context类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrategyContext</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> StrategyParam param;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StrategyContext</span><span class="params">(StrategyParam param)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.param = param;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">calculate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CalculateStrategy result = getStrategy();</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.calculate(param);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CalculateStrategy <span class="title">getStrategy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CalculateStrategy result = <span class="keyword">null</span>;</span><br><span class="line">        SourceTypeEnum type = SourceTypeEnum.valueOf(param.getVipSourceType());</span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">            <span class="keyword">case</span> ANDROID:</span><br><span class="line">                result = <span class="keyword">new</span> AndroidVipOrderStrategy();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> IOS:</span><br><span class="line">                result = <span class="keyword">new</span> IOSVipOrderStrategy();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> BIND:</span><br><span class="line">                result = <span class="keyword">new</span> BindVipOrderStrategy();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="客户端调用"><a href="#客户端调用" class="headerlink" title="客户端调用"></a>客户端调用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        StrategyParam param = <span class="keyword">new</span> StrategyParam();</span><br><span class="line">        System.out.println(<span class="keyword">new</span> StrategyContext(param).calculate());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类图描述"><a href="#类图描述" class="headerlink" title="类图描述"></a>类图描述</h3><img src="https://gitee.com/dongzl/article-images/raw/master/2019/09-design-pattern-strategy/Design_Pattern_Strategy_01.png" width="600px"><h2 id="观察者模式的四要素"><a href="#观察者模式的四要素" class="headerlink" title="观察者模式的四要素"></a>观察者模式的四要素</h2><h3 id="定义与动机"><a href="#定义与动机" class="headerlink" title="定义与动机"></a>定义与动机</h3><p><strong>定义：</strong> </p><p>策略模式（Strategy Pattern）：定义<strong>一系列算法</strong>，将<strong>每一个算法封装起来</strong>，并让他们可以<strong>相互替换</strong>。策略模式<strong>让算法独立于使用它的客户端而变化</strong>，也称为<strong>政策模式</strong>（Policy）。策略模式是一种<strong>对象行为型</strong>模式。</p><p>Strategy Pattern: Define <strong>a family of algorithms</strong>, <strong>encapsulate each one</strong>, and <strong>make them interchangeable</strong>. Strategy lets the algorithm vary independently from clients that use it.</p><p><strong>动机：</strong></p><p>完成一项任务，往往可以有很多种不同的方式，<font color="red">每一种方式称为一个策略</font>，我们<font color="red">可以根据环境或者条件的不同选择不同的策略来完成任务</font>。</p><p>为了解决这些问题，<font color="red">可以定义一些独立的类来封装不同的算法，每一个类封装一个具体的算法</font>。在这里，<font color="red">每一个封装算法的类我们都可以称之为策略（Strategy）</font>，为了保证这些策略的一致性，一般会用一个<font color="red">抽象的策略类来做算法的定义，而具体每种算法则对应于一个具体策略类</font>。</p><h3 id="结构与分析"><a href="#结构与分析" class="headerlink" title="结构与分析"></a>结构与分析</h3><p><strong>模式结构：</strong></p><p>类图：</p><img src="https://gitee.com/dongzl/article-images/raw/master/2019/09-design-pattern-strategy/Design_Pattern_Strategy_02.png" width="600px"><ul><li>Context封装角色：上下文角色，起承上启下封装作用，屏蔽高层模块对策略、算法的直接访问，封装可能存在的变化。</li><li>Strategy抽象策略角色：策略、算法家族的抽象，通常为接口，定义每个策略或算法必须具有的方法和属性。</li><li>ConcreteStratrgy具体策略角色：实现抽象策略中的操作，该类含有具体的算法。</li></ul><h3 id="优点-amp-缺点"><a href="#优点-amp-缺点" class="headerlink" title="优点 &amp; 缺点"></a>优点 &amp; 缺点</h3><p><strong>优点：</strong></p><ul><li>对“<strong>开闭原则</strong>”的完美支持，可以在不修改原有系统的基础上灵活的增加新的算法和行为；</li><li>策略模式<strong>提供了管理相关算法族的办法</strong>；</li><li>策略模式<strong>提供了可以替换继承关系的办法</strong>；</li><li>策略模式<strong>可以避免使用多重条件转移语句</strong>。</li></ul><p><strong>缺点：</strong></p><ul><li>客户端<strong>必须知道所有的策略类</strong>；</li><li>策略模式<strong>将产生很多策略类</strong>。</li></ul><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>可以在以下情况中选择使用粗略模式：</p><ul><li>如果在一个系统里面有很多类，<strong>它们之间的区别仅在于它们的行为</strong>，那么使用策略模式可以动态的让一个对象在许多行为中选择一种行为。</li><li>一个系统<strong>需要动态地在几种算法中选择一种</strong>。</li><li>如果<strong>一个对象有很多的行为</strong>，如果不用恰当的模式，这些行为就只好使用<strong>多重的条件选择语句</strong>来实现。</li><li>不希望客户端知道复杂的、与算法相关的数据结构，<strong>在具体策略类中封装算法和相关的数据结构</strong>，提高算法的保密性与安全性。</li></ul><h2 id="策略模式的扩展-枚举策略"><a href="#策略模式的扩展-枚举策略" class="headerlink" title="策略模式的扩展-枚举策略"></a>策略模式的扩展-枚举策略</h2><h3 id="枚举类定义"><a href="#枚举类定义" class="headerlink" title="枚举类定义"></a>枚举类定义</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> CalculateStrategy &#123;</span><br><span class="line"></span><br><span class="line">    ANDROID_VIP_ORDER &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">calculate</span><span class="params">(StrategyParam param)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            Order order = queryOrder(param);</span><br><span class="line">            <span class="keyword">return</span> order.getOnlineAmount;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    IOS_VIP_ORDER &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">calculate</span><span class="params">(StrategyParam param)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            Order order = queryOrder(param);</span><br><span class="line">            <span class="keyword">return</span> order.getOnlineAmount * <span class="number">0.7</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    BINDVIPORDER &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">calculate</span><span class="params">(StrategyParam param)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">199</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算金额</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> param 参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 计算结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Integer <span class="title">calculate</span><span class="params">(StrategyParam param)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Client调用类"><a href="#Client调用类" class="headerlink" title="Client调用类"></a>Client调用类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Integer result = CalculateStrategy.ANDROID_VIP_ORDER.calculate(<span class="keyword">new</span> StrategyParam());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://mp.weixin.qq.com/s/VSjVx5kf-Rc7QifEs4xf6A" target="_blank" rel="noopener">业务复杂=if else？刚来的大神竟然用策略+工厂彻底干掉了他们！</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景描述&quot;&gt;&lt;a href=&quot;#背景描述&quot; class=&quot;headerlink&quot; title=&quot;背景描述&quot;&gt;&lt;/a&gt;背景描述&lt;/h2&gt;&lt;p&gt;线上业务销售一种 VIP 虚拟卡，对于已售出的 VIP 虚拟卡在给供应商结算时需要根据销售渠道不同进行区分，例如，Android 端销售的虚拟卡按实际销售金额结算；iOS端销售的虚拟卡按实际销售金额 70% 结算（做苹果开发的都知道，苹果公司雁过拔毛，要拔走 30%）；还有就是可能与其他商品捆绑销售，捆绑销售的金额根据合作不同部门、不同商品金额都不同。目前情况即是如此，虚拟卡销售渠道很多，不同渠道结算金额不同，而且还会扩展（最近就在经历扩展，华为属于 Android 渠道，但是也开始玩苹果那套规则，拔 30% 的毛）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;PS. 一句话需求，销售商品结算，不同销售渠道销售金额不同，而且随时会扩展新的渠道。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="https://dongzl.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://dongzl.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="策略模式" scheme="https://dongzl.github.io/tags/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>GRIT：一种微服务场景下分布式事务协议实现</title>
    <link href="https://dongzl.github.io/2019/10/29/08-GRIT-Microservices-Distributed-Transactions-Protocol/"/>
    <id>https://dongzl.github.io/2019/10/29/08-GRIT-Microservices-Distributed-Transactions-Protocol/</id>
    <published>2019-10-29T01:42:47.000Z</published>
    <updated>2020-03-10T02:16:01.100Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文链接：<a href="https://tech.ebayinc.com/engineering/grit-a-protocol-for-distributed-transactions-across-microservices/" target="_blank" rel="noopener">https://tech.ebayinc.com/engineering/grit-a-protocol-for-distributed-transactions-across-microservices/</a></p></blockquote><blockquote><p>eBay 技术人员最近发布了一种称为 <code>GRIT</code> 分布式事务协议，该协议是为了解决跨多个底层数据库的微服务场景下分布式 ACID（原子性，一致性，隔离性，持久性）事务问题。</p></blockquote><p>本文描述了在 <strong>IEEE国际数据工程会议(ICDE) 2019</strong> 上发布的 GRIT 协议的基本思想，<font color="red">并且提供了一个 JanusGraph 事务性存储后端的示例，该示例实现了 GRIT 协议的一部分功能</font>。这个示例关注的是仅有单一数据库的应用，但是正如我们所说，GRIT 可以支持由多个数据库组成的系统的 ACID 事务。</p><a id="more"></a><h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>在 <a href="https://en.wikipedia.org/wiki/Microservices" target="_blank" rel="noopener">微服务</a> 架构中，应用程序可能会调用很多个微服务，通常这些微服务是用不同编程语言实现并且由不同的团队来维护，而且可能会使用多个数据库来实现微服务的功能。这种目前流行的架构为跨多个微服务的一致性分布式事务带来了新的挑战。支持微服务场景下的 ACID 事务是有实际需要的，但是在现有技术下实现起来是非常困难的，因为被设计用于单个数据库的分布式事务机制无法通过微服务架构轻松扩展到具有多个数据库的情况。</p><p>在涉及多个独立数据库的运行环境中，传统的两阶段提交（2PC）协议[1]从本质上来说是唯一一种能够实现分布式事务功能而不会给应用系统带来额外工作量的方式。然而，由于可能存在多个协调参与者而导致的较长调用链路以及在各个阶段所需要的资源锁定，所以它在横向扩展平台中工作的并不好。另一方面，引入第三方框架[2]（例如：Saga）执行事务日志的方式将导致应用程序产生复杂的事务补偿逻辑；并且由于已经部分执行成功的事务有可能是不可逆的，所以会对业务逻辑产生影响。</p><p>为了解决这些问题，我们开发了 <a href="https://ieeexplore.ieee.org/abstract/document/8731442" target="_blank" rel="noopener">GRIT</a>，一种用于全局一致性分布式事务的新协议，这个协议巧妙地结合了乐观并发控制（OCC）[3]、2PC 和 确定性数据库[4,5]的思想，首次实现了高性能，跨多个基础数据库微服务的全局一致性事务。</p><h2 id="GRIT-一种分布式事务协议实现"><a href="#GRIT-一种分布式事务协议实现" class="headerlink" title="GRIT: 一种分布式事务协议实现"></a>GRIT: 一种分布式事务协议实现</h2><p>下图描述了 GRIT 协议在两个数据库的微服务环境中的使用。GRIT 组件中包含了在图中中间部分显示的 GTM、GPL、DBTM、DBTL 和 LogPlayer 等组件。</p><img src="https://gitee.com/dongzl/article-images/raw/master/2019/08-GRIT-Microservices-Distributed-Transactions-Protocol/GRIT-Protocol-for-Distributed-Transactions-across-Microservices6.png"><p>图中除去 GRIT 相关组件，剩余部分是一个横向扩展的两个数据库组成的微服务架构系统。它包括如下组成部分：</p><ol><li>应用程序：调用微服务来实现相关功能。</li><li>微服务（实体服务）：为应用程序提供面向业务的服务以实现业务逻辑的功能模块。每个数据库可能要支持多个微服务，并且每个微服务可能彼此都是独立的。</li><li>数据库服务：提供数据库 <code>读/写</code> 接口，可以直接访问数据库服务器。当支持事务时，它会缓存每次事务在执行阶段数据的 <code>读/写结果集</code>，并在提交时将其发送到 DBTM 用于解决冲突。</li><li>数据库分片服务：数据库后台的存储服务，通过复制机制实现数据库高可用。</li></ol><p>GRIT 包含的关键组件：</p><ol><li>全局事务管理器（GTM）：它用来协调跨多个数据库的全局事务。可以同时存在一个或多个 GTM。</li><li>全局事务日志（GTL）：对于 GTM 来说，GTL 表示事务的请求队列。GTL 中事务的请求顺序决定了全局事务之间的相对可串行化顺序。全局事务日志数据的持久化是可选的。</li><li>数据库事务管理器（DBTM）：DBTM 是每个数据库内部的事务管理器。它用来执行冲突检查并解决冲突问题，即本地事务提交就是在这里完成。</li><li>数据库事务日志（DBTL）：DBTL 是每个数据库内部的事务日志，它用于记录与此数据库相关逻辑事务提交（包括单个数据库事务和多个数据库事务）。在 DBTL 中事务的顺序决定了整个数据库应用的可串行化顺序，包括 GTM 所保证的全局顺序。需要为每个日志条目分配一个日志序列号（LSN）。</li><li>日志播放器（LogPlayer）：这个组件将用于更新数据的日志条目按顺序发送到后端存储服务器。每一个数据库服务按顺序使用日志条目数据进行逻辑事务提交。</li></ol><p>为了更好的理解 GRIT 协议的实现细节，我们用下图来演示分布式事务的主要步骤：</p><img src="https://gitee.com/dongzl/article-images/raw/master/2019/08-GRIT-Microservices-Distributed-Transactions-Protocol/GRIT-main-steps2.png"><p>在 GRIT 中，一个分布式事务要经历三个步骤：</p><ol><li>乐观执行（步骤 1-4）：应用程序通过调用微服务来执行业务逻辑，数据库服务捕捉事务的 <code>读/写结果集</code>。在这个环节没有实际的数据修改发生。</li><li>逻辑提交（步骤 5-11）：一旦应用程序发送提交事务请求，每一个数据库服务节点将 <code>读/写结果集</code> 提交到它对应的 DBTM。DBTM 使用 <code>读/写结果集</code> 进行冲突检查，以实现本地提交决策。GTM 在收集到所有 DBTM 对事务的本地决策之后，做出全局提交决策。一旦事务的 <code>写结果集</code> 被持久化到所对应的数据库的日志存储（DBTL）中，事务就会进行逻辑提交。这涉及到 GTM 和 DBTM 之间的最小协调。</li><li>物理应用（步骤 12-13）：日志播放器异步发送 DBTL 条目到后端存储服务器。数据修改发生在这个阶段。</li></ol><p>总体来说，我们的方案避免了执行和提交过程中的悲观锁定，同时避免了物理提交等待。我们采用乐观锁的方案，通过利用逻辑提交日志，并使用确定性数据库技术将物理数据库更新操作从提交决策过程中移出，使提交过程更加高效，这类似于复制中的日志播放。</p><p>GRIT 能够为调用微服务的应用程序实现一致性的高吞吐量和可串行化的分布式事务，并保证最小范围协调性。GRIT 非常适合冲突较少的事务，并为那些需要复杂机制以在具有多个底层数据库的微服务之间实现一致性事务的应用程序提供了关键功能。</p><h2 id="在单一数据库中应用-GRIT"><a href="#在单一数据库中应用-GRIT" class="headerlink" title="在单一数据库中应用 GRIT"></a>在单一数据库中应用 GRIT</h2><p>正如你所了解到的，GRIT 协议包含两部分：<font color="red">其中一部分是用于 DBTM、DBTL 和 LogPlayer 操作的，这是每个数据库（或是每个数据库内部，可以是数据库的一组分区）提供的；另外一部分是用于 GTM 和 DBTM 操作的跨数据库协调。</font>在下图中，我们演示了使用了单个数据库的 GRIT 部分协议为 <a href="https://janusgraph.org/" target="_blank" rel="noopener">JanusGraph</a> 设计的事务图形存储后端（称为 NuGraphStore）。</p><p>下图显示了如何使用两个可用区域（AZ1 和 AZ2）部署来实现 NuGraphStore。</p><img src="https://gitee.com/dongzl/article-images/raw/master/2019/08-GRIT-Microservices-Distributed-Transactions-Protocol/GRIT-Protocol-for-Distributed-Transactions-across-Microservices4.png"><p>JanusGraph 的 NuGraphStore 存储后端包含了以下几个组件：</p><ul><li>存储插件（Storage plugin）：一个自定义的存储接口插件，用于 JanusGraph 数据库层、后端存储引擎和事务协议组件之间的接口。</li><li>DBTM：为乐观并发控制提供关键地冲突检查。这是分布式事务协议 <a href="https://ieeexplore.ieee.org/abstract/document/8731442" target="_blank" rel="noopener">GRIT</a> 在单个数据库乐观并发控制中的组成部分。</li><li>日志存储：事务中的变更数据的复制日志存储。每个事务一个条目，由日志序列号（LSN）索引。它在传统数据系统中充当 WAL（预写日志）角色。LogStore 就是 GRIT 架构中的 DBTL 部分。</li><li>LogPlayer：在后端服务器中异步的执行日志条目。</li><li>存储引擎：用于存储 JanusGraph 中的KCV（键-列-值）数据的后端存储引擎。它执行读取和变更操作，并支持 LSN 定义的快照。</li></ul><p>当一个应用程序执行事务时，它可以从存储层读取数据，也可以向存储层写入数据。对于读取数据操作，存储插件直接和存储服务器进行交互（要读取的数据在事务的 <code>写结果集</code> 这种情况除外）。当应用程序在事务上下文环境中从存储层读取数据时，存储插件也会对 <code>读结果集</code> 进行追踪。每次读取中有用信息的是 &lt;key, lsn&gt; 键值对，其中 LSN 是反映读取键值时存储引擎状态的日志序列号。LSN 是一个事务中变更数据的日志索引条目。它由 LogStore 来分配，被设计用于后端数据库的快照。没有被查询到的 key 同样被记录成 <code>读结果集</code> 的一部分。和读操作不同，在写操作中，存储插件不会直接和存储服务器交互。相反，存储插件会为事务缓存它对应的 <code>写结果集</code> 中的写操作。</p><p>当事务提交之时，存储插件将提交请求以及为事务捕获的 <code>读/写结果集</code> 提交到 DBTM。DBTM 为 OCC 执行事务的标准冲突检查。如果没有冲突，它将把 <code>写结果集</code> 持久化到复制的日志存储（即它将 <code>写结果集</code> 发送到日志存储副本集，因此所有副本都保持完全相同的日志）此时，事务就完成了逻辑提交，DBTM 会向存储插件返回响应结果信息。日志播放器跟踪日志存储，并根据数据分布将日志条目播放到后端分片服务器。</p><p>值得指出的是，上面描述的内容只是一个基本设计，还有很多机会来提高它的性能和可用性。我们相信，在跨组件进行优化或使用 DBTM 的复制来实现更高的可靠性之前，使基础组件成熟稳定是更富有成效的。当然，还有很多不同的方式来捕捉 <code>读/写结果集</code>。对于一个键值存储，我们需要的最简单进行冲突检测的方式就是 &lt;key, lsn&gt; 键值对。然而，为了支持更复杂的系统应用，<code>读结果集</code> 可能是一定范围或者是限定条件的数据，正如这篇文章内描述的。[6]在本文撰稿时，NuGraphStore 也正在进行开源。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] C. Mohan, Bruce Lindsay and R. Obermarck, “Transaction management in the R* distributed database management system” ACM Transactions on Database Systems (TODS), Volume 11 Issue 4, Dec. 1986, Pages 378 - 396.</p><p>[2] Pat Helland, “Life beyond Distributed Transactions: an Apostate’s Opinion”, CIDR 2007. </p><p>[3] H.T. Kung, J.T. Robinson, “On Optimistic Methods for Concurrency Control”, ACM Transactions on Database Systems 6:2, June, 1981.</p><p>[4] Thomson, Alexander and Diamond, Thaddeus and Shao, Philip and Ren, Kun and Weng, Shu-Chun and Abadi, Daniel J, “Calvin: Fast distributed transactions for partitioned database systems”, SIGMOD 2012.</p><p>[5] Kun Ren, Alexander Thomson, Daniel Abadi, “An Evaluation of the Advantages and Disadvantages of Deterministic Database Systems”, VLDB 2014.</p><p>[6] Thomas Neumann, Tobias Mühlbauer, Alfons Kemper, “Fast Serializable Multi-Version Concurrency Control for Main-Memory Database Systems”, SIGMOD 2015</p><h2 id="GRIT-a-Protocol-for-Distributed-Transactions-across-Microservices"><a href="#GRIT-a-Protocol-for-Distributed-Transactions-across-Microservices" class="headerlink" title="GRIT: a Protocol for Distributed Transactions across Microservices"></a>GRIT: a Protocol for Distributed Transactions across Microservices</h2><blockquote><p>eBay technologists recently showed off a distributed transaction protocol called GRIT, for distributed ACID (atomicity, consistency, isolation, durability) transactions across microservices with multiple underlying databases.</p></blockquote><p>This article describes the basic ideas of the GRIT protocol, which was announced at the IEEE International Conference on Data Engineering (ICDE) 2019, and provides an example of using part of the protocol for implementing a transactional storage backend for JanusGraph. This example focuses on a system with only a single database, but as we said, GRIT can support ACID transactions for systems consisting of multiple databases.</p><h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><p>In a <a href="https://en.wikipedia.org/wiki/Microservices" target="_blank" rel="noopener">microservice</a> architecture, an application may invoke multiple microservices, which are usually implemented in different application languages by different teams and may use multiple underlying databases to achieve their functionality. This popular architecture brings new challenges for consistent distributed transactions across multiple microservices. It is a real requirement to support ACID transactions in the context of microservices, but is very hard to achieve using existing technologies, since distributed transaction mechanisms designed for a single database cannot be easily extended to the cases with multiple databases through microservices.</p><p>In environments that involve multiple independent databases, the traditional two-phase commit (2PC) protocol[1] was essentially the only option for distributed transactions by the system without additional application effort. However, it does not work well in a scale-out platform due to long paths of potentially many coordinating participants and the locking required over the phases. On the other hand, using a transaction log executed by a framework[2] such as Saga will incur complex compensating logic by applications and may have business implications due to irreversible partially successful transactions. </p><p>To address these issues, we developed <a href="https://ieeexplore.ieee.org/abstract/document/8731442" target="_blank" rel="noopener">GRIT</a>, a novel protocol for globally consistent distributed transactions that cleverly combines ideas from optimistic concurrency control (OCC)[3], 2PC, and deterministic databases[4,5] to achieve, for the first time, high-performance, globally consistent transactions across microservices with multiple underlying databases.</p><h2 id="GRIT-a-protocol-for-distributed-transactions"><a href="#GRIT-a-protocol-for-distributed-transactions" class="headerlink" title="GRIT: a protocol for distributed transactions"></a>GRIT: a protocol for distributed transactions</h2><p>The following diagram illustrates the GRIT protocol in a system of microservices with two databases. The GRIT components, including GTM, GTL, DBTM, DBTL, and LogPlayer, are shown in the center.</p><img src="https://tech.ebayinc.com/assets/Uploads/Editor/GRIT-Protocol-for-Distributed-Transactions-across-Microservices6.png"><p>Without the GRIT components, the diagram represents a system of plain microservice architecture with two scale-out databases. They consist of the following:</p><ol><li>Applications: invoke microservices to achieve their functionality.</li><li>Microservices (Entity Services): building blocks to provide business-oriented service for applications to implement business logic. Each DB may have support for multiple microservices, and each microservice is likely independent of the other.</li><li>DB Services: provide DB read/write interface and directly access DB servers. When supporting transactions, it also caches the read/write results of each transaction during the execution phase and sends them to its DBTM for conflict resolution at commit time.</li><li>DB shard servers: the backend storage servers for the database, usually replicated for high availability.</li></ol><p>The key components of GRIT include:</p><ol><li>Global Transaction Manager (GTM): It coordinates global transactions across multiple databases. There can be one or more GTMs.</li><li>Global Transaction Log (GTL): It represents the transaction request queue for a GTM. The order of transaction requests in a GTL determines the relative serializability order among global transactions. Persistence of GTLs is optional.</li><li>Database Transaction Manager (DBTM): The transaction manager at each database realm. It performs the conflict checking and resolution, i.e. local commit decision is located here.</li><li>Database Transaction Log (DBTL): The transaction log at each database realm that logs logically committed transactions that relate to this database (including single database transactions and multi-database transactions). The order of transactions in a DBTL determines the serializability order of the whole database system, including the global order dictated by the GTM. A log sequence number (LSN) is assigned to each log entry.</li><li>LogPlayer: This component sends log entries, in sequence, to the backend storage servers for them to apply the updates. Each DB server applies log entries of logically committed transactions in order.</li></ol><p>For the purpose of understanding the details of the protocol, we use the following diagram to show the main steps for a distributed transaction.</p><img src="https://tech.ebayinc.com/assets/Uploads/Editor/GRIT-main-steps2.png"><p>In GRIT, a distributed transaction goes through three phases:</p><ol><li>Optimistic execution (steps 1-4): As the application is executing the business logic via microservices, the database services capture the read-set and write-set of the transaction. No actual data modification occurs at this phase.</li><li>Logical commit (steps 5-11): Once the application requests the transaction commit, the read-set and write-set at each database service point are submitted to its DBTM. The DBTM uses the read-set and write-set for conflict checking to achieve local commit decision. The GTM will make the global commit decision after collecting all the local decisions of DBTMs for the transaction. A transaction is logically committed once its write-sets are persisted in log stores (DBTLs) for databases involved. This involves minimum coordination between the GTM and the DBTMs.</li><li>Physical apply (steps 12-13): The log players asynchronously sends DBTL entries to backend storage servers. The data modification occurs at this phase.</li></ol><p>Overall, our approach avoids pessimistic locking during both execution and commit process and avoids waiting for physical commit. We take the optimistic approach and also make the commit process very efficient by leveraging logical commit logs and moving the physical database changes out of the commit decision process with deterministic database technology, which is similar to log play in replication.</p><p>GRIT is able to achieve consistent high throughput and serializable distributed transactions for applications invoking microservices with minimum coordination. GRIT fits well for transactions with few conflicts and provides a critical capability for applications that otherwise need complex mechanisms to achieve consistent transactions across microservices with multiple underlying databases.</p><h2 id="Applying-GRIT-for-a-single-database"><a href="#Applying-GRIT-for-a-single-database" class="headerlink" title="Applying GRIT for a single database"></a>Applying GRIT for a single database</h2><p>As you can see, the GRIT protocol contains two parts: one for each database (or each database realm, which can be a set of partitions of a database) performed by DBTM, DBTL, and LogPlayer, and the other for cross-database coordination by GTM and DBTMs. In the following diagram, we illustrate the design of a transactional graph store backend (called NuGraphStore) for <a href="https://janusgraph.org/" target="_blank" rel="noopener">JanusGraph</a> using the part of GRIT protocol for a single database.</p><p>The following diagram shows how NuGraphStore is implemented with two availability zone (AZ1 and AZ2) deployment for illustration.</p><p>GRIT Protocol for Distributed Transactions across Microservices4</p><img src="https://tech.ebayinc.com/assets/Uploads/Editor/GRIT-Protocol-for-Distributed-Transactions-across-Microservices4.png"><p>There are a few components involved in the NuGraphStore backend for JanusGraph:</p><ul><li>Storage plugin: a custom storage interface plugin to interface between the JanusGraph DB Layer and the backend storage engine and transaction protocol components.</li><li>DBTM: performs the critical conflict checking for optimistic concurrency control. This is part of the <a href="https://ieeexplore.ieee.org/abstract/document/8731442" target="_blank" rel="noopener">GRIT</a> distributed transaction protocol on single databases performing OCC.</li><li>LogStore: replicated log store for mutations from transactions. One entry for each transaction, indexed by Log Sequence Number (LSN). It acts as a WAL (write-ahead-log) in traditional database systems. The LogStore is the DBTL in our GRIT architecture. </li><li>LogPlayer: applies log entries to the backend servers asynchronously.</li><li>Storage engine: backend storage engine to store KCV (Key-Column-Value) data from JanusGraph. It performs reads and mutations and supports snapshots defined by the LSN.</li></ul><p>As an application is performing a transaction, it can read from the store and write to the store. For the read operations, the storage plugin directly communicates with the storage servers (except for reads that are found in the write-set for the transaction). The storage plugin also keeps track of the read-set as the application is reading from the store in the context of a transaction. The useful information for each read is the &lt;key, lsn&gt; pair, where lsn is the log sequence number reflecting the storage engine state when the key-value is read. An LSN is the log index of the entry for the mutations of a transaction. It is assigned by the LogStore and used to define the snapshot of the backend databases. A key being not found is also recorded as part of the read-set. Unlike reads, the storage plugin for writes does not directly communicate with the storage servers. Instead, the storage plugin buffers the writes in the corresponding write-set for the transaction.</p><p>When a transaction commits, the storage plugin submits the commit request with the read-set and write-set it has captured for the transaction to the DBTM. The DBTM performs the standard conflict checking for OCC for the transaction. If there is no conflict, it will persist the write-set to the replicated LogStore (i.e., it sends the write-set to the LogStore replica set, so all the replicas keep the exact same log). At this point, the transaction commit completes logically, and the DBTM responds back to the storage plugin. The LogPlayers tail the LogStores and play the log entries to the backend shard servers based on the data distribution.</p><p>It’s worth pointing out that the above description is a basic design with many opportunities to enhance for performance and reliability. It’s our belief that it is more productive to make the basic components mature before optimizing across the components or using replication for DBTM to achieve higher reliability. Also, there are different ways that we can capture the read-set and write-set. For a KV store, the simplest form we need for conflict checking is &lt;key, lsn&gt; pairs. To support more complex systems, however, the read-set may include ranges, or predicates, as described in.[6] As of this writing, NuGraphStore is going through the open source process.</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p>[1] C. Mohan, Bruce Lindsay and R. Obermarck, “Transaction management in the R* distributed database management system” ACM Transactions on Database Systems (TODS), Volume 11 Issue 4, Dec. 1986, Pages 378 - 396.</p><p>[2] Pat Helland, “Life beyond Distributed Transactions: an Apostate’s Opinion”, CIDR 2007. </p><p>[3] H.T. Kung, J.T. Robinson, “On Optimistic Methods for Concurrency Control”, ACM Transactions on Database Systems 6:2, June, 1981.</p><p>[4] Thomson, Alexander and Diamond, Thaddeus and Shao, Philip and Ren, Kun and Weng, Shu-Chun and Abadi, Daniel J, “Calvin: Fast distributed transactions for partitioned database systems”, SIGMOD 2012.</p><p>[5] Kun Ren, Alexander Thomson, Daniel Abadi, “An Evaluation of the Advantages and Disadvantages of Deterministic Database Systems”, VLDB 2014.</p><p>[6] Thomas Neumann, Tobias Mühlbauer, Alfons Kemper, “Fast Serializable Multi-Version Concurrency Control for Main-Memory Database Systems”, SIGMOD 2015</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;https://tech.ebayinc.com/engineering/grit-a-protocol-for-distributed-transactions-across-microservices/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://tech.ebayinc.com/engineering/grit-a-protocol-for-distributed-transactions-across-microservices/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;eBay 技术人员最近发布了一种称为 &lt;code&gt;GRIT&lt;/code&gt; 分布式事务协议，该协议是为了解决跨多个底层数据库的微服务场景下分布式 ACID（原子性，一致性，隔离性，持久性）事务问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文描述了在 &lt;strong&gt;IEEE国际数据工程会议(ICDE) 2019&lt;/strong&gt; 上发布的 GRIT 协议的基本思想，&lt;font color=&quot;red&quot;&gt;并且提供了一个 JanusGraph 事务性存储后端的示例，该示例实现了 GRIT 协议的一部分功能&lt;/font&gt;。这个示例关注的是仅有单一数据库的应用，但是正如我们所说，GRIT 可以支持由多个数据库组成的系统的 ACID 事务。&lt;/p&gt;
    
    </summary>
    
    
      <category term="架构设计" scheme="https://dongzl.github.io/categories/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="GRIT" scheme="https://dongzl.github.io/tags/GRIT/"/>
    
      <category term="distributed transaction" scheme="https://dongzl.github.io/tags/distributed-transaction/"/>
    
  </entry>
  
  <entry>
    <title>记一次 Wireshark 抓包 Sharding-Proxy 过程</title>
    <link href="https://dongzl.github.io/2019/10/23/07-Wireshark-Sharding-Proxy/"/>
    <id>https://dongzl.github.io/2019/10/23/07-Wireshark-Sharding-Proxy/</id>
    <published>2019-10-23T09:39:35.000Z</published>
    <updated>2020-03-10T02:10:23.222Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景描述"><a href="#背景描述" class="headerlink" title="背景描述"></a>背景描述</h2><p>最近在在参与 <a href="http://shardingsphere.apache.org/" target="_blank" rel="noopener">Apache ShardingSphere</a> 开源项目的一些工作，在 Github 的 <a href="https://github.com/apache/incubator-shardingsphere/issues" target="_blank" rel="noopener">issue 列表</a> 认领了一个问题 <a href="https://github.com/apache/incubator-shardingsphere/issues/3005" target="_blank" rel="noopener">#3005</a>。</p><p>产品描述：首先简单介绍一下 ShardingSphere 中的一个产品 Sharding-Proxy，Sharding-Proxy 产品的功能是做一个透明的中间层代理，后面连接很多的 MySQL 数据库（可能是很多分库后 MySQL 数据库）。用户在使用中可以不用直接连到真实 MySQL 数据库上，而是连接到 Sharding-Proxy 上，通过这个工具再连接到真实的数据库上。</p><a id="more"></a><p>这个过程对于用户应该是无感知的（所以才叫透明的中间层代理），可以像使用 MySQL 一样使用 Sharding-Proxy，例如通过一些工具，像 MySQL JDBC 驱动或者是客户端工具（Navicat、MySQL Workbench）直接使用 Sharding-Proxy，所以 Sharding-Proxy 需要对 MySQL 协议进行解析和封装。对于客户端发送请求，Sharding-Proxy 解析后重新封装发送给 MySQL 服务器，对于 MySQL 服务器响应数据需要解析后重新封装发送给客户端，这个过程要做到精确，才能实现<code>透明的中间层代理</code>的效果。</p><p>认领的 issue 中的问题现象是，Navicat 直接连到 MySQL 服务器打开数据表没有问题，而通过 Sharding-Proxy 代理连接后再打开数据表，就会提示 <font color="#FF0000"> There is no primary key here. Update will only use exact matching of the old values of the columns here. Thus, it may update more than one record. </font> 这个错误，虽然对于使用是没有影响的，但是依然没有做到完全透明。</p><h2 id="Wireshark-软件使用"><a href="#Wireshark-软件使用" class="headerlink" title="Wireshark 软件使用"></a>Wireshark 软件使用</h2><p>对于 Navicat 这种客户端工具，其实是通过网络连接方式连接管理远端数据库，所以一定要走网络协议。所以对于这个问题，首先想到的办法就是通过网络抓包的方式对比一下两种连接方式返回的数据差别。网络抓包好像是有这么个工具 <strong>Wireshark</strong>，对于这个工具只闻名未曾谋面过，果断安装，百度了一下简单实用。</p><p>启动软件后，出现一堆网卡，可能是装虚拟机导致出现了好多虚拟网卡吧，不过大部分网卡没有数据流量。</p><img src="https://gitee.com/dongzl/article-images/raw/master/2019/07-Wireshark-Sharding-Proxy/Wireshark_Sharding-Proxy_01.png" width="600px"><p>首先是 <strong>Wi-Fi: en0</strong> 网卡，进去之后列表一堆数据，直接刷屏，根本看不出有效信息，毫无头绪。</p><p>这个时候发现还有一个 <strong>Loopback: lo0</strong> 网卡，应该是 <strong>环回地址（127.0.0.1）</strong>，这个可能有点意思，因为 MySQL、Sharding-Proxy 和 Navicat 都装在本地开发环境，正常情况不会有真正的网络通信，都是本地搞定。</p><p>进入 <strong>Loopback: lo0</strong> 网卡，看到的就是 <strong>Wireshark</strong> 抓取的网络请求的数据了，其实第一次用，现学现卖，使用不是很流畅，不过还是百度大概了解到了一些使用技巧，首先 <strong>Wireshark</strong> 可以使用很多过滤器，过滤出我们比较感兴趣的网络请求数据，比如根据协议抓取数据，根据请求端口抓取数据进行区分。</p><p>在这个首先想到的是 MySQL 数据库使用的端口是 3306，Sharing-Proxy 使用的端口是 3307，还有就是 MySQL 有自己的应用层协议，协议名字就是：MySQL。</p><h2 id="Wireshark-抓取-MySQL-协议数据"><a href="#Wireshark-抓取-MySQL-协议数据" class="headerlink" title="Wireshark 抓取 MySQL 协议数据"></a>Wireshark 抓取 MySQL 协议数据</h2><p>首先使用 Navicat 直接连到 MySQL 数据库上，在 Wireshark 软件中只过滤 MySQL 协议的网络数据请求：</p><img src="https://gitee.com/dongzl/article-images/raw/master/2019/07-Wireshark-Sharding-Proxy/Wireshark_Sharding-Proxy_02.png" width="600px"><p>Wireshark 还是很强大，很直观的。每一次的 Request 请求，紧跟着是是配对的 Response 响应数据。其中在 Request 请求中 <strong>MySQL Protocol</strong> 中显示了 Navicat 客户端发送给 MySQL 数据库的命令：<strong>SHOW VARIABLES LIKE ‘lower_case_%’</strong>；在 Response 相应的 <strong>MySQL Protocol</strong> 中显示了 MySQL 数据库发送给 Navicat 客户端的相应结果数据，通过上面的操作和观察，至少能大概明白简单的使用方式了。</p><h2 id="Wireshark-抓包数据对比"><a href="#Wireshark-抓包数据对比" class="headerlink" title="Wireshark 抓包数据对比"></a>Wireshark 抓包数据对比</h2><p>Wireshark 大概使用是明白了，现在需要看的就是 Navicat 直连 MySQL和 Navicat 通过 Sharing-Proxy 代理连接 MySQL 到底数据的请求响应过程到底有什么不同了。抓取同一个请求命令在两种不同情况下相应结果数据的差别，理论上来说这就应该是我们排查问题的方向，当然方向是否正确，还需要实操验证。</p><h3 id="Navicat-直连-MySQL-抓包"><a href="#Navicat-直连-MySQL-抓包" class="headerlink" title="Navicat 直连 MySQL 抓包"></a>Navicat 直连 MySQL 抓包</h3><p>根据 Navicat 的提示，只有在查询表数据表的时候会提示错误，所以问题大概应该出现在 select 查询语句的请求 &amp; 相应数据上，我们抓取了一张表的 select 语句数据：</p><img src="https://gitee.com/dongzl/article-images/raw/master/2019/07-Wireshark-Sharding-Proxy/Wireshark_Sharding-Proxy_04.png" width="600px"><p>对于查询的这张数据表，其实 id 字段就是主键，主键是一定存在的，我们看一下返回结果中有关 id 字段的描述信息：</p><img src="https://gitee.com/dongzl/article-images/raw/master/2019/07-Wireshark-Sharding-Proxy/Wireshark_Sharding-Proxy_05.png" width="600px"><p>其中有 <strong>Flags</strong> 属性展开后就是一串标志位，通过实际内容大概就能明白就是标识该字段的一些特殊属性信息：</p><img src="https://gitee.com/dongzl/article-images/raw/master/2019/07-Wireshark-Sharding-Proxy/Wireshark_Sharding-Proxy_06.png" width="600px"><h3 id="Navicat-连接-Sharding-Proxy-抓包"><a href="#Navicat-连接-Sharding-Proxy-抓包" class="headerlink" title="Navicat 连接 Sharding-Proxy 抓包"></a>Navicat 连接 Sharding-Proxy 抓包</h3><p>由于 Sharding-Proxy 底层是直接使用 Netty 实现网络连接，使用 TCP 协议，并且监听的端口号是 3307，所以我们在使用 Wireshark 抓包时可以采用端口号过滤的方式过滤网络请求数据：</p><blockquote><p>tcp.srcport==3307 || tcp.dstport==3307</p></blockquote><p>我们还是抓取了相同一条 select 语句的请求相应数据，由于是直接抓取 TCP 协议包数据，无法像抓取 MySQL 协议数据那样直观了，只能通过二进制数据看出大概样子：</p><p>select 请求数据：</p><img src="https://gitee.com/dongzl/article-images/raw/master/2019/07-Wireshark-Sharding-Proxy/Wireshark_Sharding-Proxy_07.png" width="600px"><p>Sharding-Proxy 相应结果：</p><img src="https://gitee.com/dongzl/article-images/raw/master/2019/07-Wireshark-Sharding-Proxy/Wireshark_Sharding-Proxy_08.png" width="600px"><h2 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h2><p>仔细分析抓取的数据结果，其实还是能看到一些差别的，不过 Sharding-Proxy 抓取到的结果不是很直观，还是给结果分析带来一定困难的，还是直接上结论吧：</p><img src="https://gitee.com/dongzl/article-images/raw/master/2019/07-Wireshark-Sharding-Proxy/Wireshark_Sharding-Proxy_09.png" width="600px"><img src="https://gitee.com/dongzl/article-images/raw/master/2019/07-Wireshark-Sharding-Proxy/Wireshark_Sharding-Proxy_10.png" width="600px"><p>分析的结果可以看出，Navicat 工具直连 MySQL 数据库时执行的 select 查询语句中返回的 <code>Flags</code> 信息标志位二进制数据为 <code>03 50</code>，标识该字段为 <code>Not null</code> 和 <code>Primary key</code>；但是 Navicat 连接 Sharding-Proxy 代理后返回的数据中该标志位二进制位 <code>00 00</code>，其实到这里，结果就很明显了，Sharding-Proxy 返回的数据中 <code>Flags</code> 信息缺失，而该数据正式判断该数据是否为主键、是否允许为null等等信息的一种标识。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>其实，现在记录整个内容过程感觉很简单，其实过程并不容易，有些分析其实就是 <strong>经验 + 运气</strong>，而且可能运气的成分还要多一些，不过整个过程下来还是给自己增长很多知识的，不过确实要说一句：<strong>Wireshark 是个很不错的软件，以后要多学习、常使用，应用好了事半功倍</strong>。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.cnblogs.com/lsdb/p/9254544.html" target="_blank" rel="noopener">Wireshark使用教程</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景描述&quot;&gt;&lt;a href=&quot;#背景描述&quot; class=&quot;headerlink&quot; title=&quot;背景描述&quot;&gt;&lt;/a&gt;背景描述&lt;/h2&gt;&lt;p&gt;最近在在参与 &lt;a href=&quot;http://shardingsphere.apache.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Apache ShardingSphere&lt;/a&gt; 开源项目的一些工作，在 Github 的 &lt;a href=&quot;https://github.com/apache/incubator-shardingsphere/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;issue 列表&lt;/a&gt; 认领了一个问题 &lt;a href=&quot;https://github.com/apache/incubator-shardingsphere/issues/3005&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;#3005&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;产品描述：首先简单介绍一下 ShardingSphere 中的一个产品 Sharding-Proxy，Sharding-Proxy 产品的功能是做一个透明的中间层代理，后面连接很多的 MySQL 数据库（可能是很多分库后 MySQL 数据库）。用户在使用中可以不用直接连到真实 MySQL 数据库上，而是连接到 Sharding-Proxy 上，通过这个工具再连接到真实的数据库上。&lt;/p&gt;
    
    </summary>
    
    
      <category term="架构设计" scheme="https://dongzl.github.io/categories/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="Wireshark" scheme="https://dongzl.github.io/tags/Wireshark/"/>
    
      <category term="ShardingSphere" scheme="https://dongzl.github.io/tags/ShardingSphere/"/>
    
  </entry>
  
  <entry>
    <title>从一个业务场景聊聊 ZooKeeper 队列使用</title>
    <link href="https://dongzl.github.io/2019/10/19/06-ZooKeeper-Distributed-Queue/"/>
    <id>https://dongzl.github.io/2019/10/19/06-ZooKeeper-Distributed-Queue/</id>
    <published>2019-10-19T09:03:49.000Z</published>
    <updated>2020-03-10T01:43:44.010Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景描述"><a href="#背景描述" class="headerlink" title="背景描述"></a>背景描述</h2><p>目前在做的 APP 客户端有个业务场景，对于登录的新用户需要做一些操作，例如初始化用户账户信息，给该新用户发放一些优惠，比如发放优惠券、赠送经验积分等等。对于这种场景一般很容易想到使用消息队列（MQ），但是考虑到目前的业务场景，每天新增的用户并不多，如果引入专门的消息队列框架（例如：RocketMQ、RabbitMQ）等感觉比较重，意义并不是很大。</p><p><strong>PS. 一句话需求，新增登录用户模块要实现功能解耦，用户登录与新用户业务逻辑功能分开，想到使用消息队列机制，但是不想引入重量级 MQ 框架。</strong></p><a id="more"></a><p>通过调研，发现利用 ZooKeeper + Curator 是可以实现分布式队列类似的效果的，同时预研使用 ZooKeepr + Curator 实现了该功能，这一篇文章对 ZooKeepr + Curator 实现队列机制的一个总结。</p><h2 id="ZooKeeper-队列实现原理"><a href="#ZooKeeper-队列实现原理" class="headerlink" title="ZooKeeper 队列实现原理"></a>ZooKeeper 队列实现原理</h2><h3 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h3><p>为了在 ZooKeeper 中实现分布式队列，需要设计一个 ZNode 节点来存放数据，这个节点是<code>队列节点</code>，例如：<code>/app_name/first_login_user</code>。生产者向队列中存放数据，每一个消息数据都是<code>队列节点</code>下的一个新节点，我们称作<code>消息节点</code>。消息节点的命名规则为：queue-xxxx，其中 xxxx 是一个单调递增序列，从 ZooKeeper 内部存储结构来说，其实就是创建<code>持久顺序（PERSISTENT_SEQUENTIAL）</code>类型节点来实现。这样，生产者不断的在队列节点下创建消息节点，消息节点数据存储为：queue-xxxx，这就是生产者端的实现原理。</p><h3 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h3><p>消费者从队列中获取数据是通过 <code>getChildren()</code> 方法获取到<code>队列节点</code>中的所有<code>消息节点</code>，然后获取消息节点中存储数据，处理业务逻辑，并删除<code>消息节点</code>。 如果 <code>getChildren()</code> 没有获取到节点数据，说明队列是空的，则消费者进入等待状态，同时调用 <code>getChildren()</code> 方法设置观察者监听队列节点，队列节点发生变化后（消息节点变更），触发监听事件，唤起消费者。</p><img src="https://gitee.com/dongzl/article-images/raw/master/2019/06-ZooKeeper-Distributed-Queue/ZooKeeper-Distributed-Queue.png" width="600px"><h2 id="Curator-框架队列实现"><a href="#Curator-框架队列实现" class="headerlink" title="Curator 框架队列实现"></a>Curator 框架队列实现</h2><h3 id="DistributedQueue"><a href="#DistributedQueue" class="headerlink" title="DistributedQueue"></a>DistributedQueue</h3><blockquote><p>Distributed Queue - An implementation of the Distributed Queue ZK recipe. Items put into the queue are guaranteed to be ordered (by means of ZK’s PERSISTENTSEQUENTIAL node). If a single consumer takes items out of the queue, they will be ordered FIFO. If ordering is important, use a LeaderSelector to nominate a single consumer.</p></blockquote><p><code>Distributed Queue - ZK 的 分布式队列实现。添加到队列中的元素是可以保证顺序性的（通过 ZK 的 PERSISTENT SEQUENTIAL 节点类型实现）。如果只有单一消费者从队列中获取元素，可以保证以 FIFO 顺序消费元素。如果顺序性是非常重要的，可以通过 LeaderSelector 方式只选举出一个消费者。</code></p><p>数据存储格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">queue-0000000001</span><br><span class="line">queue-0000000002</span><br><span class="line">queue-0000000003</span><br><span class="line">queue-0000000004</span><br><span class="line">... ...</span><br><span class="line">queue-0000000098</span><br><span class="line">queue-0000000099</span><br><span class="line">queue-0000000100</span><br></pre></td></tr></table></figure><p>使用方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 核心类</span></span><br><span class="line">org.apache.curator.framework.recipes.queue.DistributedQueue;</span><br><span class="line">org.apache.curator.framework.recipes.queue.QueueBuilder;</span><br><span class="line">org.apache.curator.framework.recipes.queue.QueueConsumer;</span><br><span class="line">org.apache.curator.framework.recipes.queue.QueueSerializer;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Builder 实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">QueueBuilder&lt;T&gt; <span class="title">builder</span><span class="params">(CuratorFramework client, QueueConsumer&lt;T&gt; consumer, QueueSerializer&lt;T&gt; serializer, String queuePath)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parameters:</span><br><span class="line">   client - Curator 客户端</span><br><span class="line">   consumer - 接收消息消费者</span><br><span class="line">   serializer - 元素序列化工具</span><br><span class="line">   queuePath - 存储队列数据路径</span><br><span class="line"></span><br><span class="line"><span class="comment">// DistributedQueue 实现</span></span><br><span class="line">DistributedQueue&lt;String&gt; queue = QueueBuilder.builder(client, consumer, createQueueSerializer(), PATH).buildQueue();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者</span></span><br><span class="line">queue.put(aMessage);</span><br></pre></td></tr></table></figure><h3 id="DistributedIdQueue"><a href="#DistributedIdQueue" class="headerlink" title="DistributedIdQueue"></a>DistributedIdQueue</h3><blockquote><p>Distributed Id Queue - A version of DistributedQueue that allows IDs to be associated with queue items. Items can then be removed from the queue if needed.</p></blockquote><p><code>Distributed Id Queue - 允许 ID 与队列元素关联的 DistributedQueue 版本实现。如果有需要可以根据 ID 删除元素。</code></p><p>数据存储格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">queue-|id-1|0000000001</span><br><span class="line">queue-|id-2|0000000002</span><br><span class="line">queue-|id-3|0000000003</span><br><span class="line">queue-|id-4|0000000004</span><br><span class="line">... ...</span><br><span class="line">queue-|id-98|0000000098</span><br><span class="line">queue-|id-99|0000000099</span><br><span class="line">queue-|id-100|0000000100</span><br><span class="line"></span><br><span class="line">数据格式：</span><br><span class="line">queue-|itemId|节点顺序</span><br></pre></td></tr></table></figure><p>使用方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 核心类</span></span><br><span class="line">org.apache.curator.framework.recipes.queue.DistributedIdQueue;</span><br><span class="line">org.apache.curator.framework.recipes.queue.QueueBuilder;</span><br><span class="line">org.apache.curator.framework.recipes.queue.QueueConsumer;</span><br><span class="line">org.apache.curator.framework.recipes.queue.QueueSerializer;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DistributedIdQueue 实现</span></span><br><span class="line">DistributedIdQueue&lt;String&gt; queue = QueueBuilder.builder(client, consumer, createQueueSerializer(), PATH).buildIdQueue();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者</span></span><br><span class="line">queue.put(aMessage, itemId);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以根据 itemId 移除元素</span></span><br><span class="line"><span class="keyword">int</span> numberRemoved = queue.remove(itemId);</span><br></pre></td></tr></table></figure><h3 id="DistributedPriorityQueue"><a href="#DistributedPriorityQueue" class="headerlink" title="DistributedPriorityQueue"></a>DistributedPriorityQueue</h3><blockquote><p>Distributed Priority Queue - An implementation of the Distributed Priority Queue ZK recipe.</p></blockquote><p><code>Distributed Priority Queue - 分布式优先级队列的 ZK 实现。</code></p><p>数据存储格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">queue-10000001F0000000001</span><br><span class="line">queue-1000000140000000002</span><br><span class="line">queue-10000004F0000000003</span><br><span class="line">queue-10000000F0000000004</span><br><span class="line">... ...</span><br><span class="line">queue-1000000570000000098</span><br><span class="line">queue-10000003C0000000099</span><br><span class="line">queue-10000003C0000000100</span><br><span class="line"></span><br><span class="line">数据格式：</span><br><span class="line">queue-(priority &gt;= 0 ? &quot;1&quot; : &quot;0&quot;) + [(priority &amp; 4294967295L) 16进制] + 节点顺序</span><br></pre></td></tr></table></figure><p>使用方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 核心类</span></span><br><span class="line">org.apache.curator.framework.recipes.queue.DistributedPriorityQueue;</span><br><span class="line">org.apache.curator.framework.recipes.queue.QueueBuilder;</span><br><span class="line">org.apache.curator.framework.recipes.queue.QueueConsumer;</span><br><span class="line">org.apache.curator.framework.recipes.queue.QueueSerializer;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DistributedPriorityQueue 实现</span></span><br><span class="line">DistributedPriorityQueue&lt;String&gt; queue = QueueBuilder.builder(client, consumer, createQueueSerializer(), PATH).buildPriorityQueue(minItemsBeforeRefresh);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者</span></span><br><span class="line">queue.put(aMessage, priority);</span><br></pre></td></tr></table></figure><h3 id="DistributedDelayQueue"><a href="#DistributedDelayQueue" class="headerlink" title="DistributedDelayQueue"></a>DistributedDelayQueue</h3><blockquote><p>Distributed Delay Queue - An implementation of a Distributed Delay Queue.</p></blockquote><p><code>Distributed Delay Queue - 分布式延迟队列实现。</code></p><p>数据存储格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">queue-|16DE33C4F8D|0000000001</span><br><span class="line">queue-|16DE33C4F8D|0000000002</span><br><span class="line">queue-|16DE33C4F8D|0000000003</span><br><span class="line">queue-|16DE33C4F8D|0000000004</span><br><span class="line">... ...</span><br><span class="line">queue-|16DE33C4F8E|0000000098</span><br><span class="line">queue-|16DE33C4F8E|0000000099</span><br><span class="line">queue-|16DE33C4F8E|0000000100</span><br><span class="line"></span><br><span class="line">数据格式：</span><br><span class="line">queue-|delayUntilEpoch 8位16进制|节点顺序</span><br></pre></td></tr></table></figure><p>使用方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 核心类</span></span><br><span class="line">org.apache.curator.framework.recipes.queue.DistributedPriorityQueue;</span><br><span class="line">org.apache.curator.framework.recipes.queue.QueueBuilder;</span><br><span class="line">org.apache.curator.framework.recipes.queue.QueueConsumer;</span><br><span class="line">org.apache.curator.framework.recipes.queue.QueueSerializer;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DistributedPriorityQueue 实现</span></span><br><span class="line">DistributedDelayQueue&lt;String&gt; queue = QueueBuilder.builder(client, consumer, createQueueSerializer(), PATH).buildDelayQueue();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者</span></span><br><span class="line">queue.put(aMessage, delayUntilEpoch);</span><br></pre></td></tr></table></figure><h3 id="SimpleDistributedQueue"><a href="#SimpleDistributedQueue" class="headerlink" title="SimpleDistributedQueue"></a>SimpleDistributedQueue</h3><blockquote><p>Simple Distributed Queue - A drop-in replacement for the DistributedQueue that comes with the ZK distribution.</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 核心类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SimpleDistributedQueue</span><span class="params">(CuratorFramework client, String path)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 入队</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(<span class="keyword">byte</span>[] data)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 出队，移除头部元素并返回该元素，会阻塞。</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">byte</span>[] <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span></span><br></pre></td></tr></table></figure><h2 id="系统实现"><a href="#系统实现" class="headerlink" title="系统实现"></a>系统实现</h2><p>业务系统中是采用 <code>DistributedQueue</code> 的实现，首先在用户登录成功后向 ZooKeeper 的固定节点下写入 <code>PERSISTENT_SEQUENTIAL</code> 数据，写入后直接返回，不阻塞用户登录操作；在另外的线程中消费 <code>DistributedQueue</code> 队列中数据，直接按顺序获取节点数据，开始进行业务逻辑处理。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>对于使用 ZooKeeper 实现的分布式消息队列，需要注意一些问题。首先，对于使用 ZooKeeper 实现的队列这件事情本身，Curator 的官方文档就是不推荐的：</p><p><strong>IMPORTANT - We recommend that you do NOT use ZooKeeper for Queues. Please see <a href="https://cwiki.apache.org/confluence/display/CURATOR/TN4" target="_blank" rel="noopener">Tech Note 4</a> for details.</strong></p><p>ZooKeeper 的使用手册页面列举了一些 ZooKeeper 作为队列的使用场景。Curator 包括了几种队列的实现方式，以我们的经验，使用 ZooKeeper 作为消息队列是一个糟糕的选择：</p><ul><li>ZooKeeper 有 1MB 的传输限制。 实践中 ZNode 必须相对较小，而队列包含成千上万的消息，可能非常的大；</li><li>如果有很多节点，ZooKeeper 启动时相当的慢。而使用队列需要创建很多 ZNode 节点，所以在使用中需要显著调大 initLimit 和 syncLimit 参数值；</li><li>当某个 ZNode 很大的时候会很难清理，同时调用这个节点的 <code>getChildren()</code> 方法会失败；</li><li>当出现大量的包含成千上万的子节点的 ZNode 时，ZooKeeper 的性能会急剧下降；</li><li>ZooKeeper 的数据完全存放在内存中，如果有大量的队列消息会占用很多的内存空间。</li></ul><p>虽然从官方文档上来看，并不推荐使用 ZooKeeper 作为消息队列载体，但这是在大量消息的队列使用场景下，对于小规模的队列场景，例如我们新登录用户场景，一天也就几百个消息，其实也是没有问题的，之所谓<code>一切脱离业务谈技术架构都是耍流氓</code>。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://ifeve.com/zookeeper%EF%BC%8Dcurator/" target="_blank" rel="noopener">跟着实例学习ZooKeeper的用法： 队列</a></li><li><a href="https://www.cnblogs.com/boboooo/p/9259306.html" target="_blank" rel="noopener">Zookeeper应用之——队列（Queue）</a></li><li><a href="http://curator.apache.org/curator-recipes/index.html" target="_blank" rel="noopener">Curator - Recipes</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景描述&quot;&gt;&lt;a href=&quot;#背景描述&quot; class=&quot;headerlink&quot; title=&quot;背景描述&quot;&gt;&lt;/a&gt;背景描述&lt;/h2&gt;&lt;p&gt;目前在做的 APP 客户端有个业务场景，对于登录的新用户需要做一些操作，例如初始化用户账户信息，给该新用户发放一些优惠，比如发放优惠券、赠送经验积分等等。对于这种场景一般很容易想到使用消息队列（MQ），但是考虑到目前的业务场景，每天新增的用户并不多，如果引入专门的消息队列框架（例如：RocketMQ、RabbitMQ）等感觉比较重，意义并不是很大。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;PS. 一句话需求，新增登录用户模块要实现功能解耦，用户登录与新用户业务逻辑功能分开，想到使用消息队列机制，但是不想引入重量级 MQ 框架。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="架构设计" scheme="https://dongzl.github.io/categories/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="ZooKeeper" scheme="https://dongzl.github.io/tags/ZooKeeper/"/>
    
      <category term="Curator" scheme="https://dongzl.github.io/tags/Curator/"/>
    
      <category term="Queue" scheme="https://dongzl.github.io/tags/Queue/"/>
    
  </entry>
  
  <entry>
    <title>从一个功能设计聊聊观察者模式的使用</title>
    <link href="https://dongzl.github.io/2019/10/11/01-design-pattern-observer/"/>
    <id>https://dongzl.github.io/2019/10/11/01-design-pattern-observer/</id>
    <published>2019-10-11T03:06:46.000Z</published>
    <updated>2020-03-10T01:11:49.704Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景描述"><a href="#背景描述" class="headerlink" title="背景描述"></a>背景描述</h2><p>对接公司电商商城系统，接收订单完成 MQ 消息内容，需要根据订单完成数据实现自己业务部门的一些功能，例如：用户下单满多少金额发放某个礼品；过滤订单中有某个 SKU 的商品需要给用户免费绑定虚拟会员服务等等一些功能。</p><p><strong>PS.一句话需求，根据订单 MQ 消息，执行一些特殊业务逻辑处理，业务场景比较杂，逻辑分支比较多，而且随时会新增、撤销某些业务功能。</strong></p><a id="more"></a><h2 id="目前实现"><a href="#目前实现" class="headerlink" title="目前实现"></a>目前实现</h2><h3 id="老系统实现分析"><a href="#老系统实现分析" class="headerlink" title="老系统实现分析"></a>老系统实现分析</h3><p>这个类似的功能在老的系统是存在，以前系统中直接在一个 class 的方法中处理所有的逻辑，只是每个业务场景单独一个 Service，在主类中依赖所有的 Service，然后开始顺序执行所有的逻辑，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestObserver</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> AService aService;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> BService bService;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> CService cService;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 处理A场景业务</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            aService.dealBusiness(message);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">"Deal A Business exception -&gt; "</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理B场景业务</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            bService.dealBusiness(message);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">"Deal B Business exception -&gt; "</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理C场景业务</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            cService.dealBusiness(message);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">"Deal C Business exception -&gt; "</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码实现角度来说，其实是整齐划一的，所以虽然这个代码几千行，但是改起来没难度，不过这种实现方式不能算是优秀的：</p><ul><li>首先接收到一个消息，顺序执行，前后执行是阻塞的，A 没执行完，B、C 都会等待，万一某个逻辑处理很慢，后面逻辑都会受影响；</li><li>大段代码不好维护的，从面向对象的五个基本原则之 <code>开闭原则</code> 来说，类要对扩展开放，对修改关闭，这个类明显不符合。</li></ul><h3 id="新系统实现分析"><a href="#新系统实现分析" class="headerlink" title="新系统实现分析"></a>新系统实现分析</h3><p>新系统开发之后，对这个功能做了优化，目标是一定要改变这种在一个 class 中执行所有业务逻辑的实现，至少满足 <code>开闭原则</code>。<br>对于这种等待接收 MQ 处理各种业务逻辑的场景，直接想到了使用<code>观察者模式（Observer）</code>尝试一下：</p><ul><li>各种业务逻辑类注册为 Observer（观察者）；</li><li>接收 MQ 消息的主类为 Observable（被观察者）。</li></ul><p>各个业务逻辑类注册监听主类，主类在接收到 MQ 消息后通知所有的业务逻辑类，每一种业务都可以注册成为一个单独的 Observer，新增一种业务时就新增一个 Observer。</p><p>如果我们这么分析，好像的确是满足观察者模式的要求的，而且还可以满足 <code>开闭原则</code>，不知道这么分析是不是很牵强。</p><p>JDK + Spring 实现的观察者模式：</p><p>JDK 自带观察者模式实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 订单完成 MQ 被观察者 Observable</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderCompleteMqObservable</span> <span class="keyword">extends</span> <span class="title">Observable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册监听器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> observers</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addObservers</span><span class="params">(List&lt;Observer&gt; observers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(observers)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"observers is not null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Observer observer : observers) &#123;</span><br><span class="line">            <span class="keyword">this</span>.addObserver(observer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理业务逻辑</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message MQ消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dealBusiness</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        setChanged();</span><br><span class="line">        notifyObservers(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 订单完成观察者 Observer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AServiceMqObserver</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Observable o, Object arg)</span> </span>&#123;</span><br><span class="line">        String message = (String) arg;</span><br><span class="line">        <span class="comment">// Deal A Service Business</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BServiceMqObserver</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Observable o, Object arg)</span> </span>&#123;</span><br><span class="line">        String message = (String) arg;</span><br><span class="line">        <span class="comment">// Deal B Service Business</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 Spring 配置文件方式，实现 Observable 和 Observer 依赖关系解耦：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 订单完成监听-被观察者 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"orderCompleteMqObservable"</span> <span class="attr">class</span>=<span class="string">"com.abc.mq.order.observe.OrderCompleteMqObservable"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 订单完成监听-观察者 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"aServiceMqObserver"</span> <span class="attr">class</span>=<span class="string">"com.abc.mq.order.observe.AServiceMqObserver"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bServiceMqObserver"</span> <span class="attr">class</span>=<span class="string">"com.abc.mq.order.observe.BServiceMqObserver"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--反射方法调用--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.beans.factory.config.MethodInvokingFactoryBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"targetObject"</span> <span class="attr">ref</span>=<span class="string">"orderCompleteMqObservable"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"targetMethod"</span> <span class="attr">value</span>=<span class="string">"addObservers"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"arguments"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"aServiceMqObserver"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"bServiceMqObserver"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="观察者模式的四要素"><a href="#观察者模式的四要素" class="headerlink" title="观察者模式的四要素"></a>观察者模式的四要素</h2><h3 id="定义与动机"><a href="#定义与动机" class="headerlink" title="定义与动机"></a>定义与动机</h3><p><strong>定义：</strong> </p><p>观察者模式（Observer Pattern）：定义对象间的一种<code>一对多依赖关系</code>，使得每当<code>一个对象状态发生改变</code>时，其相关<code>依赖对象皆得到通知并被自动更新</code>。(Define a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.)</p><p>观察者模式又叫做<code>发布-订阅（Publish/Subscribe）</code>模式、<code>模型-视图（Model/View）</code>模式、<code>源-监听器（Source/Listener）</code>模式或<code>从属者（Dependents）</code>模式。观察者模式是一种<code>对象行为型</code>模式。</p><p><strong>动机：</strong></p><p>建立一种<font color="#FF0000">对象与对象之间的依赖关系</font>，一个对象发生改变时将自动通知其他对象，其他对象将相应做出反应。在此，发生改变的对象称为<font color="#FF0000">观察目标</font>，而被通知的对象称为<font color="#FF0000">观察者</font>，<font color="#FF0000">一个观察目标可以对应多个观察者</font>，而且这些观察者之间没有相互联系，可以根据需要<font color="#FF0000">增加和删除</font>观察者，使得系统更易于扩展，这就是观察者模式的模式动机。</p><h3 id="结构与分析"><a href="#结构与分析" class="headerlink" title="结构与分析"></a>结构与分析</h3><p><strong>模式结构：</strong></p><p>类图：</p><img src="https://gitee.com/dongzl/article-images/raw/master/2019/01-design-pattern-observer/Design-Pattern-Observer-01.png" width="600px"><p>角色：</p><ul><li>Subject：抽象主题（被观察者）角色把所有对观察者对象的引用保存在一个集合（比如 ArrayList 集合）里，每个主题都可以有任何数量的观察者，抽象主题提供一个接口，可以增加和删除观察者对象，抽象主题角色又叫做抽象被观察者（Observable）角色；</li><li>ConcreteSubject：具体主题（具体被观察者）将有关状态存入具体观察者对象，在具体主题的内部状态改变时，给所有登记过的观察者发出通知，具体主题角色又叫做具体被观察者（Concrete Observable）角色；</li><li>Observer：抽象观察者，为所有的具体观察者定义一个接口，在得到主题的通知时更新自己，这个接口叫做更新接口；</li><li>ConcreteObserver：具体观察者，存储与主题的状态匹配的状态，具体观察者角色实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题的状态协调，如果需要，具体观察者角色可以保持一个指向具体主题对象的引用。</li></ul><p>JDK 对观察者模式的扩展：</p><img src="https://gitee.com/dongzl/article-images/raw/master/2019/01-design-pattern-observer/Design-Pattern-Observer-03.png" width="600px"><p><a href="https://gitee.com/dongzl/article-images/raw/master/2019/01-design-pattern-observer/Design-Pattern-Observer-03.png" target="_blank" rel="noopener">https://gitee.com/dongzl/article-images/raw/master/2019/01-design-pattern-observer/Design-Pattern-Observer-03.png</a></p><p><strong>时序图：</strong></p><img src="https://gitee.com/dongzl/article-images/raw/master/2019/01-design-pattern-observer/Design-Pattern-Observer-02.png" width="600px"><h3 id="优点-amp-缺点"><a href="#优点-amp-缺点" class="headerlink" title="优点 &amp; 缺点"></a>优点 &amp; 缺点</h3><p><strong>优点：</strong></p><ul><li>表示层和数据逻辑层的分离；</li><li>观察者和被观察者之间建立了一个抽象的耦合；</li><li>支持广播通信；</li><li>符合“开闭原则”。</li></ul><p><strong>缺点：</strong></p><ul><li>如果一个观察目标对象有很多直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间；</li><li>如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃；</li><li>观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化（<font color="#FF0000">对于 JDK 中自带的观察者模式的实现，应该没有这个问题，观察者可以知道被观察的目标发生的变化</font>）。</li></ul><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li>一个抽象模型有两个方面，其中<strong>一个方面依赖于另一个方面</strong>，将这些方面<strong>封装在独立的对象中使它们可以各自独立地改变和复用</strong>；</li><li><strong>一个对象的改变将导致其他一个或多个对象也发生改变</strong>，而不知道<strong>具体有多少对象将发生改变</strong>，可以降低对象之间的耦合度；</li><li><strong>一个对象必须通知其他对象，而并不知道这些对象是谁</strong>；</li><li>需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种<strong>链式触发机制</strong>。</li></ul><h2 id="观察者模式-amp-推拉模型"><a href="#观察者模式-amp-推拉模型" class="headerlink" title="观察者模式 &amp; 推拉模型"></a>观察者模式 &amp; 推拉模型</h2><h3 id="推模型"><a href="#推模型" class="headerlink" title="推模型"></a>推模型</h3><p>被观察者对象（主题对象）向观察者对象推送主题的详细信息，不管观察者是否需要，推送的信息通常是主题的全部或部分数据。</p><p>我们前面讲解的观察者模式的实现就是典型的 <code>推模型</code>。</p><h3 id="拉模型"><a href="#拉模型" class="headerlink" title="拉模型"></a>拉模型</h3><p>被观察者对象（主题对象）在通知观察者的时候，只传递少量信息。如果观察者需要更具体的信息，由观察者主动到主题对象中获取，相当于是观察者从主题对象中拉数据。一般这种模型的实现中，会把主题对象自身通过 <code>update()</code> 方法传递给观察者，这样在观察者需要获取数据的时候，就可以通过这个引用来获取了。</p><img src="https://gitee.com/dongzl/article-images/raw/master/2019/01-design-pattern-observer/Design_Pattern_Observer_04.png" width="600px"><h3 id="推模型-vs-拉模型"><a href="#推模型-vs-拉模型" class="headerlink" title="推模型 vs 拉模型"></a>推模型 vs 拉模型</h3><ul><li>推模型实现前提被观察者对象（主题对象）知道观察者需要什么数据，所以只传递数据；拉模型可能是主题对象不知道观察者需要什么样的数据，所以只能把自身传递过去，观察者根据自身需要到主题对象中拉取数据；</li><li>推模型可能使观察者对象无法复用，因为推模型传递给观察者的是已经定义好的数据，一旦新的观察者要求不同格式数据，就需要重新定义 <code>update()</code> 方法；而拉模型就不会造成这样的情况，因为拉模型下，<code>update()</code> 方法的参数是主题对象本身，这基本上是主题对象能传递的最大数据集合了，基本上可以适应各种情况的需要。</li><li><code>JDK</code> 中的观察者模式采用的推模型，但是在 <code>update(Observable o, Object arg)</code> 方法中定义了两个参数，不仅传递了数据内容，也将被观察者对象（主题对象）本身传递给了观察者。 </li></ul><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>通过观察者模式，目前主要能解决的是<code>解耦问题</code>，不同的业务逻辑定义不同的观察者，防止在一个类中堆积大段逻辑代码，符合代码设计的 <code>开闭原则</code>，但是这里仍然有一个问题没有解决，就是不同业务代码的顺序执行问题，<code>JDK</code> 中观察者模式 <code>notifyObservers()</code> 方法的实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">(Object arg)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Object[] arrLocal;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!changed)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        arrLocal = obs.toArray();</span><br><span class="line">        clearChanged();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = arrLocal.length-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">        ((Observer)arrLocal[i]).update(<span class="keyword">this</span>, arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实也是通过 <code>for</code> 循环依次调用集合中的观察者的 <code>update()</code> 方法，所以这里使用观察者模式还是没有解决某个业务代码执行时间较长导致后面业务代码阻塞无法执行的问题。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/51357583" target="_blank" rel="noopener">观察者模式 vs 发布订阅模式</a></li><li><a href="https://www.cnblogs.com/KongkOngL/p/6849859.html" target="_blank" rel="noopener">Java设计模式の观察者模式（推拉模型）</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景描述&quot;&gt;&lt;a href=&quot;#背景描述&quot; class=&quot;headerlink&quot; title=&quot;背景描述&quot;&gt;&lt;/a&gt;背景描述&lt;/h2&gt;&lt;p&gt;对接公司电商商城系统，接收订单完成 MQ 消息内容，需要根据订单完成数据实现自己业务部门的一些功能，例如：用户下单满多少金额发放某个礼品；过滤订单中有某个 SKU 的商品需要给用户免费绑定虚拟会员服务等等一些功能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;PS.一句话需求，根据订单 MQ 消息，执行一些特殊业务逻辑处理，业务场景比较杂，逻辑分支比较多，而且随时会新增、撤销某些业务功能。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="https://dongzl.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="观察者模式" scheme="https://dongzl.github.io/tags/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Observer" scheme="https://dongzl.github.io/tags/Observer/"/>
    
      <category term="Observable" scheme="https://dongzl.github.io/tags/Observable/"/>
    
  </entry>
  
  <entry>
    <title>基于 Redis 实现的分布式锁</title>
    <link href="https://dongzl.github.io/2019/10/08/04-redis-distributed-lock/"/>
    <id>https://dongzl.github.io/2019/10/08/04-redis-distributed-lock/</id>
    <published>2019-10-08T10:01:09.000Z</published>
    <updated>2020-03-10T02:01:34.186Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景描述"><a href="#背景描述" class="headerlink" title="背景描述"></a>背景描述</h2><p>业务系统网关（API）接口，负责处理客户端发送的 HTTP 请求数据，对于某些客户端的请求数据，需要控制请求的频率；在上一个请求处理完之前，接收到的下一个请求需要拒绝掉，例如，签到领礼品接口，请求到达服务端，需要发放奖品，记录日志，如果逻辑还没处理完，还没成功保存日志数据，客户端又发送了一次请求，查询日志未领取奖品，会导致重复发放奖品。</p><p>PS. 举例逻辑可能比较简单，有些人会较真说需要客户端控制按钮是否可点击（有可能有恶意用户使用 HTTP 客户端工具请求接口），我们只是举例说明一下，主要是写数据场景，防止两次接口请求时间过短导致的重复写数据。</p><a id="more"></a><h2 id="业务实现"><a href="#业务实现" class="headerlink" title="业务实现"></a>业务实现</h2><p>对于这种业务场景，基本可以马上想到使用<code>锁</code>来满足需求；不过目前互联网业务系统基本都是分布式部署，分布式部署肯定不能使用 JDK 自带的锁来实现了，一般要使用分布式锁。<br>当前业务系统中是使用 Redis 的 set 命令实现的分布式锁，主要实现逻辑如下：</p><blockquote><p>加锁：<br>SET key value time NX<br>key: 加锁 key 值<br>value：设置 value，可以设为1<br>time：设置 key 的过期时间<br>NX ：只在 key 不存在时，才对 key 进行操作<br>解锁：<br>1、超时后自动删除 key，解锁，无须程序解锁<br>2、程序解锁：DEL key</p></blockquote><p>业务系统使用场景（伪代码实现）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String key = <span class="string">"SIGN_GET_GIFT_"</span> + userId;</span><br><span class="line"><span class="keyword">boolean</span> lock = SET key <span class="keyword">true</span> <span class="number">5</span> NX;</span><br><span class="line"><span class="keyword">if</span> (!lock) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"签到失败，请勿频繁请求"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//执行签到领取礼品逻辑</span></span><br><span class="line">signGetGift();</span><br><span class="line">saveSignLog();</span><br><span class="line">del(key);</span><br><span class="line"><span class="keyword">return</span> <span class="string">"签到成功"</span>;</span><br></pre></td></tr></table></figure><p>这就是系统通过 Redis 实现的分布式锁，至于这个实现的优点、缺点，是否存在不足或者在某些场景下是否会引起问题，我们后面分析，下面我们来列举一下使用 Redis 实现分布式锁的几种方式。</p><h2 id="setnx-amp-expire-实现分布式锁"><a href="#setnx-amp-expire-实现分布式锁" class="headerlink" title="setnx() &amp; expire()实现分布式锁"></a>setnx() &amp; expire()实现分布式锁</h2><p>setnx 是 <code>SET if Not exists</code>（如果不存在，则 SET）的简写。使用方式为 setnx(key, value)。该方法是原子的，如果 key 不存在，则设置当前 key 成功，返回 1；如果当前 key 已经存在，则设置当前 key 失败，返回 0。</p><p>由于 setnx 无法设置过期时间，一旦加锁后就必须显示操作删除 key，释放锁资源，否则会产生死锁；所以需要使用 <code>expire</code> 命令设置 key 过期时间，这样可以在超时后自动释放锁资源，防止出现死锁，<code>expire</code> 命令使用方式为 <code>expire(key, time)</code>。</p><p>实现步骤：</p><ul><li>setnx(key, 1) 如果返回 0，则说明加锁失败；如果返回 1，则说明加锁成功；</li><li>expire(key, 10)，对 key 设置超时时间，超时自动释放锁资源，避免出现死锁问题；</li><li>执行完业务代码后，可以通过 del 命令删除 key，显示释放锁资源。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伪代码</span></span><br><span class="line">String key = <span class="string">"SIGN_GET_GIFT_"</span> + userId;</span><br><span class="line"><span class="keyword">boolean</span> lock = SETNX key <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (!lock) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"签到失败，请勿频繁请求"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置过期时间 10s</span></span><br><span class="line">expire(key, <span class="number">10</span>);</span><br><span class="line"><span class="comment">// 执行签到领取礼品逻辑</span></span><br><span class="line">signGetGift();</span><br><span class="line">saveSignLog();</span><br><span class="line">del(key);</span><br><span class="line"><span class="keyword">return</span> <span class="string">"签到成功"</span>;</span><br></pre></td></tr></table></figure><p>主要问题：<br><code>setnx()</code> 和 <code>expire()</code>是分两步执行，并不是一个原子操作，如果在第一步 <code>setnx()</code> 执行成功后，在 <code>expire()</code> 命令执行前，发生了系统崩溃，导致设置超时时间失败，锁资源无法正常释放，一定会出现死锁的问题。</p><h2 id="setnx-amp-get-amp-getset-实现分布式锁"><a href="#setnx-amp-get-amp-getset-实现分布式锁" class="headerlink" title="setnx() &amp; get() &amp; getset()实现分布式锁"></a>setnx() &amp; get() &amp; getset()实现分布式锁</h2><p>该方法主要对 <code>setnx() &amp; expire()</code> 可能存在的死锁问题做出一些改进。</p><p><code>getset()</code> 命令的使用方式为 <code>getset(key, value)</code>，该命令将给定 key 的值设为 value，并返回 key 的旧值（old value）。</p><p>实现步骤：</p><ul><li>setnx(key, 当前时间 + 过期超时时间)，如果返回 1，则表示加锁成功；如果返回 0 则表示加锁失败，执行下一步；</li><li>get(key) 获取值 key 过期时间（value1），并将这个 <code>过期时间</code> 值与当前的系统时间进行比较，如果 &lt; 当前系统时间，则认为这个锁已经超时，可以允许其他请求执行加锁操作，转向下一步；</li><li>计算 value2 = 当前时间 + 过期超时时间，然后 getset(key, value2) 会返回当前 key 的值 <code>旧的过期时间（value3）</code>；</li><li>判断步骤二 <code>value3</code> 是否小于当前系统时间，如果小于系统时间，则说明当前 <code>getset</code> 执行成功，获取到了锁；如果大于系统时间，说明这个锁又被别的请求竞争到了，当前请求加锁失败；</li><li>在获取到锁之后，当前线程可以开始自己的业务处理，当处理完毕后，比较自己的处理时间和锁设置的超时时间，如果小于锁设置的超时时间，则直接执行 <code>del(key)</code> 释放锁；如果大于锁设置的超时时间，则不需进行释放锁操作。</li></ul><img src="https://gitee.com/dongzl/article-images/raw/master/2019/04-redis-distributed-lock/redis-distributed-lock-01.png" width="600px"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伪代码</span></span><br><span class="line"><span class="keyword">boolean</span> getLockSuccess = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">long</span> lockExpireTime = <span class="number">0L</span>;</span><br><span class="line">String key = <span class="string">"SIGN_GET_GIFT_"</span> + userId;</span><br><span class="line"><span class="keyword">boolean</span> lock = <span class="function">SETNX <span class="title">key</span> <span class="params">(currentTime + <span class="number">1000</span>ms)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (!lock) &#123;</span><br><span class="line">    <span class="keyword">long</span> value1 = get(key);</span><br><span class="line">    <span class="keyword">if</span> (value1 &lt; currentTime) &#123;</span><br><span class="line">        <span class="keyword">long</span> value2 = currentTime + <span class="number">1000</span>ms;</span><br><span class="line">        <span class="keyword">long</span> value3 = getset(key, value2);</span><br><span class="line">        <span class="keyword">if</span> (value3 &lt; currentTime) &#123;</span><br><span class="line">            getLockSuccess = <span class="keyword">true</span>;</span><br><span class="line">            lockExpireTime = values2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    getLockSuccess = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (getLockSuccess) &#123;</span><br><span class="line">    <span class="comment">// 执行签到领取礼品逻辑</span></span><br><span class="line">    signGetGift();</span><br><span class="line">    saveSignLog();</span><br><span class="line">    <span class="keyword">if</span> (currentTime &lt; lockExpireTime) &#123;</span><br><span class="line">        del(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"签到成功"</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"签到失败，请勿频繁请求"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>setnx() &amp; get() &amp; getset()</code> 实现分布式锁最大的问题是 <code>判断锁失效依赖于系统时间</code>，如果是分布式环境，当某一台服务器时间不准确，时间慢一些，有可能在这台服务器上刚刚执行的加锁操作，在另外一台服务器上判断就已经是处于过期状态。</p><h2 id="SET-key-value-time-NX-实现分布式锁"><a href="#SET-key-value-time-NX-实现分布式锁" class="headerlink" title="SET key value time NX 实现分布式锁"></a>SET key value time NX 实现分布式锁</h2><p>使用 <code>SET key value time NX</code> 命令实现分布式锁是将 <code>setnx() &amp; expire()</code> 两步操作合并成一步操作来保证原子性。</p><p>实现步骤：</p><blockquote><p>加锁：<br>SET key value time NX<br>key: 加锁 key 值<br>value：设置 value，可以设为1<br>time：设置 key 的过期时间<br>NX ：只在 key 不存在时，才对 key 进行操作<br>解锁：<br>1、超时后自动删除 key，解锁，无须程序解锁<br>2、程序解锁：DEL key</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String key = <span class="string">"SIGN_GET_GIFT_"</span> + userId;</span><br><span class="line"><span class="keyword">boolean</span> lock = SET key <span class="keyword">true</span> <span class="number">5</span> NX;</span><br><span class="line"><span class="keyword">if</span> (!lock) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"签到失败，请勿频繁请求"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//执行签到领取礼品逻辑</span></span><br><span class="line">signGetGift();</span><br><span class="line">saveSignLog();</span><br><span class="line">del(key);</span><br><span class="line"><span class="keyword">return</span> <span class="string">"签到成功"</span>;</span><br></pre></td></tr></table></figure><h2 id="Redis-锁优化"><a href="#Redis-锁优化" class="headerlink" title="Redis 锁优化"></a>Redis 锁优化</h2><h3 id="加锁-amp-解锁顺序错乱优化"><a href="#加锁-amp-解锁顺序错乱优化" class="headerlink" title="加锁 &amp; 解锁顺序错乱优化"></a>加锁 &amp; 解锁顺序错乱优化</h3><p>在前面提到的几种使用 Redis 命令实现的分布式锁中，在解锁时都需要注意一个问题：</p><ul><li>线程 A 对 key 加锁成功，设置超时时间 10s；</li><li>由于某个原因线程 A 执行较慢，时间超过 10s，导致超时自动释放锁；</li><li>线程 B 对 key 加锁成功，设置超时时间 10s；</li><li>线程 A 执行成功，执行 del(key) 命令释放锁成功，此时 B 还未执行成功，且未超时；</li><li>线程 C 对 key 加锁成功。</li></ul><img src="https://gitee.com/dongzl/article-images/raw/master/2019/04-redis-distributed-lock/redis-distributed-lock-02.png" width="600px"><p>这里出现的最大问题是某个线程（A）超时导致自动释放锁，另外一个线程（B）加锁成功，A 线程执行完后执行释放锁操作，会释放掉线程 B 的锁，导致加锁、解锁操作出现错乱。<br>解决这个问题的方式是通过给每次加锁设置不同的value值，每次解锁时判断value值与加锁时的value值是否相等来判断是否可以执行解锁操作。例如：可以在加锁时将value值设置为 <code>服务器IP + 当前线程的ID</code>，解锁时判断解锁 <code>服务器IP + 当前线程的ID</code> 与value值是否相等来决定是否可以执行解锁操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String key = <span class="string">"SIGN_GET_GIFT_"</span> + userId;</span><br><span class="line"><span class="keyword">long</span> value = IP + <span class="string">"_"</span> + Thread.currentThread().getId();</span><br><span class="line"><span class="keyword">boolean</span> lock = SET key value <span class="number">5</span> NX;</span><br><span class="line"><span class="comment">//... ... 执行业务逻辑</span></span><br><span class="line"><span class="keyword">long</span> value1 = IP + <span class="string">"_"</span> + Thread.currentThread().getId();</span><br><span class="line"><span class="keyword">if</span> (value1 = get(key)) &#123;</span><br><span class="line">    del(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PS. 在这里设置设置 value 值为 <code>服务器IP + 当前线程的ID</code>，主要就是构造一个分布式环境下的唯一标识，如果只单独使用<code>当前线程的ID</code>作为 value 值，则分布式部署情况下不同机器可能会产生相同的线程ID值，当然也可以使用构造的其他内容作为 value 值。</p><p>对于最后的 <code>get(key) &amp; del(key)</code> 操作，可以通过使用lua脚本的方式封装成一个原子操作在 Redis 中执行：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> redis.call(<span class="string">"get"</span>, KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">"del"</span>, KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">String luaScript = <span class="string">"if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end"</span>;</span><br><span class="line"></span><br><span class="line">redisClient.eval(luaScript, Collections.singletonList(key), Collections.singletonList(value1));</span><br></pre></td></tr></table></figure><h3 id="超时导致并发执行优化"><a href="#超时导致并发执行优化" class="headerlink" title="超时导致并发执行优化"></a>超时导致并发执行优化</h3><p>在前面的优化中我们可以解决加锁超时导致的解锁操作顺序错乱问题，但是依然会有并发执行的情况出现，例如线程 A 对 key 加锁后执行业务代码，超时后自动释放锁；此时线程 B 对 key 加锁成功，执行业务代码；我们使用分布式锁的目的就是控制代码并发执行，现在依然会有并发执行的情况出现。</p><p>对于这个问题我们可以让获取锁的线程再开启一个 <code>守护线程</code> 的方式，用来给快要过期的锁“续航”。例如：</p><ul><li>线程 A 对 key 加锁成功，过期时间 10s；</li><li>线程 A 开始执行业务代码；</li><li>当执行到 8s 时，线程 A 还没有释放锁，此时守护线程执行 expire 命令为线程 A 的锁续航，例如继续续航 5s；</li><li>守护线程从 8s 开始，每 5s 执行一次续航，直到线程 A 执行完毕；</li><li>当线程 A 执行完业务代码退出时，需要显示关闭守护线程，并释放锁资源。</li></ul><p>对于使用守护线程续航的方式，在某个线程所在系统出现崩溃时，由于守护线程和该线程在同一个JVM中，此时守护线程也会被关闭，到锁超时的时候，由于没有线程为锁续航，锁就自动释放掉了。</p><p>对于这种自动续航的方式，我们一定要注意的是业务代码一定不能出现死循环，或者说一定要在有限时间内执行完毕，因为一旦某个线程获取锁成功，但是一直无法执行完毕，守护线程会一直为锁续航，锁永远不会超时自动释放，导致出现死锁情况。</p><h2 id="Redis-实现分布式锁的高可用分析"><a href="#Redis-实现分布式锁的高可用分析" class="headerlink" title="Redis 实现分布式锁的高可用分析"></a>Redis 实现分布式锁的高可用分析</h2><h3 id="单点-Redis-锁缺陷"><a href="#单点-Redis-锁缺陷" class="headerlink" title="单点 Redis 锁缺陷"></a>单点 Redis 锁缺陷</h3><p>如果 Redis 服务器只有一台，很明显容易出现单点故障，很难保证高可用，一旦服务器宕机，整个分布式锁功能都会不可用。 </p><h3 id="Redis-主从架构的分布式锁"><a href="#Redis-主从架构的分布式锁" class="headerlink" title="Redis 主从架构的分布式锁"></a>Redis 主从架构的分布式锁</h3><p>如果一台 Redis 服务器容易出现单点故障，那么部署 Redis 主从（master / slave，一主多从）架构，还会有问题吗？<br>其实仔细分析还是会有问题：</p><ul><li>线程 A 在 master 节点上通过 key 获取到一个锁；</li><li>master 把这个数据同步到 slave 节点的时候宕机了（Redis 中 master 和 slave 之间同步数据机制是<strong>异步</strong>的）；</li><li>这时候其中一个 slave 节点会升级为 master 节点；</li><li>线程 B 通过相同的 key 去获取分布式锁，是可以成功的，因为新升级的节点上没有这个数据。</li></ul><p>单点是不行的，主从架构也不保险，对于这个问题，Redis 的官方给出了一个 <code>RedLock</code> 的解决方案。</p><h3 id="RedLock-分布式锁解决方案"><a href="#RedLock-分布式锁解决方案" class="headerlink" title="RedLock 分布式锁解决方案"></a><code>RedLock</code> 分布式锁解决方案</h3><p>原文：<a href="https://redis.io/topics/distlock" target="_blank" rel="noopener">Distributed locks with Redis</a></p><p>翻译：<a href="http://ifeve.com/redis-lock/" target="_blank" rel="noopener">用Redis构建分布式锁</a></p><p>实现 <code>RedLock</code> 实现分布式锁的前提条件是：假设有 N 个 Redis master 节点，所有节点之间是相互独立，互补影响的，并且业务系统也是单纯的对这些节点进行调用：</p><ul><li>获取当前时间毫秒数（t0）；</li><li>轮流用相同的 key 和随机值在 N 个节点上请求锁，在这一步里，客户端在每个master 上请求锁时，会有一个和总的锁释放时间相比小的多的超时时间。比如：如果锁自动释放时间是10s，那每个节点锁请求的超时时间可能是 5-50ms 的范围，这个可以防止一个客户端在某个宕掉的 master 节点上阻塞过长时间，<strong>如果一个 master 节点不可用了，我们应该尽快尝试下一个 master 节点</strong>；</li><li>客户端计算第二步中获取锁花费的时间（t1），只有客户端在大多数 master 节点上获取锁成功，而且总共消耗的时间不超过锁释放的时间，就认为是成功获取锁了；</li><li>如果锁获取成功了，那现在<strong>锁自动释放时间就是最初的锁释放时间减去之前获取锁所消耗的时间（锁业务有效时间：10s - t1）</strong>。</li><li>如果锁获取失败了，不管是因为获取成功的锁不超过一半（N/2 + 1）还是因为总消耗时间超过了锁释放时间，客户端都会到每个 master 节点上释放锁，即使是那些没有获取成功的锁。</li></ul><h3 id="Redisson-工具中的-RedLock-实现"><a href="#Redisson-工具中的-RedLock-实现" class="headerlink" title="Redisson 工具中的 RedLock 实现"></a><code>Redisson</code> 工具中的 <code>RedLock</code> 实现</h3><p><code>Redisson</code> 是一个具备内存数据网格特征的 Redis Java 客户端工具。它提供了 30 多种对象类型和服务功能：Set, Multimap, SortedSet, Map, List, Queue, Deque, Semaphore, Lock, AtomicLong, Map Reduce, Publish / Subscribe, Bloom filter, Spring Cache, Tomcat, Scheduler, JCache API, Hibernate, RPC.</p><p>Redisson 对于 RedLock 的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Config config = <span class="keyword">new</span> Config();</span><br><span class="line">config.useSingleServer().setAddress(<span class="string">"redis://192.168.120.0:5378"</span>).setPassword(<span class="string">"123456"</span>).setDatabase(<span class="number">0</span>);</span><br><span class="line">RedissonClient client = Redisson.create(config);</span><br><span class="line"></span><br><span class="line">Config config1 = <span class="keyword">new</span> Config();</span><br><span class="line">config1.useSingleServer().setAddress(<span class="string">"redis://192.168.120.1:5378"</span>).setPassword(<span class="string">"123456"</span>).setDatabase(<span class="number">0</span>);</span><br><span class="line">RedissonClient client1 = Redisson.create(config1);</span><br><span class="line"></span><br><span class="line">Config config2 = <span class="keyword">new</span> Config();</span><br><span class="line">config2.useSingleServer().setAddress(<span class="string">"redis://192.168.120.2:5378"</span>).setPassword(<span class="string">"123456"</span>).setDatabase(<span class="number">0</span>);</span><br><span class="line">RedissonClient client2 = Redisson.create(config2);</span><br><span class="line"></span><br><span class="line">String key = <span class="string">"SIGN_GET_GIFT_"</span> + userId;</span><br><span class="line">RLock rLock = client.getLock(key);</span><br><span class="line">RLock rLock1 = client1.getLock(key);</span><br><span class="line">RLock rLock2 = client2.getLock(key);</span><br><span class="line">RedissonRedLock redLock = <span class="keyword">new</span> RedissonRedLock(rLock, rLock1, rLock2);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!redLock.tryLock()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"签到失败，请勿频繁请求"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//执行签到领取礼品逻辑</span></span><br><span class="line">    signGetGift();</span><br><span class="line">    saveSignLog();</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"签到成功"</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"签到异常"</span>;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    redLock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>整理了一些内容，也研究了好久，每个实现方案都有种种缺点和不足，为了解决这些问题，我们不得不引入一些额外的判断和处理流程，写了很多，我感觉我依然无法用 Redis 实现一个简单、高效、完美的分布式锁的功能，当然还有 RedLock 的实现方案，Redission 开源框架的具体实现，这些还得需要进一步去研究一下。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.cnblogs.com/seesun2012/p/9214653.html" target="_blank" rel="noopener">Java分布式锁看这篇就够了</a></li><li><a href="http://doc.redisfans.com/" target="_blank" rel="noopener">Redis 命令参考</a></li><li><a href="https://mp.weixin.qq.com/s/1bPLk_VZhZ0QYNZS8LkviA" target="_blank" rel="noopener">基于Redis的分布式锁真的安全吗？（上）</a></li><li><a href="https://redis.io/topics/distlock" target="_blank" rel="noopener">Distributed locks with Redis</a></li><li><a href="http://ifeve.com/redis-lock/" target="_blank" rel="noopener">用Redis构建分布式锁</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景描述&quot;&gt;&lt;a href=&quot;#背景描述&quot; class=&quot;headerlink&quot; title=&quot;背景描述&quot;&gt;&lt;/a&gt;背景描述&lt;/h2&gt;&lt;p&gt;业务系统网关（API）接口，负责处理客户端发送的 HTTP 请求数据，对于某些客户端的请求数据，需要控制请求的频率；在上一个请求处理完之前，接收到的下一个请求需要拒绝掉，例如，签到领礼品接口，请求到达服务端，需要发放奖品，记录日志，如果逻辑还没处理完，还没成功保存日志数据，客户端又发送了一次请求，查询日志未领取奖品，会导致重复发放奖品。&lt;/p&gt;
&lt;p&gt;PS. 举例逻辑可能比较简单，有些人会较真说需要客户端控制按钮是否可点击（有可能有恶意用户使用 HTTP 客户端工具请求接口），我们只是举例说明一下，主要是写数据场景，防止两次接口请求时间过短导致的重复写数据。&lt;/p&gt;
    
    </summary>
    
    
      <category term="架构设计" scheme="https://dongzl.github.io/categories/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="redis" scheme="https://dongzl.github.io/tags/redis/"/>
    
      <category term="lock" scheme="https://dongzl.github.io/tags/lock/"/>
    
      <category term="setnx" scheme="https://dongzl.github.io/tags/setnx/"/>
    
  </entry>
  
  <entry>
    <title>一个工作的真实场景聊聊 HashMap 的实现</title>
    <link href="https://dongzl.github.io/2019/09/29/02-JDK8-HashMap-Code/"/>
    <id>https://dongzl.github.io/2019/09/29/02-JDK8-HashMap-Code/</id>
    <published>2019-09-29T05:39:36.000Z</published>
    <updated>2020-03-10T01:53:12.465Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景描述"><a href="#背景描述" class="headerlink" title="背景描述"></a>背景描述</h2><p>业务同事和其他公司合作活动，对方公司筛选 2W 优质用户手机号提供给我方，出于安全考虑（其实具体原因未知），对方提供的手机号都是 MD5 加密内容；业务同事想对这 2W 用户做短信触达，搞促销活动，业务找到研发需要将现在的 2W MD5 手机号内容逆向转换成用户手机号，然后发短信，需求场景就是这样。</p><p><strong>PS. 一句话需求，2W MD5 手机号内容，需要逆向碰撞出手机号明文，做短信促销。</strong></p><a id="more"></a><h2 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h2><p>我们都知道 MD5 是不可逆的，所以通过密文反向出明文是基本不太可行的；想到的可行方式就是穷举所有号段手机号，将所有手机号 MD5 后看是否包含在对方提供的 2W 手机号里，如果包含在里面就找到了一个手机号。</p><h3 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h3><p>程序穷举某个号段所有手机号内容，生成 13400000000 ~ 13499999999 所有手机号（可能某些手机号不存在，但是拿不到运营商真实手机号，只好穷举），每个号段 <code>10的8次方</code> 个号码；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">13400000000</span><br><span class="line">13400000001</span><br><span class="line">... ...</span><br><span class="line">//中间数据省略</span><br><span class="line">... ...</span><br><span class="line">13499999998</span><br><span class="line">13499999999</span><br></pre></td></tr></table></figure><p>程序将 2W 手机号 MD5 内容装入 <code>ArrayList</code> 集合，对于每一个穷举的手机号码，首先生成 MD5 内容，然后判断生成的 MD5 内容在 <code>ArrayList</code> 集合中是否存在，存在则碰撞到一个手机号保存下来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2W MD5 手机号内容</span></span><br><span class="line">List&lt;String&gt; md5PhoneList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">// 穷举某个号段所有手机号 10的8次方 个号码</span></span><br><span class="line">List&lt;String&gt; allPhoneNumList = <span class="keyword">new</span> ArrayList&lt;&gt;(); </span><br><span class="line"><span class="keyword">for</span> (String phone : allPhoneNumList) &#123;</span><br><span class="line">    String md5Str = md5(phone);</span><br><span class="line">    <span class="keyword">if</span> (md5PhoneList.contains(md5Str)) &#123;</span><br><span class="line">        System.out.println(phone);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果，大概一天才能跑完一个号段数据。当时汇总了一下，运营商常用号段至少在 40 多个，整个都跑完大概需要 1 个多月时间，理论 &amp; 实际都不可接受。</p><h3 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h3><p>后来想到改用 <code>HashMap</code> 尝试一下，<code>HashMap</code> 提前将穷举的手机号和 MD5 内容一同写入某个文件，调整程序JVM堆内存大小，程序直接读取文件（单个文件大概 500M），将穷举的内容直接读入内存 <code>HashMap</code> 结构中，然后循环判断 2W MD5 内容在 <code>HashMap</code> 中是否存在，存在则碰撞到一个手机号保存下来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 文件内容</span><br><span class="line">cd6b58233d21f2cc3a1fe6eecda4a17d:13400000000</span><br><span class="line">08f13675e2ed8813d519f01a6f3a2c75:13400000001</span><br><span class="line">... ...</span><br><span class="line">//中间数据省略</span><br><span class="line">... ...</span><br><span class="line">23e008be8bfe30dc24d99f246d4a363f:13499999998</span><br><span class="line">2ee6697e49a60130012f2f2824fa1778:13499999999</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2W MD5 手机号内容</span></span><br><span class="line">List&lt;String&gt; md5PhoneList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">// 文件读取某个号段所有手机号，key:value -&gt; MD5内容:手机号</span></span><br><span class="line">Map&lt;String, String&gt; allPhoneNumList = readFile(); </span><br><span class="line"><span class="keyword">for</span> (String phone : md5PhoneList) &#123;</span><br><span class="line">    String value = allPhoneNumList.get(phone);</span><br><span class="line">    <span class="keyword">if</span> (value != <span class="keyword">null</span> &amp;&amp; !value.isEmpty()) &#123;</span><br><span class="line">        System.out.println(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果，第一步生成所有 <code>手机号MD5:手机号明文</code> 内容，写入某个文件（几分钟搞定），然后通过程序进行碰撞真实手机号（几十秒完成），一通操作下来 10 分钟搞定一个号段，方案 OK。<br>这段时间分成两步操作，第一步找到所有运营商号段，每个号段生成一个文件内容；第二步单个文件开始进行处理，最终整个工作一天完成。</p><p><strong>PS. 这期间先用一台普通 windows 机器（SSD硬盘）处理，生成 <code>手机号MD5:手机号明文</code> 内容写入文件中，写入速度不是很快，生成一个文件要十几分钟，后来改用自己的 MAC PRO 机器，写入文件速度明显加快，几分钟搞定一个文件，速度提升好几倍，所以说 <code>工欲善其事，必先利其器</code> 还是很有道理的。</strong></p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>对于 <code>ArrayList</code> 的 <code>boolean contains(Object o);</code> 方法，内部是通过循环的方式逐一判断是否存在的，时间复杂度为 O(n)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> indexOf(o) &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 <code>HashMap</code> 的 <code>V get(Object key);</code> 方法，内部是通过 hash 结构来存储和获取的，如果 hash 函数设计的非常优秀，理想情况下是可以达到 <code>O(1)</code> 的时间繁杂度的，当然这是理想情况，后面我们还会再分析实际时间复杂度：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这只是上面需求的一个实现过程，下面我们来具体分析一下 <code>HashMap</code> 中的一些关键内容的实现原理。</p><blockquote><p>前面描述的是真实的工作场景，<code>HashMap</code> 最终搞定了这个工作，如果有更好的实现方案，也欢迎大家留言讨论。</p></blockquote><h2 id="JDK版本"><a href="#JDK版本" class="headerlink" title="JDK版本"></a>JDK版本</h2><blockquote><p>JDK 8</p></blockquote><h2 id="全局变量定义"><a href="#全局变量定义" class="headerlink" title="全局变量定义"></a>全局变量定义</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * HashMap 初始容量 16，必须为 2的n次幂</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * HashMap 最大容量，必须为 2的n次幂，并且 &lt;= (1 &lt;&lt; 30)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认负载因子 0.75</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一个 bin 中 Node 节点存储结构由链表转换为红黑树的阈值 = 8，</span></span><br><span class="line"><span class="comment"> * 当一个 bin 中 Node 节点数量较少时使用链表存储</span></span><br><span class="line"><span class="comment"> * 当 Node 数量大于 8 时转换为红黑树存储结构。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 执行扩容操作之后，bin 中 Node 节点存储结构由红黑树转换为链表的阈值 = 6</span></span><br><span class="line"><span class="comment"> * 执行扩容操作之后，bin 中 Node 节点数量会减少，当少于 6 个时，Node 存储结构由红黑树转换成链表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * bins 执行树化（转换成红黑树）操作时 HashMap 容量的最小值。</span></span><br><span class="line"><span class="comment"> * 也就是说，如果某个 bin 中 Node 节点数量很多，并不会马上进行树化操作，而是 HashMap 会先进行扩容操作，</span></span><br><span class="line"><span class="comment"> * 当容量 &gt;= 64 后，某个 bin 中 Node 节点数量 &gt;= TREEIFY_THRESHOLD 才会执行树化操作。</span></span><br><span class="line"><span class="comment"> * 这个值至少是 4 倍的 TREEIFY_THRESHOLD 值，这样可以避免 HashMap 扩容操作和树化阈值之间的冲突。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br></pre></td></tr></table></figure><p>从全局变量的定义我们可以总结如下一下信息：</p><ul><li>JDK8 中 HashMap 初始容量和负载因子分别为 16 和 0.75；</li><li>JDK8 中 HashMap 存储结构转换为 <code>数组 + 链表 + 红黑树</code>，之前为 <code>数组 + 链表</code>;</li><li>数组某个位置下链表长度 &gt;= 8时，可能会执行树化操作，进化成 <code>红黑树</code> 存储结构；</li><li>当 HashMap 执行扩容操作之后，数组某个位置下节点数量会变少，当 &lt;= 6 个时，会从红黑树退化成链表；</li><li><code>TREEIFY_THRESHOLD</code> + <code>MIN_TREEIFY_CAPACITY</code> 两个值共同决定了链表是否执行树化操作。</li></ul><h2 id="构造函数初始化"><a href="#构造函数初始化" class="headerlink" title="构造函数初始化"></a>构造函数初始化</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial</span></span><br><span class="line"><span class="comment"> * capacity and load factor.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  initialCapacity the initial capacity</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  loadFactor      the load factor</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity is negative</span></span><br><span class="line"><span class="comment"> *         or the load factor is nonpositive</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a power of two size for the given target capacity.</span></span><br><span class="line"><span class="comment"> * 根据给定的 capacity 参数，初始化容量为 2的k次幂</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果在初始化 <code>HashMap</code> 时指定了 <code>initialCapacity</code> 参数，由于 HashMap 要求 <code>capacity</code> 必须是 <strong>2的k次幂</strong>，因此构造函数调用 <code>tableSizeFor</code> 方法计算出 &gt;= initialCapacity 的最小的 <strong>2的k次幂</strong> 数值（如果 initialCapacity 本身就是 <strong>2的k次幂</strong>，经过计算后还是原值）。<br>算法步骤：</p><blockquote><p>int n = cap - 1;</p></blockquote><p>首先执行减 1 操作是为了防止 cap 已经是 <strong>2的k次幂</strong>。如果 cap 已经是 <strong>2的k次幂</strong>， 又没有执行减 1 操作，则执行完后面的操作之后，返回的结果将是这个 cap 的 <code>2</code> 倍。</p><p>下面开始执行右移操作：</p><blockquote><p>例如：n = 12时，二进制位：00001100</p></blockquote><p>第一步，无符号右移 1 位：</p><blockquote><p>n |= n &gt;&gt;&gt; 1;</p><p>00001100 | (00001100 &gt;&gt;&gt; 1) = 00001100 | 00000110 = 00001110</p></blockquote><p>第二步，无符号右移 2 位：</p><blockquote><p>n |= n &gt;&gt;&gt; 2;</p><p>00001110 | (00001110 &gt;&gt;&gt; 2) = 00001110 | 00000011 = 00001111</p></blockquote><p>第三步，无符号右移 4 位：</p><blockquote><p>n |= n &gt;&gt;&gt; 4;</p><p>00001111 | (00001111 &gt;&gt;&gt; 4) = 00001111 | 00000000 = 00001111</p></blockquote><p>以此类推右移 8 位、16 位，在这里容量最大也就是 32bit 的正数，因此最后 <code>n |= n &gt;&gt;&gt; 16;</code> 后，最多也就 31 个 1（第一位符号位，恒为 0），但是这时已经大于了 <code>MAXIMUM_CAPACITY</code>，所以最终取值为 <code>MAXIMUM_CAPACITY</code>。</p><img src="https://gitee.com/dongzl/article-images/raw/master/2019/02-JDK8-HashMap-Code/HashMap_1.png" width="600px"><p>之所以执行上面的一波无符号右移操作，就是为了让 <code>initialCapacity</code> 的值右移几次之后，二进制的值从某一位起的低位全部为连续 1，之前高位全部为 0，这样最后执行 <code>n + 1</code> 操作之后，结果一定是 <strong>2的k次幂</strong> 值，而且是 &gt;=n 的最小的 <strong>2的k次幂</strong> 值。</p><h2 id="hash-方法"><a href="#hash-方法" class="headerlink" title="hash 方法"></a>hash 方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 hash 方法的实现中，首先计算 key 的 hashCode 值，然后将得到的 hashCode 值无符号右移 16 位，然后再进行 <code>^</code> 操作，最终得到的结果为 key 的 hashCode。<br>我们知道对于 hash 这种数据结构来说，最重要的就是 <code>散列函数（hash函数）</code> 的设计，如果hash函数设计的比较好，可以减少元素之间的碰撞概率，使数据分布更加均匀，提高 get 和 put 方法的执行效率。</p><p>对于JDK中散列函数的设计基本思想是：<code>让 hashCode 中高 16bit 位也参与到 hash 函数计算中</code>。</p><p>在 <code>HashMap</code> 中，容量值为 <strong>2的k次幂</strong>，而计算元素下标的时候，是这样实现的：</p><blockquote><p>(n - 1) &amp; hash (实际含义为 hash % n，后面会解释为什么)</p></blockquote><p>如果容量值比较小的时候，不进行 <code>移位异或</code> 操作的话 hashCode 的高位是无法参与到 hash 函数运算中的，比如<br>当 n = 16 时，如下三个 key 的 hashCode：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0101 0101 0101 0010 1010 1010 1010 1001</span><br><span class="line">0101 0111 1101 1110 1010 1010 1010 1001</span><br><span class="line">0111 0111 0111 0000 1111 1011 1110 1001</span><br></pre></td></tr></table></figure><p>这三个key的hashCode完全不同，但是如果计算三个 key 在数组中的位置的话，结果是相同的：</p><blockquote><p>(n - 1) &amp; hash</p></blockquote><p>结果都是：<code>9</code>，所以虽然是三个不同 key 却发生了碰撞，如果将高位 <code>移位异或</code> 之后再计算结果，分别是</p><blockquote><p>11<br>7<br>9</p></blockquote><p>因为当容量比较小的时候，hashCode 只有低位才会参与到运算中，所以容易发生碰撞，所以在 <code>右移异或</code> 之后让 hashCode 中高 16bit 也参与到 hash 运算中，降低碰撞出现的概率。</p><blockquote><p>Computes key.hashCode() and spreads (XORs) higher bits of hash to lower.  Because the table uses power-of-two masking, sets of hashes that vary only in bits above the current mask will always collide. (Among known examples are sets of Float keys holding consecutive whole numbers in small tables.)  So we apply a transform that spreads the impact of higher bits downward. There is a tradeoff between speed, utility, and quality of bit-spreading. Because many common sets of hashes are already reasonably distributed (so don’t benefit from spreading), and because we use trees to handle large sets of collisions in bins, we just XOR some shifted bits in the cheapest possible way to reduce systematic lossage, as well as to incorporate impact of the highest bits that would otherwise never be used in index calculations because of table bounds.</p></blockquote><p>在 hash 方法的注释中作者也解释了，这个实现是充分考虑了 <code>speed(速度), utility(作用), and quality(质量)</code> 之后的结果，而且 <code>现在大部分的 hash 函数实现使数据分布已经很均匀了，而且在发生碰撞之后也优化成了树型结构，仅仅进行了一次异或操作，既没有引起系统很大的开销，也降低了因为高位没有参加运算而导致的碰撞情况出现。</code></p><h2 id="index-方法"><a href="#index-方法" class="headerlink" title="index 方法"></a>index 方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(n - <span class="number">1</span>) &amp; hash</span><br></pre></td></tr></table></figure><p><code>HashMap</code> 中没有 index 方法，之所以这么称呼，是因为这一行代码，就是确定某个 key 在 table 数组中的位置，所以姑且称作 index 方法。<br>其实，这行代码的含义是 <code>hash % n</code> 的结果，之所以使用 <code>&amp;</code> 操作而不是 <code>%</code> 的方式，是因为 相对于 <code>&amp;</code> 操作，<code>%</code> 是一个比较耗时的操作，而 <code>&amp;</code> 是位操作，速度非常快。<br>但是，<code>(n - 1) &amp; hash == hash % n</code> 是如何成立的？</p><p>这里举个例子，例如：<br>9 % 4 = 1，9 的二进制是 1001，4 - 1 = 3，3 的二进制是 0011。 9 &amp; 3 = 1001 &amp; 0011 = 0001 = 1；</p><p>12 % 8 = 4，12 的二进制是 1100，8 - 1 = 7，7的二进制是 0111。12 &amp; 7 = 1100 &amp; 0111 = 0100 = 4；</p><p>上面两个例子 4 和 8 都是 <strong>2的k次幂</strong>，结论是成立的，当长度不为 <strong>2的k次幂</strong> 时:</p><p>比如：9 % 5 = 4，9的二进制是 1001，5 - 1 = 4，4的二进制是0100。9 &amp; 4 = 1001 &amp; 0100 = 0000 = 0，显然是不成立的。<br>结论：</p><blockquote><p>结论：当 n = <strong>2的k次幂</strong> 时，x % n = x &amp; (n - 1)</p></blockquote><p>具体证明过程可以参考：<a href="https://www.cnblogs.com/ysocean/p/9054804.html" target="_blank" rel="noopener">由 HashMap 哈希算法引出的求余 % 和与运算 &amp; 转换问题</a></p><h2 id="put-方法"><a href="#put-方法" class="headerlink" title="put 方法"></a>put 方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// table 为空，执行初始化操作</span></span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 初始化头结点</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 判断是第一个元素，直接替换</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            <span class="comment">// 插入树元素</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        <span class="comment">// 转换成红黑树</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// onlyIfAbsent true，key存在不覆盖value</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        <span class="comment">// 扩容操作</span></span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过阅读源代码，put 方法的实现思路主要是：</p><ul><li>判断 table 是否为 null，如果为空调用 resize() 方法进行初始化；</li><li>计算新增元素在 table 中位置 <code>tab[i = (n - 1) &amp; hash]</code>，判断是否发生碰撞；</li><li>如果没有碰撞直接放到 table 中该索引位置；</li><li>如果发生碰撞，判断 table 后链接的是什么数据类型；</li><li>如果是 TreeNode 类型，直接插入红黑树中；</li><li>如果是 LinkedList 类型，直接 <code>头插法</code> 插入链表头部；</li><li>插入后判断链表长度是不是大于树化阈值（TREEIFY_THRESHOLD），如果 &gt;= TREEIFY_THRESHOLD，链表进化成红黑树；</li><li>在插入过程都要判断元素是否已经存在 <code>p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))</code>；</li><li>如果元素存在根据 <code>onlyIfAbsent</code> 参数判断是否覆盖旧值（HashMap 直接覆盖）;</li><li>最后判断元素数量是否超过阈值，超过阈值需要进行 resize() 操作。</li></ul><h2 id="resize-方法"><a href="#resize-方法" class="headerlink" title="resize 方法"></a>resize 方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 超过最大阈值，不在执行扩容操作，直接发生碰撞后存储</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            <span class="comment">// 原来容量右移一位，扩容为原来 2 倍</span></span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据 loadFactor 计算新的上限值，下次扩容使用</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">// 原 table 索引位置</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 新 table 索引位置：原位置 + oldCap</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 原索引放到原来 table 位置</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 原索引放到 "原位置 + oldCap" 位置</span></span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当执行 <code>put</code> 操作时，如果目前的 <code>table</code> 数组的使用程度已经超过 <code>loadFactor</code> 的比例（默认 <code>75%</code>），就会调用 <code>resize()</code> 方法执行扩容操作，<code>HashMap</code> 扩容操作是将 <code>table</code> 扩容为原来的 <code>2</code> 倍，之后重排列元素，这里面的重新排列元素是有技巧的，<code>resize()</code> 方法的注释大致意思是：首先要扩容为原来的 <code>2</code> 倍，扩容之后，由于是扩容为原来的 <code>2</code> 倍，元素的位置或者是在原来的位置，或者是在新 <code>table</code> 中偏移 <code>2</code> 次幂的位置。</p><blockquote><p>Otherwise, because we are using power-of-two expansion, the elements from each bin must either stay at same index, or move with a power of two offset in the new table.</p></blockquote><img src="https://gitee.com/dongzl/article-images/raw/master/2019/02-JDK8-HashMap-Code/HashMap_2.png" width="600px"><p>我们在扩容 HashMap 的时候，不需要重新计算 hash，只需要观察一下原来的 hash 值新增的那个 bit 是 1 还是 0 就好了，是 0 的话索引没变，是 1 的话索引变成 <code>原索引 + oldCap</code>。以下图为例，如果 n = 16，扩容后 n = 32:</p><img src="https://gitee.com/dongzl/article-images/raw/master/2019/02-JDK8-HashMap-Code/HashMap_3.png" width="600px"><h2 id="get-方法"><a href="#get-方法" class="headerlink" title="get 方法"></a>get 方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="comment">// 判断table不为空</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果第一个元素命中，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果是红黑树，获取节点值，O(logn)</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="comment">// 循环遍历链表，O(n)</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>get 方法的实现思路如下：</p><ul><li>根据 hashCode 计算元素在 table 中位置 <code>tab[(n - 1) &amp; hash]</code>，如果第一个元素命中，直接返回；</li><li>如果发生碰撞，则根据结点类型继续向下查找；</li><li>如果是 <code>TreeNode</code> 类型，在红黑树中查找，时间复杂度 <code>O(logn)</code>；</li><li>如果是 <code>LinkedList</code> 类型，循环查找，时间复杂度 <code>O(n)</code>。</li></ul><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>通过分析 <code>HashMap</code> 内部的实现细节，我们再返回头来看开篇的案例，对于 <code>ArrayList</code> 类，<code>contains</code> 方法的时间复杂度是 <code>0(n)</code>，而 <code>HashMap</code> 的时间复杂度是 <code>O(1) + O(logn)</code> 或者是 <code>O(1) + O(n)</code> 的，但是 <code>HashMap</code> 的执行效率要高出很多，这是因为在 <code>HashMap</code> 中的 <code>O(logn)</code> 或者是 <code>O(n)</code> 的 n 是发生碰撞的元素数量，并不是我们实际计算的元素数量，或者写作 <code>O(1) + O(logk) 或者 O(1) + O(k) k 为碰撞元素个数</code> 更合适，如果 hash 函数设计的非常合理，数据分布的非常均匀，发生碰撞的概率比较小，k 值相对于计算元素 n 应该是小很多的，所以执行的效率会高很多。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="http://yikun.github.io/2015/04/01/Java-HashMap%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/" target="_blank" rel="noopener">Java HashMap工作原理及实现</a></li><li><a href="https://blog.csdn.net/fan2012huan/article/details/51097331" target="_blank" rel="noopener">HashMap源码注解 之 静态工具方法hash()、tableSizeFor()（四）</a></li><li><a href="https://www.cnblogs.com/ysocean/p/9054804.html" target="_blank" rel="noopener">由HashMap哈希算法引出的求余%和与运算&amp;转换问题</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景描述&quot;&gt;&lt;a href=&quot;#背景描述&quot; class=&quot;headerlink&quot; title=&quot;背景描述&quot;&gt;&lt;/a&gt;背景描述&lt;/h2&gt;&lt;p&gt;业务同事和其他公司合作活动，对方公司筛选 2W 优质用户手机号提供给我方，出于安全考虑（其实具体原因未知），对方提供的手机号都是 MD5 加密内容；业务同事想对这 2W 用户做短信触达，搞促销活动，业务找到研发需要将现在的 2W MD5 手机号内容逆向转换成用户手机号，然后发短信，需求场景就是这样。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;PS. 一句话需求，2W MD5 手机号内容，需要逆向碰撞出手机号明文，做短信促销。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="java开发" scheme="https://dongzl.github.io/categories/java%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="HashMap" scheme="https://dongzl.github.io/tags/HashMap/"/>
    
      <category term="Hash" scheme="https://dongzl.github.io/tags/Hash/"/>
    
      <category term="红黑树" scheme="https://dongzl.github.io/tags/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>线上系统频繁Full GC问题排查</title>
    <link href="https://dongzl.github.io/2019/09/20/05-online-system-frequent-full-gc-bug/"/>
    <id>https://dongzl.github.io/2019/09/20/05-online-system-frequent-full-gc-bug/</id>
    <published>2019-09-20T07:02:03.000Z</published>
    <updated>2020-03-10T01:51:53.728Z</updated>
    
    <content type="html"><![CDATA[<h2 id="现象描述"><a href="#现象描述" class="headerlink" title="现象描述"></a>现象描述</h2><p>线上系统刚上线后运行正常，使用一段时间后出现频繁 Full GC 现象，系统出现卡顿，但是一直没有出现内存溢出，所以设置内存溢出后生成 dump 文件无效，重启后现象消失，运行一段时间后重复出现上述问题。</p><a id="more"></a><p>由于初期系统访问并发量并不是很大，而且改动上线比较频繁，所以问题并不明显，但是系统稳定后上线频率降低，运行比较长一段时间后就会出现上述问题。最后在线上系统频繁出现 Full GC 时通过 jmap 命令生成 java 堆 dump 文件，查看 java 堆内存中年轻代、年老代内存使用情况，最终确定了问题根源。</p><p>PS. 由于是事后复盘问题，所以线上监控系统监测到到的频繁 Full GC 现象没能截图保存下来，比较遗憾。</p><h2 id="问题代码"><a href="#问题代码" class="headerlink" title="问题代码"></a>问题代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParamsUtils</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String,JSONObject&gt; JSON_OBJ_MAP = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object objForLock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_MAP_SIZE = <span class="number">50000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取已经JSONObject的对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> body Json字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> json格式化后的对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> JSONObject <span class="title">getJson</span><span class="params">(String body)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(body)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String key = MD5Util.md5Hex(body);</span><br><span class="line">        <span class="keyword">if</span> (JSON_OBJ_MAP.containsKey(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> JSON_OBJ_MAP.get(key);</span><br><span class="line">        &#125;</span><br><span class="line">        JSONObject bodyObject = JSONObject.fromObject(body);</span><br><span class="line">        <span class="keyword">if</span> (!bodyObject.isNullObject() &amp;&amp; !bodyObject.isEmpty() &amp;&amp; !JSON_OBJ_MAP.containsKey(key)) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (objForLock) &#123;</span><br><span class="line">                <span class="keyword">if</span>(!JSON_OBJ_MAP.containsKey(key))&#123;</span><br><span class="line">                    JSON_OBJ_MAP.put(key, bodyObject);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bodyObject;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码的主要作用是解析网关接口的公共参数，将字符串参数转换为 JSON 对象，网关接口的格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 关键敏感信息已脱敏</span><br><span class="line">http://www.abc.com/client.action?functionId=test&amp;body=&#123;&quot;param1&quot;:&quot;value1&quot;,&quot;param2&quot;:&quot;value2&quot;,&quot;param3&quot;:&quot;value3&quot;&#125;</span><br></pre></td></tr></table></figure><p>ParamsUtils 类就是解析 URL 中 body 参数并转换为 JSON 对象的公共类。在转换过程中，主要经过以下几步：</p><ul><li>解析参数字符串并转换为 JSON 对象；</li><li>body 字符串进行 MD5 操作，生成 key；</li><li>判断 key 是否存在，不存在直接 put 进全局 JSON_OBJ_MAP 中。</li></ul><p>JSON_OBJ_MAP 全局 Map 对象的主要作用应该是作为缓存使用，如果相同 body 参数已经解析过，不再重复解析，减少解析操作耗时（可能想法是好的，但是实现的方式感觉并不优雅，后面我们再分析）。</p><h2 id="复盘步骤-amp-环境"><a href="#复盘步骤-amp-环境" class="headerlink" title="复盘步骤 &amp; 环境"></a>复盘步骤 &amp; 环境</h2><p>为了更直白的说明问题，我在本地准备了测试环境，通过一些特殊条件快速复现出问题现象，来说明问题：</p><ul><li>通过 main 方法拼接 body 参数字符串，而且每次 body 参数内容都不相同，这样 JSON_OBJ_MAP 缓存失效，每次要放入内容都不同，会持续进行 put 操作；</li><li>通过 main 方法方式模拟大量请求解析参数过程，线上流量比较小，系统运行很长时间才会出现 Full GC，而且几乎不出现内存溢出情况，通过 mian 方法循环方式，可以快速模拟出现 Full GC 情况，而且一段时间后还会出现内存溢出；</li><li>通过 main 方法中创建的 body 字符串，通过某个参数使用长文本字符串，创建大字符串对象，快速消耗内存；</li><li>调整本地内存大小，线上服务器内存比较大，所以才会在运行一段时间后出现问题，测试环境可以减小 jvm 内存设置，使问题快速出现，而且还可以设置一些 jvm 垃圾回收参数，分析系统运行，直至出现内存溢出过程中内存使用情况。</li></ul><p>测试 main 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5000000</span>; i++) &#123;</span><br><span class="line">        String a = <span class="string">"&#123;\"pin\":\"xxxxxxxx\",\"content\":\"测试数据测试数据\",\"index\":%s&#125;"</span>;</span><br><span class="line">        ParamsUtils.getJson(String.format(a, i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内存设置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 内存设置</span><br><span class="line">-Xms500m -Xmx500m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/data/dump/java_pid.hprof -XX:+PrintGCDetails</span><br></pre></td></tr></table></figure><p>Java 堆内存使用情况</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 152064K, used 133632K [0x00000007f5900000, 0x0000000800000000, 0x0000000800000000)</span><br><span class="line">  eden space 133632K, 100% used [0x00000007f5900000,0x00000007fdb80000,0x00000007fdb80000)</span><br><span class="line">  from space 18432K, 0% used [0x00000007fdb80000,0x00000007fdb80000,0x00000007fed80000)</span><br><span class="line">  to   space 18432K, 0% used [0x00000007fee00000,0x00000007fee00000,0x0000000800000000)</span><br><span class="line"> ParOldGen       total 341504K, used 341488K [0x00000007e0b80000, 0x00000007f5900000, 0x00000007f5900000)</span><br><span class="line">  object space 341504K, 99% used [0x00000007e0b80000,0x00000007f58fc0d8,0x00000007f5900000)</span><br><span class="line"> PSPermGen       total 21504K, used 7946K [0x00000007db980000, 0x00000007dce80000, 0x00000007e0b80000)</span><br><span class="line">  object space 21504K, 36% used [0x00000007db980000,0x00000007dc142878,0x00000007dce80000)</span><br></pre></td></tr></table></figure><h2 id="java堆dump文件分析"><a href="#java堆dump文件分析" class="headerlink" title="java堆dump文件分析"></a>java堆dump文件分析</h2><img src="https://gitee.com/dongzl/article-images/raw/master/2019/05-online-system-frequent-full-gc-bug/online-system-frequent-full-gc-bug-01.jpg" width="600px"><img src="https://gitee.com/dongzl/article-images/raw/master/2019/05-online-system-frequent-full-gc-bug/online-system-frequent-full-gc-bug-02.png" width="600px"><p>通过 MAT 工具查看 dump.hprof 文件，问题还是比较明显的（现在想不明白为什么当时定位这个问题花了好长时间，可能是“事后诸葛亮”，现在逆向反推感觉好简单^_^）。</p><p>主要的问题就是 JSON_OBJ_MAP 中持有大量对象不会释放，而且从系统运行角度而言，JSON_OBJ_MAP 只会一直往里 put 内容，不会进行移除，所以系统运行越久，JSON_OBJ_MAP 中存储的内容就越多，直到系统重启后，JSON_OBJ_MAP 中内容会被清空。</p><h2 id="第一版代码修改"><a href="#第一版代码修改" class="headerlink" title="第一版代码修改"></a>第一版代码修改</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParamsUtils</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String,JSONObject&gt; JSON_OBJ_MAP = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object objForLock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_MAP_SIZE = <span class="number">50000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取已经JSONObject的对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> body Json字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> json格式化后的对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> JSONObject <span class="title">getJson</span><span class="params">(String body)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(body)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String key = MD5Util.md5Hex(body);</span><br><span class="line">        <span class="keyword">if</span> (JSON_OBJ_MAP.containsKey(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> JSON_OBJ_MAP.get(key);</span><br><span class="line">        &#125;</span><br><span class="line">        JSONObject bodyObject = JSONObject.fromObject(body);</span><br><span class="line">        <span class="keyword">if</span> (!bodyObject.isNullObject() &amp;&amp; !bodyObject.isEmpty() &amp;&amp; !JSON_OBJ_MAP.containsKey(key)) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (objForLock) &#123;</span><br><span class="line">                <span class="comment">//释放</span></span><br><span class="line">                <span class="keyword">if</span>(JSON_OBJ_MAP.size() &gt; MAX_MAP_SIZE) &#123;</span><br><span class="line">                    JSON_OBJ_MAP = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(!JSON_OBJ_MAP.containsKey(key))&#123;</span><br><span class="line">                    JSON_OBJ_MAP.put(key, bodyObject);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bodyObject;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一版修改后加入条件判断，如果 JSON_OBJ_MAP 中存储元素数量大于  5W，重新初始化，释放 Map 中内容；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//释放</span></span><br><span class="line"><span class="keyword">if</span>(JSON_OBJ_MAP.size() &gt; MAX_MAP_SIZE) &#123;</span><br><span class="line">    JSON_OBJ_MAP = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">// JSON_OBJ_MAP.clear(); //也可以通过调用 clear() 方法的方式。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实这种方式上线后系统性能有所改观，但是还是没能避免前面的问题（当然这还是有一种事后分析的思路，因为最初修改后也感觉没问题）。</p><p>在 JSON_OBJ_MAP 中元素个数还是会从 0 增长到 5W，然后释放掉，再重复上述过程；其实对于 body 参数长度，根据不同的 URL 请求长度都是不固定的，如果某段时间 body 体比较大，也会占用比较多内存，而且当 JSON_OBJ_MAP 中元素个数接近 5W 而没有达到 5W 的时候还是会触发频繁的 Full GC。</p><p>我个人理解对于 5W 个元素这个限制，最大的作用是能够保证线上代码即使运行足够长时间也大概率不会出现内存溢出（只是大概率，如果某些 body 比较大，可能还没 5W 就直接内存溢出了），如果没有 5W 元素个数限制，线上代码运行足够长时间后理论上一定会出现内存溢出，我们线上的系统之所以没出现，可能是因为连续运行时间不足够长，还没到内存溢出条件就上线或重启等操作释放掉内存了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 年轻代内存回收 &amp; 年老代内存回收 交替打印</span><br><span class="line">... ...</span><br><span class="line">[GC [PSYoungGen: 62720K-&gt;5376K(114176K)] 380088K-&gt;327793K(455680K), 0.0028630 secs] [Times: user=0.02 sys=0.00, real=0.00 secs] </span><br><span class="line">[GC [PSYoungGen: 62720K-&gt;5408K(114176K)] 385137K-&gt;332869K(455680K), 0.0025480 secs] [Times: user=0.02 sys=0.00, real=0.00 secs] </span><br><span class="line">[Full GC [PSYoungGen: 5408K-&gt;0K(114176K)] [ParOldGen: 327461K-&gt;331078K(341504K)] 332869K-&gt;331078K(455680K) [PSPermGen: 7918K-&gt;7918K(21504K)], 0.2018180 secs] [Times: user=1.45 sys=0.01, real=0.20 secs] </span><br><span class="line">[Full GC [PSYoungGen: 57344K-&gt;0K(114176K)] [ParOldGen: 331078K-&gt;336099K(341504K)] 388422K-&gt;336099K(455680K) [PSPermGen: 7918K-&gt;7918K(21504K)], 0.0892940 secs] [Times: user=0.62 sys=0.00, real=0.08 secs] </span><br><span class="line"></span><br><span class="line">... ...</span><br></pre></td></tr></table></figure><img src="https://gitee.com/dongzl/article-images/raw/master/2019/05-online-system-frequent-full-gc-bug/online-system-frequent-full-gc-bug-03.jpg" width="600px"><img src="https://gitee.com/dongzl/article-images/raw/master/2019/05-online-system-frequent-full-gc-bug/online-system-frequent-full-gc-bug-04.jpg" width="600px"><h2 id="第二版代码修改"><a href="#第二版代码修改" class="headerlink" title="第二版代码修改"></a>第二版代码修改</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParamsUtils</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String,JSONObject&gt; JSON_OBJ_MAP = <span class="keyword">new</span> WeakHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object objForLock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取已经JSONObject的对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> body Json字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> json格式化后的对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> JSONObject <span class="title">getJson</span><span class="params">(String body)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(body)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String key = MD5Util.md5Hex(body);</span><br><span class="line">        <span class="keyword">if</span> (JSON_OBJ_MAP.containsKey(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> JSON_OBJ_MAP.get(key);</span><br><span class="line">        &#125;</span><br><span class="line">        JSONObject bodyObject = JSONObject.fromObject(body);</span><br><span class="line">        <span class="keyword">if</span> (!bodyObject.isNullObject() &amp;&amp; !bodyObject.isEmpty() &amp;&amp; !JSON_OBJ_MAP.containsKey(key)) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (objForLock) &#123;</span><br><span class="line">                <span class="keyword">if</span>(!JSON_OBJ_MAP.containsKey(key))&#123;</span><br><span class="line">                    JSON_OBJ_MAP.put(key, bodyObject);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bodyObject;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过使用 WeakHashMap() ，不再使用强引用的 HashMap()，WeakHashMap() 由于是弱引用，put 进去的元素也是可以被垃圾回收掉的，一般元素在 Young GC的时候就可以被回收掉，不会进入老年代触发 Full GC，可以解决这个问题，其实如果使用 WeakHashMap() 存储结构，5W 个元素的限制也可以去掉，不会有问题。</p><p>不过这里会有另外一个问题，JSON_OBJ_MAP 其实是作为一个本地缓存使用，如果使用 WeakHashMap() 存储结构，里面元素被快速垃圾回收掉，下次同样一个 body 参数体还需要进行解析，这样就降低了 JSON_OBJ_MAP 作为一个本地缓存的价值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 只有年轻代出现垃圾回收</span><br><span class="line">... ... </span><br><span class="line">[GC [PSYoungGen: 156704K-&gt;13248K(157184K)] 186190K-&gt;42766K(498688K), 0.0034030 secs] [Times: user=0.02 sys=0.00, real=0.00 secs] </span><br><span class="line">[GC [PSYoungGen: 156608K-&gt;13280K(157184K)] 186126K-&gt;42830K(498688K), 0.0033730 secs] [Times: user=0.02 sys=0.00, real=0.00 secs] </span><br><span class="line">[GC [PSYoungGen: 156640K-&gt;13312K(157184K)] 186190K-&gt;42902K(498688K), 0.0027250 secs] [Times: user=0.01 sys=0.00, real=0.00 secs] </span><br><span class="line">[GC [PSYoungGen: 156672K-&gt;13280K(157184K)] 186262K-&gt;42894K(498688K), 0.0027370 secs] [Times: user=0.01 sys=0.00, real=0.00 secs] </span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 157184K, used 156640K [0x00000007f5900000, 0x0000000800000000, 0x0000000800000000)</span><br><span class="line">  eden space 143360K, 100% used [0x00000007f5900000,0x00000007fe500000,0x00000007fe500000)</span><br><span class="line">  from space 13824K, 96% used [0x00000007ff280000,0x00000007fff78000,0x0000000800000000)</span><br><span class="line">  to   space 13824K, 0% used [0x00000007fe500000,0x00000007fe500000,0x00000007ff280000)</span><br><span class="line"> ParOldGen       total 341504K, used 29614K [0x00000007e0b80000, 0x00000007f5900000, 0x00000007f5900000)</span><br><span class="line">  object space 341504K, 8% used [0x00000007e0b80000,0x00000007e286bbb8,0x00000007f5900000)</span><br><span class="line"> PSPermGen       total 21504K, used 7934K [0x00000007db980000, 0x00000007dce80000, 0x00000007e0b80000)</span><br><span class="line">  object space 21504K, 36% used [0x00000007db980000,0x00000007dc13fa48,0x00000007dce80000)</span><br></pre></td></tr></table></figure><img src="https://gitee.com/dongzl/article-images/raw/master/2019/05-online-system-frequent-full-gc-bug/online-system-frequent-full-gc-bug-05.jpg" width="600px"><h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><p>除去前面提到的 Full GC 问题，单独看这段代码的实现，还是有值得思考的地方的，这是一个网关请求参数的公共解析类，线上系统流量进来之后，请求参数首先要这个类处理，这个类中对于全局变量 JSON_OBJ_MAP 的写操作是同步的，也就是如果有写操作，每次只有一个线程可以拿到锁，其它线程被阻塞，需要排队等待执行。</p><p>如果是在高并发情况下，系统刚刚上线的时候，JSON_OBJ_MAP 为空，会触发大量的写操作，而排队写操作会导致每个请求进来都要排队进行参数解析，等待解析结果再执行业务逻辑，这样会很大程度上降低系统的吞吐量，使用 JSON_OBJ_MAP 缓存解析结果可能在下次请求会节省一点时间，但是相比较同步阻塞的时间，可能有点得不偿失，而且目前业界开源的一些 JSON 解析工具，性能都是非常不错的，其实完全没有必要进行本地缓存，这个类完全可以改造成只进行公共参数解析，不进行本地缓存的实现。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;现象描述&quot;&gt;&lt;a href=&quot;#现象描述&quot; class=&quot;headerlink&quot; title=&quot;现象描述&quot;&gt;&lt;/a&gt;现象描述&lt;/h2&gt;&lt;p&gt;线上系统刚上线后运行正常，使用一段时间后出现频繁 Full GC 现象，系统出现卡顿，但是一直没有出现内存溢出，所以设置内存溢出后生成 dump 文件无效，重启后现象消失，运行一段时间后重复出现上述问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java开发" scheme="https://dongzl.github.io/categories/java%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JVM" scheme="https://dongzl.github.io/tags/JVM/"/>
    
      <category term="Full GC" scheme="https://dongzl.github.io/tags/Full-GC/"/>
    
      <category term="MAT" scheme="https://dongzl.github.io/tags/MAT/"/>
    
  </entry>
  
</feed>
