<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>董宗磊的博客</title>
  
  <subtitle>董宗磊的博客--靡不有初，鲜克有终</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://dongzl.github.io/"/>
  <updated>2020-06-06T01:26:50.310Z</updated>
  <id>https://dongzl.github.io/</id>
  
  <author>
    <name>[object Object]</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《算法训练营》课堂笔记 &amp; 习题</title>
    <link href="https://dongzl.github.io/2020/06/04/29-Algorithm-Training-Note/"/>
    <id>https://dongzl.github.io/2020/06/04/29-Algorithm-Training-Note/</id>
    <published>2020-06-04T06:27:31.000Z</published>
    <updated>2020-06-06T01:26:50.310Z</updated>
    
    <content type="html"><![CDATA[<h3 id="第01课丨数据结构与算法总览"><a href="#第01课丨数据结构与算法总览" class="headerlink" title="第01课丨数据结构与算法总览"></a>第01课丨数据结构与算法总览</h3><h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><ul><li><a href="http://naotu.baidu.com/file/b832f043e2ead159d584cca4efb19703?token=7a6a56eb2630548c" target="_blank" rel="noopener">数据结构脑图</a></li><li><a href="http://naotu.baidu.com/file/0a53d3a5343bd86375f348b2831d3610?token=5ab1de1c90d5f3ec" target="_blank" rel="noopener">算法脑图</a></li></ul><h4 id="课后作业"><a href="#课后作业" class="headerlink" title="课后作业"></a>课后作业</h4><p><strong>绘制自己的数据结构和算法脑图</strong></p><p>用脑图的方式把知识的脉络串联起来，不管对于学习新知识还是巩固已有知识，都是一种很好的学习方式。同学们可以将目前自己所掌握的数据结构和算法知识绘制成脑图，在绘制过程中可以查阅资料，补充目前掌握欠缺的部分，找到自己薄弱的地方。后面再通过课程的学习和刻意练习，动态地将自己绘制的脑图逐步补充、完善，从而达到真正的融会贯通。</p><p>脑图绘制工具不限，同学们需要按时将作业提交到班级 GitHub 中，具体作业提交方式戳此<a href="http://u.geekbang.org/lesson/1?article=144228" target="_blank" rel="noopener">查看</a>。</p><h3 id="第02课丨训练准备和复杂度分析"><a href="#第02课丨训练准备和复杂度分析" class="headerlink" title="第02课丨训练准备和复杂度分析"></a>第02课丨训练准备和复杂度分析</h3><h4 id="参考链接-1"><a href="#参考链接-1" class="headerlink" title="参考链接"></a>参考链接</h4><ul><li><a href="https://github.com/microsoft/terminal" target="_blank" rel="noopener">Windows Microsoft New Terminal</a></li><li><a href="https://vscodethemes.com/" target="_blank" rel="noopener">VS Code Themes</a></li><li><a href="https://juejin.im/entry/587e0f2f570c352201113e14" target="_blank" rel="noopener">教你打造一款颜值逆天的 VS Code</a></li><li><a href="https://juejin.im/post/5ce1365151882525ff28ed47" target="_blank" rel="noopener">炫酷的 VS Code 毛玻璃效果</a></li><li><a href="https://markhneedham.com/blog/2008/09/15/clean-code-book-review/" target="_blank" rel="noopener">自顶向下的编程方式</a></li><li><a href="http://leetcode-cn.com/problems/valid-palindrome/" target="_blank" rel="noopener">自顶向下编程的 LeetCode 例题</a></li></ul><h4 id="参考链接-2"><a href="#参考链接-2" class="headerlink" title="参考链接"></a>参考链接</h4><ul><li><a href="https://www.zhihu.com/question/21387264" target="_blank" rel="noopener">如何理解算法时间复杂度的表示法</a></li><li><a href="https://en.wikipedia.org/wiki/Master_theorem_(analysis_of_algorithms)" target="_blank" rel="noopener">Master theorem</a></li><li><a href="https://zh.wikipedia.org/wiki/%E4%B8%BB%E5%AE%9A%E7%90%86" target="_blank" rel="noopener">主定理</a></li></ul><h3 id="第03课丨数组、链表、跳表"><a href="#第03课丨数组、链表、跳表" class="headerlink" title="第03课丨数组、链表、跳表"></a>第03课丨数组、链表、跳表</h3><h3 id="参考链接-3"><a href="#参考链接-3" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="http://developer.classpath.org/doc/java/util/ArrayList-source.html" target="_blank" rel="noopener">Java 源码分析（ArrayList）</a></li><li><a href="http://www.geeksforgeeks.org/implementing-a-linked-list-in-java-using-class/" target="_blank" rel="noopener">Linked List 的标准实现代码</a></li><li><a href="http://www.cs.cmu.edu/~adamchik/15-121/lectures/Linked%20Lists/code/LinkedList.java" target="_blank" rel="noopener">Linked List 示例代码</a></li><li><a href="http://developer.classpath.org/doc/java/util/LinkedList-source.html" target="_blank" rel="noopener">Java 源码分析（LinkedList）</a></li><li><a href="https://leetcode-cn.com/problems/lru-cache/" target="_blank" rel="noopener">LRU Cache - Linked list： LRU 缓存机制</a></li><li><a href="https://www.zhihu.com/question/20202931" target="_blank" rel="noopener">Redis - Skip List：跳跃表、为啥 Redis 使用跳表（Skip List）而不是使用 Red-Black？</a></li></ul><h4 id="Array-实战题目"><a href="#Array-实战题目" class="headerlink" title="Array 实战题目"></a>Array 实战题目</h4><ul><li><a href="https://leetcode-cn.com/problems/two-sum/" target="_blank" rel="noopener">1. 两数之和</a></li><li><a href="https://leetcode-cn.com/problems/container-with-most-water/" target="_blank" rel="noopener">11. 盛最多水的容器</a></li><li><a href="https://leetcode-cn.com/problems/3sum/" target="_blank" rel="noopener">15. 三数之和</a> (高频老题）</li><li><a href="https://leetcode.com/problems/climbing-stairs/" target="_blank" rel="noopener">70. 爬楼梯</a></li><li><a href="https://leetcode-cn.com/problems/move-zeroes/" target="_blank" rel="noopener">283. 移动零</a></li></ul><h4 id="Linked-List-实战题目"><a href="#Linked-List-实战题目" class="headerlink" title="Linked List 实战题目"></a>Linked List 实战题目</h4><ul><li><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs" target="_blank" rel="noopener">24. 两两交换链表中的节点</a></li><li><a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/" target="_blank" rel="noopener">25. K 个一组翻转链表</a></li><li><a href="https://leetcode-cn.com/problems/linked-list-cycle" target="_blank" rel="noopener">141. 环形链表</a></li><li><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii" target="_blank" rel="noopener">142. 环形链表 II</a></li><li><a href="https://leetcode-cn.com/problems/reverse-linked-list/" target="_blank" rel="noopener">206. 反转链表</a></li></ul><h4 id="课后作业-1"><a href="#课后作业-1" class="headerlink" title="课后作业"></a>课后作业</h4><ul><li><a href="https://leetcode-cn.com/problems/two-sum/" target="_blank" rel="noopener">1. 两数之和</a></li><li><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener">21. 合并两个有序链表</a></li><li><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/" target="_blank" rel="noopener">26. 删除排序数组中的重复项</a></li><li><a href="https://leetcode-cn.com/problems/plus-one/" target="_blank" rel="noopener">66. 加一</a></li><li><a href="https://leetcode-cn.com/problems/merge-sorted-array/" target="_blank" rel="noopener">88. 合并两个有序数组</a></li><li><a href="https://leetcode-cn.com/problems/rotate-array/" target="_blank" rel="noopener">189. 旋转数组</a></li><li><a href="https://leetcode-cn.com/problems/move-zeroes/" target="_blank" rel="noopener">283. 移动零</a></li></ul><h3 id="第04课丨栈、队列、优先队列、双端队列"><a href="#第04课丨栈、队列、优先队列、双端队列" class="headerlink" title="第04课丨栈、队列、优先队列、双端队列"></a>第04课丨栈、队列、优先队列、双端队列</h3><h4 id="参考链接-4"><a href="#参考链接-4" class="headerlink" title="参考链接"></a>参考链接</h4><ul><li><a href="https://docs.oracle.com/javase/10/docs/api/java/util/PriorityQueue.html" target="_blank" rel="noopener">Java 的 PriorityQueue 文档</a></li><li><a href="http://developer.classpath.org/doc/java/util/Stack-source.html" target="_blank" rel="noopener">Java 的 Stack 源码</a></li><li><a href="http://fuseyism.com/classpath/doc/java/util/Queue-source.html" target="_blank" rel="noopener">Java 的 Queue 源码</a></li><li><a href="https://docs.python.org/2/library/heapq.html" target="_blank" rel="noopener">Python 的 heapq</a></li><li><a href="https://docs.python.org/2/library/collections.html" target="_blank" rel="noopener">高性能的 container 库</a></li></ul><h4 id="预习题目"><a href="#预习题目" class="headerlink" title="预习题目"></a>预习题目</h4><ul><li><a href="https://leetcode-cn.com/problems/valid-parentheses/" target="_blank" rel="noopener">20. 有效的括号</a></li><li><a href="https://leetcode-cn.com/problems/min-stack/" target="_blank" rel="noopener">155. 最小栈</a></li></ul><h4 id="实战题目"><a href="#实战题目" class="headerlink" title="实战题目"></a>实战题目</h4><ul><li><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram" target="_blank" rel="noopener">84. 柱状图中最大的矩形</a></li><li><a href="https://leetcode-cn.com/problems/sliding-window-maximum" target="_blank" rel="noopener">239. 滑动窗口最大值</a></li></ul><h4 id="课后作业-2"><a href="#课后作业-2" class="headerlink" title="课后作业"></a>课后作业</h4><ul><li>用 add first 或 add last 这套新的 API 改写 Deque 的代码</li><li>分析 Queue 和 Priority Queue 的源码</li><li><a href="https://leetcode.com/problems/trapping-rain-water/" target="_blank" rel="noopener">42. 接雨水</a></li><li><a href="https://leetcode.com/problems/design-circular-deque/" target="_blank" rel="noopener">641. 设计循环双端队列</a></li></ul><p><strong>说明：改写代码和分析源码这两项作业，同学们需要在第 1 周的学习总结中完成。如果不熟悉 Java 语言，这两项作业可选做。</strong></p><h3 id="第05课丨哈希表、映射、集合"><a href="#第05课丨哈希表、映射、集合" class="headerlink" title="第05课丨哈希表、映射、集合"></a>第05课丨哈希表、映射、集合</h3><h4 id="参考链接-5"><a href="#参考链接-5" class="headerlink" title="参考链接"></a>参考链接</h4><ul><li><a href="https://docs.oracle.com/en/java/javase/12/docs/api/java.base/java/util/Set.html" target="_blank" rel="noopener">Java Set 文档</a></li><li><a href="https://docs.oracle.com/en/java/javase/12/docs/api/java.base/java/util/Map.html" target="_blank" rel="noopener">Java Map 文档</a></li></ul><h4 id="课后作业-3"><a href="#课后作业-3" class="headerlink" title="课后作业"></a>课后作业</h4><p><strong>写一个关于 HashMap 的小总结。<br>说明：对于不熟悉 Java 语言的同学，此项作业可选做。</strong></p><h4 id="实战题目-课后作业"><a href="#实战题目-课后作业" class="headerlink" title="实战题目 / 课后作业"></a>实战题目 / 课后作业</h4><ul><li><a href="https://leetcode-cn.com/problems/two-sum/" target="_blank" rel="noopener">1. 两数之和</a></li><li><a href="https://leetcode-cn.com/problems/group-anagrams/" target="_blank" rel="noopener">49. 字母异位词分组</a></li><li><a href="https://leetcode-cn.com/problems/valid-anagram/" target="_blank" rel="noopener">242. 有效的字母异位词</a></li></ul><h4 id="参考链接-6"><a href="#参考链接-6" class="headerlink" title="参考链接"></a>参考链接</h4><ul><li><a href="https://shimo.im/docs/R6g9WJV89QkHrDhr/read" target="_blank" rel="noopener">养成收藏精选代码的习惯（示例）</a></li></ul><h3 id="第06课丨树、二叉树、二叉搜索树"><a href="#第06课丨树、二叉树、二叉搜索树" class="headerlink" title="第06课丨树、二叉树、二叉搜索树"></a>第06课丨树、二叉树、二叉搜索树</h3><h4 id="参考链接-7"><a href="#参考链接-7" class="headerlink" title="参考链接"></a>参考链接</h4><ul><li><a href="https://visualgo.net/zh/bst" target="_blank" rel="noopener">二叉搜索树 Demo</a></li></ul><h4 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h4><p><strong>树的面试题解法一般都是递归，为什么？<br>说明：同学们可以将自己的思考写在课程下方的留言区一起讨论，也可以写在第 2 周的学习总结中。</strong></p><h4 id="参考链接-8"><a href="#参考链接-8" class="headerlink" title="参考链接"></a>参考链接</h4><ul><li><a href="https://visualgo.net/zh/bst?slide=1" target="_blank" rel="noopener">树的遍历 Demo</a></li></ul><h4 id="实战题目-课后作业-1"><a href="#实战题目-课后作业-1" class="headerlink" title="实战题目 / 课后作业"></a>实战题目 / 课后作业</h4><ul><li><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">94. 二叉树的中序遍历</a></li><li><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/" target="_blank" rel="noopener">144. 二叉树的前序遍历</a></li><li><a href="https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/" target="_blank" rel="noopener">429. N叉树的层序遍历</a></li><li><a href="https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/" target="_blank" rel="noopener">589. N叉树的前序遍历</a></li><li><a href="https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/" target="_blank" rel="noopener">590. N叉树的后序遍历</a></li></ul><h3 id="第07课丨泛型递归、树的递归"><a href="#第07课丨泛型递归、树的递归" class="headerlink" title="第07课丨泛型递归、树的递归"></a>第07课丨泛型递归、树的递归</h3><h4 id="参考链接-9"><a href="#参考链接-9" class="headerlink" title="参考链接"></a>参考链接</h4><ul><li><a href="https://shimo.im/docs/DjqqGCT3xqDYwPyY" target="_blank" rel="noopener">递归代码模板</a></li></ul><h4 id="实战题目-1"><a href="#实战题目-1" class="headerlink" title="实战题目"></a>实战题目</h4><ul><li><a href="https://leetcode-cn.com/problems/generate-parentheses/" target="_blank" rel="noopener">22. 括号生成</a></li><li><a href="https://leetcode-cn.com/problems/climbing-stairs/" target="_blank" rel="noopener">70. 爬楼梯</a></li><li><a href="https://leetcode-cn.com/problems/validate-binary-search-tree" target="_blank" rel="noopener">98. 验证二叉搜索树</a></li><li><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree" target="_blank" rel="noopener">104. 二叉树的最大深度</a></li><li><a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree" target="_blank" rel="noopener">111. 二叉树的最小深度</a></li><li><a href="https://leetcode-cn.com/problems/invert-binary-tree/description/" target="_blank" rel="noopener">226. 翻转二叉树</a></li><li><a href="https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/" target="_blank" rel="noopener">297. 二叉树的序列化与反序列化</a></li></ul><h4 id="每日一课"><a href="#每日一课" class="headerlink" title="每日一课"></a>每日一课</h4><ul><li><a href="https://time.geekbang.org/dailylesson/detail/100028406" target="_blank" rel="noopener">如何优雅地计算斐波那契数列</a></li></ul><h4 id="课后作业-4"><a href="#课后作业-4" class="headerlink" title="课后作业"></a>课后作业</h4><ul><li><a href="https://leetcode-cn.com/problems/permutations/" target="_blank" rel="noopener">46. 全排列</a></li><li><a href="https://leetcode-cn.com/problems/permutations-ii/" target="_blank" rel="noopener">47. 全排列 II</a></li><li><a href="https://leetcode-cn.com/problems/combinations/" target="_blank" rel="noopener">77. 组合</a></li><li><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal" target="_blank" rel="noopener">105. 从前序与中序遍历序列构造二叉树</a></li><li><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/" target="_blank" rel="noopener">236. 二叉树的最近公共祖先</a></li></ul><h3 id="第08课丨分治、回溯"><a href="#第08课丨分治、回溯" class="headerlink" title="第08课丨分治、回溯"></a>第08课丨分治、回溯</h3><h4 id="参考链接-10"><a href="#参考链接-10" class="headerlink" title="参考链接"></a>参考链接</h4><ul><li><a href="https://shimo.im/docs/3xvghYh3JJPKwdvt" target="_blank" rel="noopener">分治代码模板</a></li><li><a href="https://leetcode-cn.com/problems/generate-parentheses/" target="_blank" rel="noopener">括号生成问题</a></li></ul><h4 id="预习题目-1"><a href="#预习题目-1" class="headerlink" title="预习题目"></a>预习题目</h4><ul><li><a href="https://leetcode-cn.com/problems/powx-n/" target="_blank" rel="noopener">50. Pow(x, n)</a></li><li><a href="https://leetcode-cn.com/problems/subsets/" target="_blank" rel="noopener">78. 子集</a></li></ul><h4 id="参考链接-11"><a href="#参考链接-11" class="headerlink" title="参考链接"></a>参考链接</h4><ul><li><a href="http://www.matrix67.com/blog/archives/361" target="_blank" rel="noopener">牛顿迭代法原理</a></li><li><a href="http://www.voidcn.com/article/p-eudisdmk-zm.html" target="_blank" rel="noopener">牛顿迭代法代码</a></li></ul><h4 id="实战题目-2"><a href="#实战题目-2" class="headerlink" title="实战题目"></a>实战题目</h4><ul><li><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/" target="_blank" rel="noopener">17. 电话号码的字母组合</a></li><li><a href="https://leetcode-cn.com/problems/n-queens/" target="_blank" rel="noopener">51. N皇后</a></li><li><a href="https://leetcode-cn.com/problems/majority-element/description/" target="_blank" rel="noopener">169. 多数元素</a> （简单、但是高频）</li></ul><h3 id="第09课丨深度优先搜索和广度优先搜索"><a href="#第09课丨深度优先搜索和广度优先搜索" class="headerlink" title="第09课丨深度优先搜索和广度优先搜索"></a>第09课丨深度优先搜索和广度优先搜索</h3><h4 id="参考链接-12"><a href="#参考链接-12" class="headerlink" title="参考链接"></a>参考链接</h4><ul><li><a href="https://shimo.im/docs/ddgwCccJQKxkrcTq" target="_blank" rel="noopener">DFS 代码模板（递归写法、非递归写法）</a></li><li><a href="https://shimo.im/docs/P8TqKHGKt3ytkYYd" target="_blank" rel="noopener">BFS 代码模板</a></li></ul><h4 id="实战题目-3"><a href="#实战题目-3" class="headerlink" title="实战题目"></a>实战题目</h4><ul><li><a href="https://leetcode-cn.com/problems/generate-parentheses/" target="_blank" rel="noopener">22. 括号生成</a></li><li><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">102. 二叉树的层序遍历</a></li><li><a href="https://leetcode-cn.com/problems/minimum-genetic-mutation/" target="_blank" rel="noopener">433. 最小基因变化</a></li><li><a href="https://leetcode-cn.com/problems/find-largest-value-in-each-tree-row/" target="_blank" rel="noopener">515. 在每个树行中找最大值</a></li></ul><h4 id="课后作业-5"><a href="#课后作业-5" class="headerlink" title="课后作业"></a>课后作业</h4><ul><li><a href="https://leetcode-cn.com/problems/word-ladder-ii/" target="_blank" rel="noopener">126. 单词接龙 II</a></li><li><a href="https://leetcode-cn.com/problems/word-ladder/" target="_blank" rel="noopener">127. 单词接龙</a></li><li><a href="https://leetcode-cn.com/problems/number-of-islands/" target="_blank" rel="noopener">200. 岛屿数量</a></li><li><a href="https://leetcode-cn.com/problems/minesweeper/" target="_blank" rel="noopener">529. 扫雷游戏</a></li></ul><h3 id="第10课丨贪心算法"><a href="#第10课丨贪心算法" class="headerlink" title="第10课丨贪心算法"></a>第10课丨贪心算法</h3><h4 id="参考链接-13"><a href="#参考链接-13" class="headerlink" title="参考链接"></a>参考链接</h4><ul><li><a href="https://leetcode-cn.com/problems/coin-change/" target="_blank" rel="noopener">coin change 题目</a></li><li><a href="https://zh.wikipedia.org/wiki/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92" target="_blank" rel="noopener">动态规划定义</a></li></ul><h4 id="课后作业-6"><a href="#课后作业-6" class="headerlink" title="课后作业"></a>课后作业</h4><ul><li><a href="https://leetcode-cn.com/problems/jump-game-ii/" target="_blank" rel="noopener">45. 跳跃游戏 II</a></li><li><a href="https://leetcode-cn.com/problems/jump-game/" target="_blank" rel="noopener">55. 跳跃游戏</a></li><li><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/" target="_blank" rel="noopener">122. 买卖股票的最佳时机 II</a></li><li><a href="https://leetcode-cn.com/problems/assign-cookies/" target="_blank" rel="noopener">455. 分发饼干</a></li><li><a href="https://leetcode-cn.com/problems/walking-robot-simulation/" target="_blank" rel="noopener">874. 模拟行走机器人</a></li><li><a href="https://leetcode-cn.com/problems/lemonade-change/" target="_blank" rel="noopener">860. 柠檬水找零</a></li></ul><h3 id="第11课丨二分查找"><a href="#第11课丨二分查找" class="headerlink" title="第11课丨二分查找"></a>第11课丨二分查找</h3><h4 id="参考链接-14"><a href="#参考链接-14" class="headerlink" title="参考链接"></a>参考链接</h4><ul><li><a href="https://shimo.im/docs/hjQqRQkGgwd9g36J" target="_blank" rel="noopener">二分查找代码模板</a></li><li><a href="https://www.beyond3d.com/content/articles/8/" target="_blank" rel="noopener">Fast InvSqrt() 扩展阅读</a></li></ul><h4 id="实战题目-4"><a href="#实战题目-4" class="headerlink" title="实战题目"></a>实战题目</h4><ul><li><a href="https://leetcode-cn.com/problems/sqrtx/" target="_blank" rel="noopener">69. x 的平方根</a></li><li><a href="https://leetcode-cn.com/problems/valid-perfect-square/" target="_blank" rel="noopener">367. 有效的完全平方数</a></li></ul><h4 id="课后作业-7"><a href="#课后作业-7" class="headerlink" title="课后作业"></a>课后作业</h4><ul><li><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/" target="_blank" rel="noopener">33. 搜索旋转排序数组</a></li><li><a href="https://leetcode-cn.com/problems/search-a-2d-matrix/" target="_blank" rel="noopener">74. 搜索二维矩阵</a></li><li><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/" target="_blank" rel="noopener">153. 寻找旋转排序数组中的最小值</a></li></ul><p><strong>使用二分查找，寻找一个半有序数组 [4, 5, 6, 7, 0, 1, 2] 中间无序的地方<br>说明：同学们可以将自己的思路、代码写在第 3 周的学习总结中</strong></p><h3 id="第12课丨动态规划"><a href="#第12课丨动态规划" class="headerlink" title="第12课丨动态规划"></a>第12课丨动态规划</h3><h4 id="参考链接-15"><a href="#参考链接-15" class="headerlink" title="参考链接"></a>参考链接</h4><ul><li><a href="https://shimo.im/docs/DjqqGCT3xqDYwPyY/" target="_blank" rel="noopener">递归代码模板</a></li><li><a href="https://shimo.im/docs/3xvghYh3JJPKwdvt" target="_blank" rel="noopener">分治代码模板</a></li><li><a href="https://en.wikipedia.org/wiki/Dynamic_programming" target="_blank" rel="noopener">动态规划定义</a></li></ul><h4 id="参考链接-16"><a href="#参考链接-16" class="headerlink" title="参考链接"></a>参考链接</h4><ul><li><a href="https://leetcode-cn.com/problems/unique-paths/" target="_blank" rel="noopener">不同路径题目</a></li><li><a href="https://leetcode-cn.com/problems/unique-paths-ii/" target="_blank" rel="noopener">不同路径 2 题目</a></li><li><a href="https://leetcode-cn.com/problems/longest-common-subsequence/" target="_blank" rel="noopener">最长公共子序列题目</a></li><li><a href="https://www.bilibili.com/video/av53233912?from=search&seid=2847395688604491997" target="_blank" rel="noopener">MIT 动态规划课程最短路径算法</a></li></ul><h4 id="实战题目-5"><a href="#实战题目-5" class="headerlink" title="实战题目"></a>实战题目</h4><ul><li><a href="https://leetcode-cn.com/problems/maximum-subarray/" target="_blank" rel="noopener">53. 最大子序和</a></li><li><a href="https://leetcode-cn.com/problems/climbing-stairs/" target="_blank" rel="noopener">70. 爬楼梯</a></li><li><a href="https://leetcode-cn.com/problems/triangle/" target="_blank" rel="noopener">120. 三角形最小路径和</a></li><li><a href="https://leetcode.com/problems/triangle/discuss/38735/Python-easy-to-understand-solutions-(top-down-bottom-up)" target="_blank" rel="noopener">120. 三角形最小路径和</a></li><li><a href="https://leetcode-cn.com/problems/maximum-product-subarray/" target="_blank" rel="noopener">152. 乘积最大子数组</a></li><li><a href="https://leetcode-cn.com/problems/coin-change/" target="_blank" rel="noopener">322. 零钱兑换</a></li></ul><h4 id="实战题目-6"><a href="#实战题目-6" class="headerlink" title="实战题目"></a>实战题目</h4><ul><li><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener">121. 买卖股票的最佳时机</a></li><li><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/solution/yi-ge-fang-fa-tuan-mie-6-dao-gu-piao-wen-ti-by-l-3/" target="_blank" rel="noopener">121. 买卖股票的最佳时机</a></li><li><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/" target="_blank" rel="noopener">122. 买卖股票的最佳时机 II</a></li><li><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/" target="_blank" rel="noopener">123. 买卖股票的最佳时机 III</a></li><li><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/" target="_blank" rel="noopener">188. 买卖股票的最佳时机 IV</a></li><li><a href="https://leetcode-cn.com/problems/house-robber/" target="_blank" rel="noopener">198. 打家劫舍</a></li><li><a href="https://leetcode-cn.com/problems/house-robber-ii/" target="_blank" rel="noopener">213. 打家劫舍 II</a></li><li><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/" target="_blank" rel="noopener">309. 最佳买卖股票时机含冷冻期</a></li><li><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/" target="_blank" rel="noopener">714. 买卖股票的最佳时机含手续费</a></li></ul><h4 id="高级-DP-实战题目"><a href="#高级-DP-实战题目" class="headerlink" title="高级 DP 实战题目"></a>高级 DP 实战题目</h4><ul><li><a href="https://leetcode-cn.com/problems/jump-game-ii/" target="_blank" rel="noopener">45. 跳跃游戏 II</a></li><li><a href="https://leetcode-cn.com/problems/jump-game/" target="_blank" rel="noopener">55. 跳跃游戏</a></li><li><a href="https://leetcode-cn.com/problems/unique-paths/" target="_blank" rel="noopener">62. 不同路径</a></li><li><a href="https://leetcode-cn.com/problems/unique-paths-ii/" target="_blank" rel="noopener">63. 不同路径 II</a></li><li><a href="https://leetcode-cn.com/problems/edit-distance/" target="_blank" rel="noopener">72. 编辑距离</a> （重点）</li><li><a href="https://leetcode-cn.com/problems/perfect-squares/" target="_blank" rel="noopener">279. 完全平方数</a></li><li><a href="https://leetcode-cn.com/problems/coin-change/" target="_blank" rel="noopener">322. 零钱兑换</a></li><li><a href="https://leetcode-cn.com/problems/coin-change-2/" target="_blank" rel="noopener">518. 零钱兑换 II</a></li><li><a href="https://leetcode-cn.com/problems/unique-paths-iii/" target="_blank" rel="noopener">980. 不同路径 III</a></li></ul><p><strong>注意：请大家先消化前面的实战题目，高级 DP 的方法和题解会在课程后面解锁。</strong></p><h4 id="课后作业-8"><a href="#课后作业-8" class="headerlink" title="课后作业"></a>课后作业</h4><ul><li><a href="https://leetcode-cn.com/problems/longest-valid-parentheses/" target="_blank" rel="noopener">32. 最长有效括号</a></li><li><a href="https://leetcode-cn.com/problems/minimum-path-sum/" target="_blank" rel="noopener">64. 最小路径和</a></li><li><a href="https://leetcode-cn.com/problems/edit-distance/" target="_blank" rel="noopener">72. 编辑距离</a></li><li><a href="https://leetcode-cn.com/problems/minimum-window-substring/" target="_blank" rel="noopener">76. 最小覆盖子串Copy</a></li><li><a href="https://leetcode-cn.com/problems/decode-ways" target="_blank" rel="noopener">91. 解码方法</a></li><li><a href="https://leetcode-cn.com/problems/maximal-square/" target="_blank" rel="noopener">221. 最大正方形</a></li><li><a href="https://leetcode-cn.com/problems/burst-balloons/" target="_blank" rel="noopener">312. 戳气球</a></li><li><a href="https://leetcode-cn.com/problems/max-sum-of-rectangle-no-larger-than-k/" target="_blank" rel="noopener">363. 矩形区域不超过 K 的最大数值和</a></li><li><a href="https://leetcode-cn.com/problems/frog-jump/" target="_blank" rel="noopener">403. 青蛙过河</a></li><li><a href="https://leetcode-cn.com/problems/split-array-largest-sum" target="_blank" rel="noopener">410. 分割数组的最大值</a></li><li><a href="https://leetcode-cn.com/problems/student-attendance-record-ii/" target="_blank" rel="noopener">552. 学生出勤记录 II</a></li><li><a href="https://leetcode-cn.com/problems/task-scheduler/" target="_blank" rel="noopener">621. 任务调度器</a></li><li><a href="https://leetcode-cn.com/problems/palindromic-substrings/" target="_blank" rel="noopener">647. 回文子串</a></li></ul><h3 id="第13课丨字典树和并查集"><a href="#第13课丨字典树和并查集" class="headerlink" title="第13课丨字典树和并查集"></a>第13课丨字典树和并查集</h3><h4 id="参考链接-17"><a href="#参考链接-17" class="headerlink" title="参考链接"></a>参考链接</h4><ul><li><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">二叉树的层次遍历</a></li><li><a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/" target="_blank" rel="noopener">实现 Trie</a></li><li><a href="https://shimo.im/docs/Pk6vPY3HJ9hKkh33" target="_blank" rel="noopener">Tire 树代码模板</a></li></ul><h4 id="实战题目-课后作业-2"><a href="#实战题目-课后作业-2" class="headerlink" title="实战题目 / 课后作业"></a>实战题目 / 课后作业</h4><ul><li><a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/" target="_blank" rel="noopener">208. 实现 Trie (前缀树)</a></li><li><a href="https://leetcode-cn.com/problems/word-search-ii/" target="_blank" rel="noopener">212. 单词搜索 II</a></li></ul><p><strong>分析单词搜索 2 用 Tire 树方式实现的时间复杂度，请同学们提交在第 6 周的学习总结中。</strong></p><h4 id="参考链接-18"><a href="#参考链接-18" class="headerlink" title="参考链接"></a>参考链接</h4><ul><li><a href="https://leetcode-cn.com/problems/number-of-islands/" target="_blank" rel="noopener">岛屿数量</a></li><li><a href="https://shimo.im/docs/ydPCH33xDhK9YwWR" target="_blank" rel="noopener">并查集代码模板</a></li></ul><h4 id="实战题目-课后作业-3"><a href="#实战题目-课后作业-3" class="headerlink" title="实战题目 / 课后作业"></a>实战题目 / 课后作业</h4><ul><li><a href="https://leetcode-cn.com/problems/surrounded-regions/" target="_blank" rel="noopener">130. 被围绕的区域</a></li><li><a href="https://leetcode-cn.com/problems/number-of-islands/" target="_blank" rel="noopener">200. 岛屿数量</a></li><li><a href="https://leetcode-cn.com/problems/friend-circles" target="_blank" rel="noopener">547. 朋友圈</a></li></ul><h3 id="第14课丨高级搜索"><a href="#第14课丨高级搜索" class="headerlink" title="第14课丨高级搜索"></a>第14课丨高级搜索</h3><h4 id="参考链接-19"><a href="#参考链接-19" class="headerlink" title="参考链接"></a>参考链接</h4><ul><li><a href="https://shimo.im/docs/ddgwCccJQKxkrcTq" target="_blank" rel="noopener">DFS 代码模板</a></li><li><a href="https://shimo.im/docs/P8TqKHGKt3ytkYYd" target="_blank" rel="noopener">BFS 代码模板</a></li><li><a href="https://nikcheerla.github.io/deeplearningschool/2018/01/01/AlphaZero-Explained/" target="_blank" rel="noopener">AlphaZero Explained</a></li><li><a href="https://en.wikipedia.org/wiki/Game_complexity" target="_blank" rel="noopener">棋类复杂度</a></li></ul><h4 id="实战题目-7"><a href="#实战题目-7" class="headerlink" title="实战题目"></a>实战题目</h4><ul><li><a href="https://leetcode-cn.com/problems/generate-parentheses/" target="_blank" rel="noopener">22. 括号生成</a></li><li><a href="https://leetcode-cn.com/problems/valid-sudoku/" target="_blank" rel="noopener">36. 有效的数独</a></li><li><a href="https://leetcode-cn.com/problems/sudoku-solver/" target="_blank" rel="noopener">37. 解数独</a></li><li><a href="https://leetcode-cn.com/problems/n-queens" target="_blank" rel="noopener">51. N皇后</a></li><li><a href="https://leetcode-cn.com/problems/climbing-stairs/" target="_blank" rel="noopener">70. 爬楼梯</a></li></ul><h4 id="实战题目-8"><a href="#实战题目-8" class="headerlink" title="实战题目"></a>实战题目</h4><ul><li><a href="https://leetcode-cn.com/problems/word-ladder/" target="_blank" rel="noopener">127. 单词接龙</a></li><li><a href="https://leetcode-cn.com/problems/minimum-genetic-mutation/" target="_blank" rel="noopener">433. 最小基因变化</a></li></ul><h4 id="课后作业-9"><a href="#课后作业-9" class="headerlink" title="课后作业"></a>课后作业</h4><p><strong>总结双向 BFS 代码模版，请同学们提交在第 6 周学习总结中。</strong></p><h4 id="参考链接-20"><a href="#参考链接-20" class="headerlink" title="参考链接"></a>参考链接</h4><ul><li><a href="https://shimo.im/docs/CXvjHyWhpQcxXjcw" target="_blank" rel="noopener">A* 代码模板</a></li><li><a href="https://dataaspirant.com/2015/04/11/five-most-popular-similarity-measures-implementation-in-python/" target="_blank" rel="noopener">相似度测量方法</a></li><li><a href="https://leetcode.com/problems/shortest-path-in-binary-matrix/discuss/313347/A*-search-in-Python" target="_blank" rel="noopener">二进制矩阵中的最短路径的 A* 解法</a></li><li><a href="https://zxi.mytechroad.com/blog/searching/8-puzzles-bidirectional-astar-vs-bidirectional-bfs/" target="_blank" rel="noopener">8 puzzles 解法比较</a></li></ul><h4 id="实战题目-9"><a href="#实战题目-9" class="headerlink" title="实战题目"></a>实战题目</h4><ul><li><a href="https://leetcode-cn.com/problems/sudoku-solver/" target="_blank" rel="noopener">37. 解数独</a></li><li><a href="https://leetcode-cn.com/problems/sliding-puzzle/" target="_blank" rel="noopener">773. 滑动谜题</a></li><li><a href="https://leetcode-cn.com/problems/shortest-path-in-binary-matrix/" target="_blank" rel="noopener">1091. 二进制矩阵中的最短路径</a></li></ul><h3 id="第15课丨红黑树和AVL树"><a href="#第15课丨红黑树和AVL树" class="headerlink" title="第15课丨红黑树和AVL树"></a>第15课丨红黑树和AVL树</h3><h4 id="参考链接-21"><a href="#参考链接-21" class="headerlink" title="参考链接"></a>参考链接</h4><ul><li><a href="https://en.wikipedia.org/wiki/Self-balancing_binary_search_tree" target="_blank" rel="noopener">平衡树</a></li></ul><h3 id="第16课丨位运算"><a href="#第16课丨位运算" class="headerlink" title="第16课丨位运算"></a>第16课丨位运算</h3><h4 id="参考链接-22"><a href="#参考链接-22" class="headerlink" title="参考链接"></a>参考链接</h4><ul><li><a href="https://zh.wikihow.com/%E4%BB%8E%E5%8D%81%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E8%BF%9B%E5%88%B6" target="_blank" rel="noopener">如何从十进制转换为二进制</a></li></ul><h4 id="参考链接-23"><a href="#参考链接-23" class="headerlink" title="参考链接"></a>参考链接</h4><ul><li><a href="https://shimo.im/docs/rHTyt8hcpT6D9Tj8" target="_blank" rel="noopener">N 皇后位运算代码示例</a></li></ul><p>####实战题目 / 课后作业</p><ul><li><a href="https://leetcode-cn.com/problems/n-queens/" target="_blank" rel="noopener">51. N皇后</a></li><li><a href="https://leetcode-cn.com/problems/n-queens-ii/" target="_blank" rel="noopener">52. N皇后 II</a></li><li><a href="https://leetcode-cn.com/problems/reverse-bits/" target="_blank" rel="noopener">190. 颠倒二进制位</a></li><li><a href="https://leetcode-cn.com/problems/number-of-1-bits/" target="_blank" rel="noopener">191. 位1的个数</a></li><li><a href="https://leetcode-cn.com/problems/power-of-two/" target="_blank" rel="noopener">231. 2的幂</a></li><li><a href="https://leetcode-cn.com/problems/counting-bits/" target="_blank" rel="noopener">338. 比特位计数</a></li></ul><h3 id="第17课丨布隆过滤器和LRU缓存"><a href="#第17课丨布隆过滤器和LRU缓存" class="headerlink" title="第17课丨布隆过滤器和LRU缓存"></a>第17课丨布隆过滤器和LRU缓存</h3><h4 id="参考链接-24"><a href="#参考链接-24" class="headerlink" title="参考链接"></a>参考链接</h4><ul><li>布隆过滤器的原理和实现</li><li>使用布隆过滤器解决缓存击穿、垃圾邮件识别、集合判重</li><li>布隆过滤器 Python 代码示例</li><li>布隆过滤器 Python 实现示例</li><li>高性能布隆过滤器 Python 实现示例</li><li>布隆过滤器 Java 实现示例 1</li><li>布隆过滤器 Java 实现示例 2</li></ul><h4 id="参考链接-25"><a href="#参考链接-25" class="headerlink" title="参考链接"></a>参考链接</h4><ul><li>Understanding the Meltdown exploit</li><li>替换算法总揽</li><li>LRU Cache Python 代码示例</li></ul><h4 id="实战题目-课后作业-4"><a href="#实战题目-课后作业-4" class="headerlink" title="实战题目 / 课后作业"></a>实战题目 / 课后作业</h4><ul><li><a href="https://leetcode-cn.com/problems/lru-cache/#/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/lru-cache/#/</a></li></ul><h3 id="第18课丨排序算法"><a href="#第18课丨排序算法" class="headerlink" title="第18课丨排序算法"></a>第18课丨排序算法</h3><h4 id="参考链接-26"><a href="#参考链接-26" class="headerlink" title="参考链接"></a>参考链接</h4><ul><li>十大经典排序算法</li><li>快速排序代码示例</li><li>归并排序代码示例</li><li>堆排序代码示例</li><li>直播课回顾: <a href="https://pan.baidu.com/s/1sFuZ8GjDCXy5mPCNLZhHxw" target="_blank" rel="noopener">https://pan.baidu.com/s/1sFuZ8GjDCXy5mPCNLZhHxw</a> 提取码: 2rdy</li></ul><h4 id="课后作业-10"><a href="#课后作业-10" class="headerlink" title="课后作业"></a>课后作业</h4><p><strong>用自己熟悉的编程语言，手写各种初级排序代码，提交到第 7 周学习总结中。</strong></p><h4 id="参考链接-27"><a href="#参考链接-27" class="headerlink" title="参考链接"></a>参考链接</h4><ul><li>十大经典排序算法</li><li>9 种经典排序算法可视化动画</li><li>6 分钟看完 15 种排序算法动画展示</li></ul><h4 id="实战题目-课后作业-5"><a href="#实战题目-课后作业-5" class="headerlink" title="实战题目 / 课后作业"></a>实战题目 / 课后作业</h4><ul><li><a href="https://leetcode-cn.com/problems/relative-sort-array/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/relative-sort-array/</a></li><li><a href="https://leetcode-cn.com/problems/valid-anagram/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/valid-anagram/</a></li><li><a href="https://leetcode-cn.com/problems/design-a-leaderboard/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/design-a-leaderboard/</a></li><li><a href="https://leetcode-cn.com/problems/merge-intervals/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/merge-intervals/</a></li><li><a href="https://leetcode-cn.com/problems/reverse-pairs/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-pairs/</a></li></ul><h3 id="第19课丨高级动态规划"><a href="#第19课丨高级动态规划" class="headerlink" title="第19课丨高级动态规划"></a>第19课丨高级动态规划</h3><h4 id="参考链接-28"><a href="#参考链接-28" class="headerlink" title="参考链接"></a>参考链接</h4><ul><li>爬楼梯</li><li>不同路径</li><li>打家劫舍</li><li>最小路径和</li><li>股票买卖</li></ul><h4 id="课后作业-11"><a href="#课后作业-11" class="headerlink" title="课后作业"></a>课后作业</h4><p><strong>在第 8 周学习总结中，写出不同路径 2 这道题目的状态转移方程。</strong></p><h4 id="参考链接-29"><a href="#参考链接-29" class="headerlink" title="参考链接"></a>参考链接</h4><ul><li>爬楼梯</li><li>使用最小花费爬楼梯</li><li>编辑距离</li></ul><h4 id="课后作业-12"><a href="#课后作业-12" class="headerlink" title="课后作业"></a>课后作业</h4><ul><li><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-increasing-subsequence/</a></li><li><a href="https://leetcode-cn.com/problems/decode-ways/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/decode-ways/</a></li><li><a href="https://leetcode-cn.com/problems/longest-valid-parentheses/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-valid-parentheses/</a></li><li><a href="https://leetcode-cn.com/problems/maximal-rectangle/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximal-rectangle/</a></li><li><a href="https://leetcode-cn.com/problems/distinct-subsequences/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/distinct-subsequences/</a></li><li><a href="https://leetcode-cn.com/problems/race-car/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/race-car/</a></li></ul><h3 id="第20课丨字符串算法"><a href="#第20课丨字符串算法" class="headerlink" title="第20课丨字符串算法"></a>第20课丨字符串算法</h3><h4 id="参考链接-30"><a href="#参考链接-30" class="headerlink" title="参考链接"></a>参考链接</h4><ul><li>不可变字符串</li><li>Atoi 代码示例</li></ul><h4 id="字符串基础问题"><a href="#字符串基础问题" class="headerlink" title="字符串基础问题"></a>字符串基础问题</h4><ul><li><a href="https://leetcode-cn.com/problems/to-lower-case/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/to-lower-case/</a></li><li><a href="https://leetcode-cn.com/problems/length-of-last-word/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/length-of-last-word/</a></li><li><a href="https://leetcode-cn.com/problems/jewels-and-stones/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/jewels-and-stones/</a></li><li><a href="https://leetcode-cn.com/problems/first-unique-character-in-a-string/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/first-unique-character-in-a-string/</a></li><li><a href="https://leetcode-cn.com/problems/string-to-integer-atoi/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/string-to-integer-atoi/</a></li></ul><h4 id="字符串操作问题"><a href="#字符串操作问题" class="headerlink" title="字符串操作问题"></a>字符串操作问题</h4><ul><li><a href="https://leetcode-cn.com/problems/longest-common-prefix/description/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-common-prefix/description/</a></li><li><a href="https://leetcode-cn.com/problems/reverse-string" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-string</a></li><li><a href="https://leetcode-cn.com/problems/reverse-string-ii/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-string-ii/</a></li><li><a href="https://leetcode-cn.com/problems/reverse-words-in-a-string/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-words-in-a-string/</a></li><li><a href="https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/</a></li><li><a href="https://leetcode-cn.com/problems/reverse-only-letters/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-only-letters/</a></li></ul><h4 id="异位词问题"><a href="#异位词问题" class="headerlink" title="异位词问题"></a>异位词问题</h4><ul><li><a href="https://leetcode-cn.com/problems/valid-anagram/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/valid-anagram/</a></li><li><a href="https://leetcode-cn.com/problems/group-anagrams/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/group-anagrams/</a></li><li><a href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/</a></li></ul><h4 id="回文串问题"><a href="#回文串问题" class="headerlink" title="回文串问题"></a>回文串问题</h4><ul><li><a href="https://leetcode-cn.com/problems/valid-palindrome/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/valid-palindrome/</a></li><li><a href="https://leetcode-cn.com/problems/valid-palindrome-ii/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/valid-palindrome-ii/</a></li><li><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-palindromic-substring/</a></li></ul><h4 id="最长子串、子序列问题"><a href="#最长子串、子序列问题" class="headerlink" title="最长子串、子序列问题"></a>最长子串、子序列问题</h4><ul><li><a href="https://leetcode-cn.com/problems/longest-common-subsequence/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-common-subsequence/</a></li><li><a href="https://leetcode-cn.com/problems/edit-distance/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/edit-distance/</a></li><li><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-palindromic-substring/</a></li></ul><h4 id="字符串-DP-问题"><a href="#字符串-DP-问题" class="headerlink" title="字符串 +DP 问题"></a>字符串 +DP 问题</h4><ul><li><a href="https://leetcode-cn.com/problems/regular-expression-matching/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/regular-expression-matching/</a></li><li><a href="https://leetcode-cn.com/problems/regular-expression-matching/solution/ji-yu-guan-fang-ti-jie-gen-xiang-xi-de-jiang-jie-b/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/regular-expression-matching/solution/ji-yu-guan-fang-ti-jie-gen-xiang-xi-de-jiang-jie-b/</a></li><li><a href="https://leetcode-cn.com/problems/wildcard-matching/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/wildcard-matching/</a></li><li><a href="https://leetcode-cn.com/problems/distinct-subsequences/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/distinct-subsequences/</a></li></ul><h4 id="参考链接-31"><a href="#参考链接-31" class="headerlink" title="参考链接"></a>参考链接</h4><ul><li>Boyer-Moore 算法</li><li>Sunday 算法</li><li>字符串匹配暴力法代码示例</li><li>Rabin-Karp 代码示例</li><li>KMP 字符串匹配算法视频</li><li>字符串匹配的 KMP 算法</li></ul><h4 id="课后作业-13"><a href="#课后作业-13" class="headerlink" title="课后作业"></a>课后作业</h4><ul><li><a href="https://leetcode-cn.com/problems/first-unique-character-in-a-string/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/first-unique-character-in-a-string/</a></li><li><a href="https://leetcode-cn.com/problems/string-to-integer-atoi/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/string-to-integer-atoi/</a></li><li><a href="https://leetcode-cn.com/problems/reverse-string-ii/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-string-ii/</a></li><li><a href="https://leetcode-cn.com/problems/reverse-words-in-a-string/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-words-in-a-string/</a></li><li><a href="https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/</a></li><li><a href="https://leetcode-cn.com/problems/reverse-only-letters/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-only-letters/</a></li><li><a href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/</a></li><li><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-palindromic-substring/</a></li><li><a href="https://leetcode-cn.com/problems/isomorphic-strings/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/isomorphic-strings/</a></li><li><a href="https://leetcode-cn.com/problems/valid-palindrome-ii/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/valid-palindrome-ii/</a></li><li><a href="https://leetcode-cn.com/problems/wildcard-matching" target="_blank" rel="noopener">https://leetcode-cn.com/problems/wildcard-matching</a></li><li><a href="https://leetcode-cn.com/problems/longest-valid-parentheses" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-valid-parentheses</a></li><li><a href="https://leetcode-cn.com/problems/distinct-subsequences/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/distinct-subsequences/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;第01课丨数据结构与算法总览&quot;&gt;&lt;a href=&quot;#第01课丨数据结构与算法总览&quot; class=&quot;headerlink&quot; title=&quot;第01课丨数据结构与算法总览&quot;&gt;&lt;/a&gt;第01课丨数据结构与算法总览&lt;/h3&gt;&lt;h4 id=&quot;参考链接&quot;&gt;&lt;a href=&quot;#参
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://dongzl.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="https://dongzl.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="https://dongzl.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>PT-OSC 添加唯一索引导致数据丢失问题分析</title>
    <link href="https://dongzl.github.io/2020/05/27/28-PT-OSC-Add-Unique-Index/"/>
    <id>https://dongzl.github.io/2020/05/27/28-PT-OSC-Add-Unique-Index/</id>
    <published>2020-05-27T07:26:22.000Z</published>
    <updated>2020-05-29T02:24:29.927Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景描述"><a href="#背景描述" class="headerlink" title="背景描述"></a>背景描述</h2><p>最近新开发了一个业务功能，在线上创建了一张和这个业务相关的数据表，由于这是一个中间数据表，是将源头数据表进行逻辑处理后临时存储。系统上线后，先从源头表计算了一些数据存储到了新创建的中间数据表，不过在查询中间数据表数据进行后续逻辑处理时，发现查询很慢，原因也很简单，有一个查询索引漏掉了，没有创建，这些都没有什么问题，由于是操作线上数据库，执行相关操作需要走公司内部审批流，直接将以前创建索引的一条 <code>SQL</code> 语句拿来改了一下直接就提交了。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tableA <span class="keyword">add</span> <span class="keyword">unique</span> <span class="keyword">index</span> uniq_test(<span class="keyword">test</span>);</span><br></pre></td></tr></table></figure><p>这个时候重点来了，其实我本意是创建一个普通索引的，但是没有发现拷贝以前的 <code>SQL</code> 语句创建的是唯一索引，其实创建索引的字段还真是不唯一的，但是即使如此，执行流程还是正常结束了，唯一索引创建成功。</p><p>开始似乎也没发现什么问题，索引创建成功了，查询也快了，但是查询结果死活和源头数据表对不上了，想了好长时间不知道为什么，开始以为是自己代码逻辑问题，但是代码逻辑是经过测试的，数据对不上问题很明显，不可能测试没发现。</p><p>剩下的故事就是灵光一现的问题了，突然想到线上生产数据库执行 <code>DDL</code> 操作时都是使用的 <code>pt-online-schema-change（简称 pt-osc）</code> 工具，是不是这个工具搞的鬼，马上 <code>google</code> 了一下，很容易就查到了，<code>pt-osc</code> 工具在非唯一字段上创建唯一索引会导致数据丢失。又和公司的 <code>DBA</code> 求证了一下，<code>DBA</code> 坦然承认，<code>pt-osc</code> 工具确实存在这个问题。</p><p>毕竟不是专业 <code>DBA</code>，对这个工具只是有基本了解，只知道这个工具执行 <code>DDL</code> 语句时不会锁表，因此不会阻塞数据的写入。</p><h2 id="PT-OSC-工具工作原理"><a href="#PT-OSC-工具工作原理" class="headerlink" title="PT-OSC 工具工作原理"></a>PT-OSC 工具工作原理</h2><p><strong>pt-osc 工作流程</strong></p><ul><li><p>创建一个和要执行 <code>alter</code> 操作的表一样的新的空表，后缀默认是 <code>new</code>；</p></li><li><p>在新表执行 <code>alter table</code> 语句，因为是空表，执行速度很快；</p></li><li><p>在原表中创建触发器 3 个触发器分别对应 <code>insert、update、delete</code> 操作；</p></li><li><p>以一定块大小从原表拷贝数据到临时表，拷贝过程中通过原表上的触发器在原表进行的写操作都会更新到新建的临时表，注意这里是 <code>Replace</code> 操作；</p></li><li><p>表明替换 将原表名 <code>table</code> 修改为 <code>table_old</code>，将 <code>table_new</code> 表名修改为原表名 <code>table</code>；</p></li><li><p>如果有参考该表的外键，根据 <code>alter-foreign-keys-method</code> 参数的值，检测外键相关的表，做相应设置的处理；</p></li><li><p>默认最后将旧原表删除。</p></li></ul><p><strong>PS. 这个流程我并没有在官网找到详细的描述，来源于网上的二手资料，不过可以说明问题了，后续找到官网的详细描述再更新。</strong></p><img src="https://gitee.com/dongzl/article-images/raw/master/2020/28-PT-OSC-Add-Unique-Index/PT-OSC-Add-Unique-Index-01.png" width="800px"><p>从网上摘抄一个 <code>pt-osc</code> 工具实际运行过程日志输出，公司内部日志输出也是类似的，涉及具体线上业务，就不截图我们线上的内容了。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">tmp_task_user</span><br><span class="line">ADD COLUMN support tinyint(1) unsigned NOT NULL DEFAULT '1'</span><br><span class="line">No slaves found.  See <span class="comment">--recursion-method if host h=127.0.0.1,P=3306 has slaves.</span></span><br><span class="line">Not checking slave lag because no slaves were found and <span class="comment">--check-slave-lag was not specified.</span></span><br><span class="line">Operation, tries, wait:</span><br><span class="line">  analyze_table, 10, 1</span><br><span class="line">  copy_rows, 10, 0.25</span><br><span class="line">  create_triggers, 10, 1</span><br><span class="line">  drop_triggers, 10, 1</span><br><span class="line">  swap_tables, 10, 1</span><br><span class="line">  update_foreign_keys, 10, 1</span><br><span class="line">Altering `test_db`.`tmp_task_user`...</span><br><span class="line">Creating new table...</span><br><span class="line">Created new table test_db._tmp_task_user_new OK.</span><br><span class="line">Altering new table...</span><br><span class="line">Altered `test_db`.`_tmp_task_user_new` OK.</span><br><span class="line">2018-05-14T18:14:21 Creating triggers...</span><br><span class="line">2018-05-14T18:14:21 Created triggers OK.</span><br><span class="line">2018-05-14T18:14:21 Copying approximately 6 rows...</span><br><span class="line">2018-05-14T18:14:21 Copied rows OK.</span><br><span class="line">2018-05-14T18:14:21 Analyzing new table...</span><br><span class="line">2018-05-14T18:14:21 Swapping tables...</span><br><span class="line">2018-05-14T18:14:21 Swapped original and new tables OK.</span><br><span class="line">2018-05-14T18:14:21 Dropping old table...</span><br><span class="line">2018-05-14T18:14:21 Dropped old table `test_db`.`_tmp_task_user_old` OK.</span><br><span class="line">2018-05-14T18:14:21 Dropping triggers...</span><br><span class="line">2018-05-14T18:14:21 Dropped triggers OK.</span><br><span class="line">Successfully altered `test_db`.`tmp_task_user`.</span><br></pre></td></tr></table></figure><p>在 <code>Percona Toolkit</code> 的 <a href="https://jira.percona.com/projects/PT/issues" target="_blank" rel="noopener">jira</a> 问题列表中我们搜索到了相同的问题，在 2017年 就有人提出过：<a href="https://jira.percona.com/browse/PT-116" target="_blank" rel="noopener">pt-online-schema change eats data on adding a unique index</a></p><p>在这个问题里有描述异常出现的原因：</p><blockquote><p>The cause of the unexpected behavior is that pt-osc uses INSERT LOW_PRIORITY IGNORE to copy chunks, which only raises a warning instead of an error when there is a UNIQUE constraint violation (Percona and Oracle 5.6.35) so pt-osc silently ignores those rows.</p></blockquote><blockquote><p>引起这个异常行为是由于 pt-osc 工具使用 INSERT LOW_PRIORITY IGNORE 命令来拷贝块数据，这个命令在数据违反唯一约束时只会给出一个警告提示，而不是提示错误，所以 pt-osc 工具默认忽略了这些数据。</p></blockquote><p>不过看这个问题的最终状态是在 <code>3.0.3</code> 版本已经被修复，看问题评论，修复的方式是新增了 <code>use-insert-ignore</code> 参数，这个参数的作用是控制是否在 <code>INSERT</code> 数据时使用 <code>IGNORE</code> 参数。</p><img src="https://gitee.com/dongzl/article-images/raw/master/2020/28-PT-OSC-Add-Unique-Index/PT-OSC-Add-Unique-Index-02.png" width="800px"><p>我当时联系了 DBA，找他求证了一下线上生产环境使用的 <code>pt-osc</code> 工具版本，并和求证了一下线上是否开启了这个参数，<code>DBA</code> 回复说现在线上使用比较多的版本还是 <code>2.2.20</code>，当时内心是万马奔腾啊，不过他马上在自己本地环境的 <code>3.0.5</code> 版本上查了一下这个参数使用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./pt-online-schema-change --help</span><br></pre></td></tr></table></figure><p><code>DBA</code> 反馈说并没有这个参数，这个有点奇怪了，还是想自己验证一下，<code>VMware</code> 虚拟机启动了一台测试的 <code>CentOS 7</code>，安装了最新版 <code>pt-osc</code> 工具，也 <code>--help</code> 了一下，发现还真没有参数，而且官网上使用说明也没有这个参数，又是万马奔腾啊。</p><p>最后只能出大招了，撸源码。首先先在 <code>github</code> 上面搜索了一下 <code>use-insert-ignore</code> 这个参数，找到了 <code>bug</code> 修改记录中有记录这个内容，这个配置是添加在 <code>/bin/pt-online-schema-change</code> shell 脚本中，从 <code>github</code> 上 <code>clone</code> 了一份 <code>percona-toolkit</code> 代码，从最新代码的 <code>pt-online-schema-change</code> 文件中没有搜到这个 <code>use-insert-ignore</code> 参数，然后翻了一遍 <code>pt-online-schema-change</code> 脚本的修改记录，根据 <code>3.0.3</code> 大致发布的时间，终于找到了提交记录，在 <code>2017-04-21 02:31</code> 的提交记录中添加了这个参数，也找到了这个提交的 <code>PR</code> <a href="https://github.com/percona/percona-toolkit/pull/206" target="_blank" rel="noopener">PT-116 pt-online-schema change eats data on adding a unique index</a>，没问题，这个参数一定是存在过的，不过为什么现在最新的是没有这个参数的，究竟在哪里又被去掉了呢？继续翻记录，还好在不远处的提交就找到了原因，在 <code>2017-06-20 06:16</code> 的一次提交，将上一次的提交直接 <code>revert</code> 掉了，而且没有写什么原因，这次 <code>revert</code> 貌似没有 <code>github</code> 的 <code>PR</code> 记录，本来想到 <code>github</code> 上面提个 <code>issue</code> 问一下这个问题，在进到代码库地址，重点到了，居然不能提 <code>issue</code>，好了，就到这里了，这个参数也只就是昙花一现了。</p><img src="https://gitee.com/dongzl/article-images/raw/master/2020/28-PT-OSC-Add-Unique-Index/PT-OSC-Add-Unique-Index-03.png" width="800px"><h2 id="事故总结"><a href="#事故总结" class="headerlink" title="事故总结"></a>事故总结</h2><p>首先这是一个不幸的事情，线上出现了事故；但是这也是一个幸运的事情，因为出现问题只是一个中间数据表，不是核心业务源头数据表，如果是核心数据表，不好说后果了；而且及早发现了这个问题，至少比以后出现更严重事故要好的多，踩坑还是得趁早。</p><p>工作上还是有疏忽，即使再怎么认真的去对待工作，还是会有疏漏时候，对于线上生产环境的操作，即使感觉安全的，也会有一定的风险，避免风险的方式可以参考敏捷开发中的 <code>结对编程</code> 的思想，对于线上的重要操作，由自己的一名队友确认之后，再进行操作，这也是我目前工作的思路转变，双人确认之后再执行操作。</p><p>最后是工作流程上的一种反思，我们现在线上数据库操作，是有公司内部的审批流的，但是这个审批流程的节点是 <code>M</code> 岗的管理人员，管理人员对于具体的技术操作可能了解并不多，所以现在的审批流程形式大于意义；对于这个审批工作，更应该交给技术岗的研发负责人或者架构师来完成，能够熟悉正在操作修改的内容，仔细确认修改内容是否合理，是否准确，严格把握审批流程，可能在工作流程上更合理。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><p><a href="https://jira.percona.com/browse/PT-116" target="_blank" rel="noopener">pt-online-schema change eats data on adding a unique index</a></p></li><li><p><a href="https://cloud.tencent.com/developer/news/171416" target="_blank" rel="noopener">PT-Online-Schema-Change 详解</a></p></li><li><p><a href="https://www.cnblogs.com/xinysu/p/6758170.html" target="_blank" rel="noopener">pt-online-schema-change的原理解析与应用说明</a></p></li><li><p><a href="https://github.com/percona/percona-toolkit" target="_blank" rel="noopener">percona/percona-toolkit</a></p></li><li><p><a href="https://segmentfault.com/a/1190000014924677" target="_blank" rel="noopener">pt-online-schema-change使用</a></p></li><li><p><a href="https://www.percona.com/doc/percona-toolkit" target="_blank" rel="noopener">Percona Toolkit Documentation</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景描述&quot;&gt;&lt;a href=&quot;#背景描述&quot; class=&quot;headerlink&quot; title=&quot;背景描述&quot;&gt;&lt;/a&gt;背景描述&lt;/h2&gt;&lt;p&gt;最近新开发了一个业务功能，在线上创建了一张和这个业务相关的数据表，由于这是一个中间数据表，是将源头数据表进行逻辑处理后临时存
      
    
    </summary>
    
    
      <category term="数据库" scheme="https://dongzl.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MySQL" scheme="https://dongzl.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>算法中的 DFS 和 BFS</title>
    <link href="https://dongzl.github.io/2020/05/23/27-Algorithm-DFS-BFS/"/>
    <id>https://dongzl.github.io/2020/05/23/27-Algorithm-DFS-BFS/</id>
    <published>2020-05-23T03:20:31.000Z</published>
    <updated>2020-05-25T02:24:44.538Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景描述"><a href="#背景描述" class="headerlink" title="背景描述"></a>背景描述</h2><p>最近学习了 <a href="https://u.geekbang.org/subject/algorithm/1000343?utm_source=time_web&utm_medium=menu&utm_term=timewebmenu" target="_blank" rel="noopener">极客大学–算法训练营</a> 的课程，这一篇文章总结一下算法中的 <code>DFS</code> 和 <code>BFS</code> 相关知识内容。其实有关 <code>DFS</code> 和 <code>BFS</code> 的知识内容并不多，也不是非常难，类似于套公式一般直接套上去，就可以解决问题，不过在 <a href="https://leetcode-cn.com/" target="_blank" rel="noopener">Leetcode</a> 网站上刷题就会发现，的确很多都能够通过 <code>DFS</code> 或 <code>BFS</code> 来解决，但是有些题比较隐晦，需要进行思路转换才能抓住问题的关键。</p><h2 id="深度优先遍历（DFS）"><a href="#深度优先遍历（DFS）" class="headerlink" title="深度优先遍历（DFS）"></a>深度优先遍历（DFS）</h2><p><strong>深度优先搜索算法（英语：Depth-First-Search，DFS）</strong> 是一种用于遍历或搜索树或图的算法。这个算法会尽可能深的搜索树的分支。当节点v的所在边都己被探寻过，搜索将回溯到发现节点v的那条边的起始节点。这一过程一直进行到已发现从源节点可达的所有节点为止。</p><p><code>DFS</code> 是一种是一种利用栈（Stack）或者递归实现的搜索算法。</p><h3 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DepthFirstSearch</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">dfs</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        helper(root, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode node, List&lt;Integer&gt; result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        result.add(node.val);</span><br><span class="line">        helper(node.left, result);</span><br><span class="line">        helper(node.right, result);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> val;</span><br><span class="line">        <span class="keyword">public</span> TreeNode left, right;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.val= val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Stack-实现"><a href="#Stack-实现" class="headerlink" title="Stack 实现"></a>Stack 实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DepthFirstSearch</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">dfs</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack.add(root);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 弹出栈顶元素</span></span><br><span class="line">            TreeNode currentNode = stack.pop();</span><br><span class="line">            result.add(currentNode.val);</span><br><span class="line">            <span class="keyword">if</span> (currentNode.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 深度优先遍历，先遍历左边，后遍历右边，栈先进后出</span></span><br><span class="line">                stack.push(currentNode.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (currentNode.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(currentNode.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> val;</span><br><span class="line">        <span class="keyword">public</span> TreeNode left, right;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.val= val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="广度优先遍历（BFS）"><a href="#广度优先遍历（BFS）" class="headerlink" title="广度优先遍历（BFS）"></a>广度优先遍历（BFS）</h2><p><strong>广度优先搜索算法（英语：Breadth-First Search，缩写为BFS）</strong>，又译作宽度优先搜索，或横向优先搜索，是一种图形搜索算法。简单的说，BFS是从根节点开始，沿着树的宽度遍历树的节点。如果所有节点均被访问，则算法中止。</p><p><code>BFS</code> 是一种是一种利用队列（Queue）实现的搜索算法，其实现思想为：</p><ul><li>队列不为空则循环；</li><li>将未访问的邻接点压入队列后面，然后从前面取出并访问（这样就做到了广度优先）。</li></ul><h3 id="Queue-实现"><a href="#Queue-实现" class="headerlink" title="Queue 实现"></a>Queue 实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BreadthFirstSearch</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">bfs</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 利用队列实现优先搜索算法</span></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            TreeNode currentNode = queue.poll();</span><br><span class="line">            result.add(currentNode.val);</span><br><span class="line">            <span class="keyword">if</span> (currentNode.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.add(currentNode.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (currentNode.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.add(currentNode.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> val;</span><br><span class="line">        <span class="keyword">public</span> TreeNode left, right;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.val= val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="括号生成问题"><a href="#括号生成问题" class="headerlink" title="括号生成问题"></a>括号生成问题</h2><h3 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22. 括号生成"></a><a href="https://leetcode-cn.com/problems/generate-parentheses/" target="_blank" rel="noopener">22. 括号生成</a></h3><p>Difficulty: <strong>中等</strong></p><p>数字 <em>n</em> 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 <strong>有效的</strong> 括号组合。</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：[</span><br><span class="line">       &quot;((()))&quot;,</span><br><span class="line">       &quot;(()())&quot;,</span><br><span class="line">       &quot;(())()&quot;,</span><br><span class="line">       &quot;()(())&quot;,</span><br><span class="line">       &quot;()()()&quot;</span><br><span class="line">     ]</span><br></pre></td></tr></table></figure><p>这个题目乍一看和 <code>BFS、DFS</code> 完全是不沾边的，但是通过将具体题目过程进行抽象转换，也是可以用 <code>BFS、DFS</code> 实现的；具体思路是将要生成结果看做是 <code>root</code>，将左右括号使用的数量作为左右节点向外扩展，扩展到最后，左右括号数量都是 <code>0</code>，那么就得到了一个最终的结果。在扩展的过程中，如果一层层处理，那就是 <code>BFS</code> 了；如果是在一侧一直处理，处理完一侧再回溯继续处理，就是 <code>DFS</code> 了。</p><h3 id="括号生成问题-DFS-代码（递归实现）"><a href="#括号生成问题-DFS-代码（递归实现）" class="headerlink" title="括号生成问题 DFS 代码（递归实现）"></a>括号生成问题 DFS 代码（递归实现）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        generateOneByOne(<span class="string">""</span>, result, n, n);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">generateOneByOne</span><span class="params">(String s, List&lt;String&gt; result, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="number">0</span> &amp;&amp; right == <span class="number">0</span>) &#123;</span><br><span class="line">            result.add(s);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            generateOneByOne(s + <span class="string">"("</span>, result, left - <span class="number">1</span>, right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (right &gt; left) &#123;</span><br><span class="line">            generateOneByOne(s + <span class="string">")"</span>, result, left, right - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="括号生成问题-DFS-代码（Stack-实现）"><a href="#括号生成问题-DFS-代码（Stack-实现）" class="headerlink" title="括号生成问题 DFS 代码（Stack 实现）"></a>括号生成问题 DFS 代码（Stack 实现）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String res;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> left;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> right;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span> <span class="params">(String res, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.res = res;</span><br><span class="line">            <span class="keyword">this</span>.left = left;</span><br><span class="line">            <span class="keyword">this</span>.right = right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack.add(<span class="keyword">new</span> Node(<span class="string">""</span>, n, n));</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            Node currentNode = stack.pop();</span><br><span class="line">            <span class="keyword">if</span> (currentNode.left == <span class="number">0</span> &amp;&amp; currentNode.right == <span class="number">0</span>) &#123;</span><br><span class="line">                result.add(currentNode.res);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (currentNode.right &gt; currentNode.left) &#123;</span><br><span class="line">                stack.push(<span class="keyword">new</span> Node(currentNode.res + <span class="string">")"</span>, currentNode.left, currentNode.right - <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (currentNode.left &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                stack.push(<span class="keyword">new</span> Node(currentNode.res + <span class="string">"("</span>, currentNode.left - <span class="number">1</span>, currentNode.right));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="括号生成问题-BFS-代码（Queue-实现）"><a href="#括号生成问题-BFS-代码（Queue-实现）" class="headerlink" title="括号生成问题 BFS 代码（Queue 实现）"></a>括号生成问题 BFS 代码（Queue 实现）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String res;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> left;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> right;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span> <span class="params">(String res, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.res = res;</span><br><span class="line">            <span class="keyword">this</span>.left = left;</span><br><span class="line">            <span class="keyword">this</span>.right = right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(<span class="keyword">new</span> Node(<span class="string">""</span>, n, n));</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            Node currentNode = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (currentNode.left == <span class="number">0</span> &amp;&amp; currentNode.right == <span class="number">0</span>) &#123;</span><br><span class="line">                result.add(currentNode.res);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (currentNode.left &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                queue.add(<span class="keyword">new</span> Node(currentNode.res + <span class="string">"("</span>, currentNode.left - <span class="number">1</span>, currentNode.right));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (currentNode.right &gt; currentNode.left) &#123;</span><br><span class="line">                queue.add(<span class="keyword">new</span> Node(currentNode.res + <span class="string">")"</span>, currentNode.left, currentNode.right - <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其他题目（持续补充）"><a href="#其他题目（持续补充）" class="headerlink" title="其他题目（持续补充）"></a>其他题目（持续补充）</h2><p><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">102. 二叉树的层序遍历</a></p><p>该题目本来是一道典型的 <code>BFS</code> 题目，但是在输出结果上有特殊的要求，所以要在循环队列时记录当前的层次，这样才能满足结果输出。</p><div class="row">    <embed src="https://gitee.com/dongzl/article-images/raw/master/2020/27-Algorithm-DFS-BFS/27-Algorithm-DFS-BFS-01.pdf" width="100%" height="550" type="application/pdf"></div><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><p><a href="https://zh.wikipedia.org/wiki/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2" target="_blank" rel="noopener">广度优先搜索（需要梯子）</a></p></li><li><p><a href="https://zh.wikipedia.org/wiki/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2" target="_blank" rel="noopener">深度优先搜索（需要梯子）</a></p></li><li><p><a href="https://www.cnblogs.com/wkfvawl/p/9347828.html" target="_blank" rel="noopener">深搜（DFS）与广搜（BFS）区别</a></p></li><li><p><a href="https://juejin.im/post/5d7127eb51882519a93ac19f" target="_blank" rel="noopener">一文搞懂深度优先搜索、广度优先搜索(dfs,bfs)</a></p></li><li><p><a href="https://blog.csdn.net/weixin_42289193/article/details/81741756" target="_blank" rel="noopener">Java实现深度优先遍历和广度优先遍历</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景描述&quot;&gt;&lt;a href=&quot;#背景描述&quot; class=&quot;headerlink&quot; title=&quot;背景描述&quot;&gt;&lt;/a&gt;背景描述&lt;/h2&gt;&lt;p&gt;最近学习了 &lt;a href=&quot;https://u.geekbang.org/subject/algorithm/100034
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://dongzl.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="https://dongzl.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="https://dongzl.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Java 线程池中 Future &amp; FutureTask 使用总结</title>
    <link href="https://dongzl.github.io/2020/05/20/26-JDK-ThreadPool-Future-FutureTask/"/>
    <id>https://dongzl.github.io/2020/05/20/26-JDK-ThreadPool-Future-FutureTask/</id>
    <published>2020-05-20T12:28:00.000Z</published>
    <updated>2020-05-22T03:37:26.848Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景描述"><a href="#背景描述" class="headerlink" title="背景描述"></a>背景描述</h2><p>在工作中，对于 <code>Future</code> 和 <code>FutureTask</code> 类使用频率并不高，正好有个业务场景使用到了 <code>Future</code> 类，有些 API 使用并不熟练，这篇文章正好总结记录一下，方便以后学习和使用。</p><h2 id="Java-中创建线程几种方式对比"><a href="#Java-中创建线程几种方式对比" class="headerlink" title="Java 中创建线程几种方式对比"></a>Java 中创建线程几种方式对比</h2><p><code>Future</code> 和 <code>FutureTask</code> 都是 <code>Java</code> 中提供的多线程相关的几个工具类，提到了多线程，首先就要总结一下 <code>Java</code> 中创建线程的几种方式：</p><ul><li>继承 <code>Thread</code> 类；</li><li>实现 <code>Runnable</code> 接口；</li><li>实现 <code>Callable</code> 接口；</li></ul><p>通过继承 <code>Thread</code> 类来实现多线程这种方式就不多说了，由于 <code>Java</code> 中是单继承规则，继承 <code>Thread</code> 类就无法继承其他类，所以并不是一种特别推荐的方式；通过实现接口倒是提供了两种方式：<code>Runnable</code> 和 <code>Callable</code>，下面就来对比一下这两种实现方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * When an object implementing interface &lt;code&gt;Runnable&lt;/code&gt; is used</span></span><br><span class="line"><span class="comment">     * to create a thread, starting the thread causes the object's</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;run&lt;/code&gt; method to be called in that separately executing</span></span><br><span class="line"><span class="comment">     * thread.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * The general contract of the method &lt;code&gt;run&lt;/code&gt; is that it may</span></span><br><span class="line"><span class="comment">     * take any action whatsoever.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span>     java.lang.Thread#run()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Computes a result, or throws an exception if unable to do so.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> computed result</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception if unable to compute a result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>多线程</th><th>Runnable</th><th>Callable</th></tr></thead><tbody><tr><td>返回值</td><td>无返回值</td><td>有返回值（泛型）</td></tr><tr><td>异常</td><td>用户捕获异常</td><td>可以抛出异常</td></tr><tr><td>执行</td><td>ExecutorService#submit()</td><td>ExecutorService#submit() or ExecutorService#execute()</td></tr><tr><td>与 Thread 类关系</td><td>new Thread(Runnable target).start() 启动（Thread 类就实现了 Runnable 接口）</td><td>与 Thread 没关系，只能与 ExecutorService 配合使用</td></tr></tbody></table><h2 id="Future-接口定义"><a href="#Future-接口定义" class="headerlink" title="Future 接口定义"></a>Future 接口定义</h2><p>在 <code>JDK1.5</code> 之前，<code>Java</code> 中还没有提供 <code>Future</code> 和 <code>Callable</code> 相关接口，创建线程只能通过 <code>Thread</code> 类或者是 <code>Runnable</code> 接口，这两种方式最大的缺点就是在线程异步执行完毕后无法获取线程的执行结果，如果一定要获取执行结果，只能通过共享变量或者其它线程通信的方式来达到效果，这就是这两种方式备受诟病的地方。<code>JDK1.5</code> 之后，<code>Doug Lea</code> 大师给我们提供了 <code>Future</code> 和 <code>Callable</code> 几个相关的工具类，方便我们来获取线程的异步执行结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试取消任务执行。如果这个任务已经执行完成，或者已经被取消，或者一些其他原因导致任务无法被取消，该方法操作失败；</span></span><br><span class="line">    <span class="comment">// 如果取消成功，并且这个任务还没有被开始执行，这个任务将永远不会再被执行；</span></span><br><span class="line">    <span class="comment">// 如果任务已经开始执行，将由 mayInterruptIfRunning 参数决定是否尝试中断执行该任务的线程来尝试停止任务；</span></span><br><span class="line">    <span class="comment">// 这个方法执行返回结果后，如果随后调用 isDone 方法将永远返回 true；如果这个方法返回true，那么随后调用 isCancelled 方法将永远返回 true；</span></span><br><span class="line">    <span class="comment">// mayInterruptIfRunning 为 true，中断执行任务线程，false 执行中的任务将会一直执行完毕。</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断任务是否被取消</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断任务是否执行完毕</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 用来获取执行结果，这个方法会产生阻塞，会一直等到任务执行完毕才返回</span></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用来获取执行结果，如果在指定时间内，还没获取到结果，直接抛出 TimeoutException</span></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结一下，<code>Java</code> 中提供的 <code>Future</code> 接口主要三个作用：</p><ul><li>取消任务执行；</li><li>判断任务是否执行完毕；</li><li>获取任务执行结果。</li></ul><h2 id="ExecutorService-接口定义"><a href="#ExecutorService-接口定义" class="headerlink" title="ExecutorService 接口定义"></a>ExecutorService 接口定义</h2><p><code>Future</code> 只是一个接口定义，需要和 <code>ExecutorService</code> 接口配合使用才能达到效果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行一个 Runnable 类型任务，无返回结果。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExecutorService</span> <span class="keyword">extends</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ... ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行一个 Callable 类型任务，并通过 Future#get() 获取执行结果。</span></span><br><span class="line">    &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行一个 Runnable 类型任务，并通过 Future#get() 获取执行结果，使用比较少；</span></span><br><span class="line">    <span class="comment">// Runnable 类型的任务是不能返回执行结果，但是可以通过指定参数，返回执行结果。</span></span><br><span class="line">    <span class="comment">// 具体的实现逻辑在 RunnableAdapter 中，我理解应该是类似于通过共享变量来获取返回结果的意思。</span></span><br><span class="line">    &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 执行一个 Runnable 类型任务，并通过 Future 返回执行结果，但是返回的结果 Future#get() 为 null。</span></span><br><span class="line">    Future&lt;?&gt; submit(Runnable task);</span><br><span class="line"></span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="FutureTask-类的定义"><a href="#FutureTask-类的定义" class="headerlink" title="FutureTask 类的定义"></a>FutureTask 类的定义</h2><p>由于 <code>Future</code> 只是一个接口定义，是无法直接用来创建对象使用的，所以就有了 <code>FutureTask</code> 类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util.concurrent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Runnable</span>, <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets this Future to the result of its computation</span></span><br><span class="line"><span class="comment">     * unless it has been cancelled.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (callable == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">this</span>.callable = callable;</span><br><span class="line">        <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Runnable runnable, V result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.callable = Executors.callable(runnable, result);</span><br><span class="line">        <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过类的定义我们可以得知，<code>FutureTask</code> 类实现了 <code>RunnableFuture&lt;V&gt;</code> 接口，<code>RunnableFuture&lt;V&gt;</code> 接口继承自 <code>Runnable</code> 和 <code>Future&lt;V&gt;</code> 接口，所以 <code>FutureTask</code> 类是同时实现了 <code>Runnable</code> 和 <code>Future&lt;V&gt;</code> 接口。</p><p>在构造方法上，<code>FutureTask</code> 类对 <code>Callable</code> 和 <code>Runnable</code> 进行了一层封装。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ExecutorService executor = ...</span><br><span class="line">    ArchiveSearcher searcher = ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showSearch</span><span class="params">(<span class="keyword">final</span> String target)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        </span><br><span class="line">        Future&lt;String&gt; future = executor.submit(<span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> searcher.search(target);</span><br><span class="line">            &#125;&#125;);</span><br><span class="line">        displayOtherThings(); <span class="comment">// do other things while searching</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            displayText(future.get()); <span class="comment">// use future </span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException ex) &#123; </span><br><span class="line">            cleanup(); </span><br><span class="line">            <span class="keyword">return</span>; </span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        FutureTask&lt;String&gt; future = <span class="keyword">new</span> FutureTask&lt;String&gt;(<span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> searcher.search(target);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        executor.execute(future);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="FutureTask-类对-Future-接口的逻辑实现"><a href="#FutureTask-类对-Future-接口的逻辑实现" class="headerlink" title="FutureTask 类对 Future 接口的逻辑实现"></a>FutureTask 类对 Future 接口的逻辑实现</h2><p><code>FutureTask</code> 类实现了 <code>Future</code> 接口，那么相应的也就实现了 <code>Future</code> 接口中的所有方法，下面我们就简单分析一下 <code>FutureTask</code> 类对这些方法的实现逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The run state of this task, initially NEW.  The run state</span></span><br><span class="line"><span class="comment"> * transitions to a terminal state only in methods set,</span></span><br><span class="line"><span class="comment"> * setException, and cancel.  During completion, state may take on</span></span><br><span class="line"><span class="comment"> * transient values of COMPLETING (while outcome is being set) or</span></span><br><span class="line"><span class="comment"> * INTERRUPTING (only while interrupting the runner to satisfy a</span></span><br><span class="line"><span class="comment"> * cancel(true)). Transitions from these intermediate to final</span></span><br><span class="line"><span class="comment"> * states use cheaper ordered/lazy writes because values are unique</span></span><br><span class="line"><span class="comment"> * and cannot be further modified.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Possible state transitions:</span></span><br><span class="line"><span class="comment"> * NEW -&gt; COMPLETING -&gt; NORMAL</span></span><br><span class="line"><span class="comment"> * NEW -&gt; COMPLETING -&gt; EXCEPTIONAL</span></span><br><span class="line"><span class="comment"> * NEW -&gt; CANCELLED</span></span><br><span class="line"><span class="comment"> * NEW -&gt; INTERRUPTING -&gt; INTERRUPTED</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NEW          = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COMPLETING   = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NORMAL       = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCEPTIONAL  = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED    = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTING = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTED  = <span class="number">6</span>;</span><br></pre></td></tr></table></figure><p><code>FutureTask</code> 类中重要的就是 <code>state</code> 变量，并且对该变量定义了七种常量类型，一个 <code>FutureTask</code> 任务的执行过程就是在这些状态中流转的过程。最初是在 <code>FutureTask</code> 的构造方法中，会初始化 <code>state</code> 为 <code>NEW</code> 类型，所有流转都以该状态为起始。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CANCELLED、INTERRUPTING、INTERRUPTED 状态都表示任务已被取消</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> state &gt;= CANCELLED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 状态不等于 NEW 都表示任务已完成</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> state != NEW;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1、判断状态是否是 NEW，同时 cas 修改 state 状态值；</span></span><br><span class="line"><span class="comment">// 2、根据 mayInterruptIfRunning 参数决定是中断线程，还是等待线程执行完成。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(state == NEW &amp;&amp;</span><br><span class="line">          UNSAFE.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, NEW,</span><br><span class="line">              mayInterruptIfRunning ? INTERRUPTING : CANCELLED)))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;    <span class="comment">// in case call to interrupt throws exception</span></span><br><span class="line">        <span class="keyword">if</span> (mayInterruptIfRunning) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread t = runner;</span><br><span class="line">                <span class="keyword">if</span> (t != <span class="keyword">null</span>)</span><br><span class="line">                    t.interrupt();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123; <span class="comment">// final state</span></span><br><span class="line">                UNSAFE.putOrderedInt(<span class="keyword">this</span>, stateOffset, INTERRUPTED);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        finishCompletion();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景描述&quot;&gt;&lt;a href=&quot;#背景描述&quot; class=&quot;headerlink&quot; title=&quot;背景描述&quot;&gt;&lt;/a&gt;背景描述&lt;/h2&gt;&lt;p&gt;在工作中，对于 &lt;code&gt;Future&lt;/code&gt; 和 &lt;code&gt;FutureTask&lt;/code&gt; 类使用频率并不高
      
    
    </summary>
    
    
      <category term="java开发" scheme="https://dongzl.github.io/categories/java%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Thread" scheme="https://dongzl.github.io/tags/Thread/"/>
    
  </entry>
  
  <entry>
    <title>对比源码分析 ConcurrentHashMap 是如何成为一个线程安全的 HashMap</title>
    <link href="https://dongzl.github.io/2020/05/13/25-JDK8-ConcurrentHashMap/"/>
    <id>https://dongzl.github.io/2020/05/13/25-JDK8-ConcurrentHashMap/</id>
    <published>2020-05-13T05:39:36.000Z</published>
    <updated>2020-05-15T05:48:46.380Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景描述"><a href="#背景描述" class="headerlink" title="背景描述"></a>背景描述</h2><p><code>HashMap</code> 是我们在工作中使用非常广泛的容器类，前面已经有一篇文章，结合自己工作中的一个使用场景（<a href="https://dongzl.github.io/2019/09/29/02-JDK8-HashMap-Code/">一个工作的真实场景聊聊 HashMap 的实现</a>），简单分析过 <code>HashMap</code> 的实现原理；但是我们也知道，<code>HashMap</code> 并不是线程安全的，如果要在多线程场景中保证线程安全，一般推荐使用 <code>ConcurrentHashMap</code>，当然这也不是唯一选择，还有 <code>HashTable</code>、<code>Collections.synchronizedMap()</code> 等方式，不过这些肯定都是不推荐的了。<code>ConcurrentHashMap</code> 和 <code>HashMap</code> 的在代码层面的实现非常类似，基本上可以说 <code>ConcurrentHashMap</code> 就是在可能会引发线程安全问题的关键点上做了处理，这篇文章我们就通过分析一下这些关键点，来理解 <code>ConcurrentHashMap</code> 是如何保证线程安全的。</p><blockquote><p>关于 HashMap 可能引发的线程安全问题，可以参考这篇文章 <a href="https://juejin.im/post/5c8910286fb9a049ad77e9a3" target="_blank" rel="noopener">深入解读HashMap线程安全性问题</a></p></blockquote><h2 id="ConcurrentHashMap-构造方法实现"><a href="#ConcurrentHashMap-构造方法实现" class="headerlink" title="ConcurrentHashMap 构造方法实现"></a>ConcurrentHashMap 构造方法实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a new, empty map with the default initial table size (16).</span></span><br><span class="line"><span class="comment"> * 创建空的 map，默认初始容量 16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a new, empty map with an initial table size</span></span><br><span class="line"><span class="comment"> * accommodating the specified number of elements without the need</span></span><br><span class="line"><span class="comment"> * to dynamically resize.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> initialCapacity The implementation performs internal</span></span><br><span class="line"><span class="comment"> * sizing to accommodate this many elements.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity of</span></span><br><span class="line"><span class="comment"> * elements is negative</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">int</span> cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ?</span><br><span class="line">            MAXIMUM_CAPACITY :</span><br><span class="line">            tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">this</span>.sizeCtl = cap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ConcurrentHashMap</code> 类的构造方法还是有些特殊的：</p><ul><li>在构造方法内部并没有进行 <code>table</code> 的初始化操作，初始化的过程放到了 <code>put</code> 方法中来完成，后面我们还会讲到；</li><li>在带有 <code>initialCapacity</code> 参数的构造方法中提供初始容量值，计算了  <code>sizeCtl</code> 大小，<code>sizeCtl = [( 1.5 * initialCapacity + 1)</code>，然后向上取最近的 2 的 n 次方]。如 <code>initialCapacity</code> 为 10，那么得到 <code>sizeCtl</code> 为 16，如果 <code>initialCapacity</code> 为 11，得到 <code>sizeCtl</code> 为 32。<code>sizeCtl</code> 这个属性有很多使用场景，后面我们来分析。</li></ul><h2 id="ConcurrentHashMap-类-spread-方法理解"><a href="#ConcurrentHashMap-类-spread-方法理解" class="headerlink" title="ConcurrentHashMap 类 spread 方法理解"></a>ConcurrentHashMap 类 spread 方法理解</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Spreads (XORs) higher bits of hash to lower and also forces top</span></span><br><span class="line"><span class="comment"> * bit to 0. Because the table uses power-of-two masking, sets of</span></span><br><span class="line"><span class="comment"> * hashes that vary only in bits above the current mask will</span></span><br><span class="line"><span class="comment"> * always collide. (Among known examples are sets of Float keys</span></span><br><span class="line"><span class="comment"> * holding consecutive whole numbers in small tables.)  So we</span></span><br><span class="line"><span class="comment"> * apply a transform that spreads the impact of higher bits</span></span><br><span class="line"><span class="comment"> * downward. There is a tradeoff between speed, utility, and</span></span><br><span class="line"><span class="comment"> * quality of bit-spreading. Because many common sets of hashes</span></span><br><span class="line"><span class="comment"> * are already reasonably distributed (so don't benefit from</span></span><br><span class="line"><span class="comment"> * spreading), and because we use trees to handle large sets of</span></span><br><span class="line"><span class="comment"> * collisions in bins, we just XOR some shifted bits in the</span></span><br><span class="line"><span class="comment"> * cheapest possible way to reduce systematic lossage, as well as</span></span><br><span class="line"><span class="comment"> * to incorporate impact of the highest bits that would otherwise</span></span><br><span class="line"><span class="comment"> * never be used in index calculations because of table bounds.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (h ^ (h &gt;&gt;&gt; <span class="number">16</span>)) &amp; HASH_BITS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ConcurrentHashMap</code> 中 <code>spread</code> 方法的作用类似于 HashMap 中 hash(Object key) 方法，但是在实现上也是略有差别。</p><p><code>ConcurrentHashMap</code> 类中的 <code>spread(int h)</code> 方法类似于 <code>HashMap</code> 中的 <code>hash(Object key)</code> 方法，两个方法的作用应该说是相同的，都是通过将 <code>Map</code> 中的 <code>key</code> 的 <code>hashCode</code> 值进行无符号右移 16 位的方式，让 <code>hashCode</code> 的高低 16 位都参与到运算中，尽量降低 <code>hash</code> 碰撞的概率，但是两者的实现又略有不同。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = key.hashCode();</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : h ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>HashMap</code> 中只是做了无符号右移操作，然后和原值进行异或操作；而在<code>ConcurrentHashMap</code> 中无符号右移，和原值异或之后，还和 <code>HASH_BITS</code> 常量进行了 &amp; 操作，<code>HASH_BITS</code> 常量在类中的定义为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_BITS = <span class="number">0x7fffffff</span>; <span class="comment">// usable bits of normal node hash</span></span><br></pre></td></tr></table></figure><p>这个值其实是 Integer.MAX_VALUE，如果转换成二进制是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span></span><br></pre></td></tr></table></figure><p>对于任意一个二进制的数据，和上面的数据做 &amp; 操作，其实结果都是：</p><ul><li>如果这个数 &gt; 0，那么 <code>&amp; HASH_BITS</code> 结果是不变的，还是原值；</li><li>如果这个数 &lt; 0，那么 <code>&amp; HASH_BITS</code> 后低 31 位不变，最高位符号位 <code>1 &amp; 0</code> 后结果为 <code>0</code>，最终结果 &gt; 0。</li></ul><p>这个操作的含义应该就是注释中描述的作用 <code>forces top bit to 0</code>：</p><blockquote><p>Spreads (XORs) higher bits of hash to lower and also forces top bit to 0.</p></blockquote><p><font color="red">对于这里的操作不是太理解作用是什么，为了防止 hashCode 出现负数的情况吗，即使是负数，最终计算 table 数组中位置的时候是会进行 h &amp; (n-1) 计算，也该不会有什么问题；而且在 HashMap 的源码的确是没有这个操作的，没理解透彻，这个问题暂时遗留吧，看看是不是有朋友能回答这个问题。</font></p><h2 id="ConcurrentHashMap-中的-put-操作"><a href="#ConcurrentHashMap-中的-put-操作" class="headerlink" title="ConcurrentHashMap 中的 put 操作"></a>ConcurrentHashMap 中的 put 操作</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Maps the specified key to the specified value in this table.</span></span><br><span class="line"><span class="comment"> * Neither the key nor the value can be null.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;The value can be retrieved by calling the &#123;<span class="doctag">@code</span> get&#125; method</span></span><br><span class="line"><span class="comment"> * with a key that is equal to the original key.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key key with which the specified value is to be associated</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value value to be associated with the specified key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the previous value associated with &#123;<span class="doctag">@code</span> key&#125;, or</span></span><br><span class="line"><span class="comment"> *         &#123;<span class="doctag">@code</span> null&#125; if there was no mapping for &#123;<span class="doctag">@code</span> key&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified key or value is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(key, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Implementation for put and putIfAbsent */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算hash值</span></span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table; ;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">int</span> fh;</span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 初始化tab</span></span><br><span class="line">            tab = initTable();</span><br><span class="line">            <span class="comment">// 找到tab中的第一个元素</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果第一个元素为空，执行cas操作，添加元素</span></span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>, <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>))) &#123;</span><br><span class="line">                <span class="comment">// 当向一个空bin添加元素时使用无锁的CAS</span></span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED) &#123;</span><br><span class="line">            <span class="comment">// 处理map正在扩容中的场景</span></span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 加锁执行添加元素操作</span></span><br><span class="line">            <span class="comment">// 锁f是通过tabAt方法获取的</span></span><br><span class="line">            <span class="comment">// 也就是说，当发生hash碰撞时，会以链表的头结点作为锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="comment">// 这个检查的原因在于：</span></span><br><span class="line">                <span class="comment">// tab引用的是成员变量table，table在发生了rehash之后，原来index上的Node可能会变</span></span><br><span class="line">                <span class="comment">// 这里就是为了确保在put的过程中，没有收到rehash的影响，指定index上的Node仍然是f</span></span><br><span class="line">                <span class="comment">// 如果不是f，那这个锁就没有意义了</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="comment">// 确保put没有发生在扩容的过程中，fh=-1时表示正在扩容</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f; ; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent) &#123;</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 如果是红黑树，执行红黑树插入操作</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent) &#123;</span><br><span class="line">                                p.val = value;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果超过设定阈值，转换成红黑树</span></span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD) &#123;</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://gitee.com/dongzl/article-images/raw/master/2020/25-JDK8-ConcurrentHashMap/JDK8-ConcurrentHashMap-01.png"><p>通过对代码分析，我们可以了解到，在执行 <code>put</code> 操作时会进行如下操作：</p><ul><li>如果 <code>table</code> 为空，执行初始化操作，这一点是 <code>ConcurrentHashMap</code> 和 <code>HashMap</code> 比较大的区别，<code>ConcurrentHashMap</code> 在构造方法中不会对 <code>table</code> 进行初始化，而 <code>HashMap</code> 会在构造方法中对 <code>table</code> 进行初始化；</li><li>如果 <code>table</code> 某个位置元素为空，也就是这个位置还没有元素，<code>put</code> 的内容是这个位置的第一个元素，<code>ConcurrentHashMap</code> 会通过 <code>CAS</code> 操作，将该元素放入该位置；</li><li>在 <code>put</code> 过程中，有可能 <code>ConcurrentHashMap</code> 正在执行扩容操作，需要等到扩容操作，继续进行 <code>put</code> 操作；</li><li>如果 <code>table</code> 某个位置元素不为空，需要使用 <code>synchronized</code>对该位置第一个元素 <code>f</code> 加锁，完成 <code>put</code> 操作；</li><li>至于后面执行的操作，根据判断是链表 or 红黑树来执行不同操作，与 <code>HashMap</code> 中的操作基本是相同的。</li></ul><h2 id="ConcurrentHashMap-中的-get-操作"><a href="#ConcurrentHashMap-中的-get-操作" class="headerlink" title="ConcurrentHashMap 中的 get 操作"></a>ConcurrentHashMap 中的 get 操作</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the value to which the specified key is mapped,</span></span><br><span class="line"><span class="comment"> * or &#123;<span class="doctag">@code</span> null&#125; if this map contains no mapping for the key.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;More formally, if this map contains a mapping from a key</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> k&#125; to a value &#123;<span class="doctag">@code</span> v&#125; such that &#123;<span class="doctag">@code</span> key.equals(k)&#125;,</span></span><br><span class="line"><span class="comment"> * then this method returns &#123;<span class="doctag">@code</span> v&#125;; otherwise it returns</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> null&#125;.  (There can be at most one such mapping.)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified key is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K, V&gt;[] tab; Node&lt;K, V&gt; e; Node&lt;K, V&gt; p;</span><br><span class="line">    <span class="keyword">int</span> n; <span class="keyword">int</span> eh; K ek;</span><br><span class="line">    <span class="keyword">int</span> h = spread(key.hashCode());</span><br><span class="line">    tab = table; n = tab.length; e = tabAt(tab, (n - <span class="number">1</span>) &amp; h);</span><br><span class="line">    <span class="keyword">if</span> (tab != <span class="keyword">null</span> &amp;&amp; n &gt; <span class="number">0</span> &amp;&amp; e != <span class="keyword">null</span>) &#123;</span><br><span class="line">        eh = e.hash;</span><br><span class="line">        <span class="keyword">if</span> (eh == h) &#123;</span><br><span class="line">            ek = e.key;</span><br><span class="line">            <span class="keyword">if</span> (ek == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek))) &#123;</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            p = e.find(h, key);</span><br><span class="line">            <span class="keyword">return</span> p != <span class="keyword">null</span> ? p.val : <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        e = e.next;</span><br><span class="line">        <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ek = e.key;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == h &amp;&amp; (ek == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">            &#125;</span><br><span class="line">            e = e.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的源码，我们可以看到，在 <code>ConcurrentHashMap</code> 类的 <code>get</code> 方法并没有任何加锁操作，那是如何来保证线程安全的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Key-value entry.  This class is never exported out as a</span></span><br><span class="line"><span class="comment"> * user-mutable Map.Entry (i.e., one supporting setValue; see</span></span><br><span class="line"><span class="comment"> * MapEntry below), but can be used for read-only traversals used</span></span><br><span class="line"><span class="comment"> * in bulk tasks.  Subclasses of Node with a negative hash field</span></span><br><span class="line"><span class="comment"> * are special, and contain null keys and values (but are never</span></span><br><span class="line"><span class="comment"> * exported).  Otherwise, keys and vals are never null.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="keyword">volatile</span> V val;</span><br><span class="line">    <span class="keyword">volatile</span> Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(<span class="keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.hash = hash;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>       </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>     </span>&#123; <span class="keyword">return</span> val; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span>   </span>&#123; <span class="keyword">return</span> key.hashCode() ^ val.hashCode(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> key + <span class="string">"="</span> + val; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>get</code> 操作可以无锁是由于 <code>Node</code> 的元素 <code>val</code> 和指针 <code>next</code> 是用 <code>volatile</code> 修饰的，在多线程环境下一个线程修改结点的 <code>val</code> 或者新增节点的时候保证对另外一个线程可见的。</p><h2 id="ConcurrentHashMap-中的扩容操作"><a href="#ConcurrentHashMap-中的扩容操作" class="headerlink" title="ConcurrentHashMap 中的扩容操作"></a>ConcurrentHashMap 中的扩容操作</h2><p><a href="https://juejin.im/post/5ca89afa5188257e1d4576ff#heading-10" target="_blank" rel="noopener">解读Java8中ConcurrentHashMap是如何保证线程安全的–5 线程安全的扩容</a></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://juejin.im/post/5ca89afa5188257e1d4576ff" target="_blank" rel="noopener">解读Java8中ConcurrentHashMap是如何保证线程安全的</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景描述&quot;&gt;&lt;a href=&quot;#背景描述&quot; class=&quot;headerlink&quot; title=&quot;背景描述&quot;&gt;&lt;/a&gt;背景描述&lt;/h2&gt;&lt;p&gt;&lt;code&gt;HashMap&lt;/code&gt; 是我们在工作中使用非常广泛的容器类，前面已经有一篇文章，结合自己工作中的一个使用场
      
    
    </summary>
    
    
      <category term="java开发" scheme="https://dongzl.github.io/categories/java%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Map" scheme="https://dongzl.github.io/tags/Map/"/>
    
  </entry>
  
  <entry>
    <title>《OKR 工作法》读书笔记</title>
    <link href="https://dongzl.github.io/2020/04/29/24-OKR-Work-Method/"/>
    <id>https://dongzl.github.io/2020/04/29/24-OKR-Work-Method/</id>
    <published>2020-04-29T11:17:33.000Z</published>
    <updated>2020-05-12T11:30:11.227Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>OKR：Objective and Key Results，目标与关键结果。</p></blockquote><h3 id="确定目标，确保团队聚焦到重要目标上"><a href="#确定目标，确保团队聚焦到重要目标上" class="headerlink" title="确定目标，确保团队聚焦到重要目标上"></a>确定目标，确保团队聚焦到重要目标上</h3><h6 id="管理方法的三个步骤："><a href="#管理方法的三个步骤：" class="headerlink" title="管理方法的三个步骤："></a>管理方法的三个步骤：</h6><ul><li>首先，设置有挑战、可衡量的阶段性目标。</li><li>其次，确保你和你的团队一直朝着这个目标前进，不要被其他事情干扰。</li><li>最后，把握节奏，所有成员一直明确需要努力达成的目标，并相互支持、相互鼓励。</li></ul><h3 id="讨论关键结果，复盘OKR实施过程中的问题"><a href="#讨论关键结果，复盘OKR实施过程中的问题" class="headerlink" title="讨论关键结果，复盘OKR实施过程中的问题"></a>讨论关键结果，复盘OKR实施过程中的问题</h3><ul><li><strong>目标</strong>：向餐厅供应商证明我们所提供的优质茶叶的价值。</li><li><strong>关键结果1</strong>：客户重复订购率达到70%。</li><li><strong>关键结果2</strong>：50%的重复订购客户能自助完成重复订购。</li><li><strong>关键结果3</strong>：完成25万美元的交易额。</li></ul><h3 id="评估-OKR-实施成果"><a href="#评估-OKR-实施成果" class="headerlink" title="评估 OKR 实施成果"></a>评估 OKR 实施成果</h3><ul><li>季度末成果盘点</li><li>半年末成果盘点</li><li>一年后成果盘点</li></ul><h3 id="影响目标达成的关键因素"><a href="#影响目标达成的关键因素" class="headerlink" title="影响目标达成的关键因素"></a>影响目标达成的关键因素</h3><ul><li>因素1：没有给目标设置优先级<br><strong>如果所有事情都同等重要，就意味着它们也同等不重要。</strong></li><li>因素2：缺乏充分沟通，导致没能准确理解目标<br><strong>当你说得不想再说了，人们就开始听进去了。——领英首席执行官 杰夫·韦纳</strong></li><li>因素3：没有做好计划</li><li>因素4：没有把时间花在重要的事情上<br><strong>重要的事通常不紧急，紧急的事通常不重要。——德怀特·艾森豪威尔</strong></li><li>因素5：轻易放弃<br><strong>幸福的家庭都是一样的，不幸的家庭各有各的不幸。——列夫·托尔斯泰</strong></li></ul><h6 id="设定目标遵循的原则"><a href="#设定目标遵循的原则" class="headerlink" title="设定目标遵循的原则"></a>设定目标遵循的原则</h6><ul><li>原则1：目标要明确方向并且鼓舞人心</li><li>原则2：目标要有时间期限</li><li>原则3：由独立的团队来执行目标</li></ul><h3 id="OKR-使用的六大场景"><a href="#OKR-使用的六大场景" class="headerlink" title="OKR 使用的六大场景"></a>OKR 使用的六大场景</h3><ul><li>场景1：如何开季度 OKR 会议</li><li>场景2：服务部门的 OKR 要和公司目标关联</li><li>场景3：OKR 会议的7个步骤<ul><li>所有员工提交他们认为这个季度公司需要实现的目标。</li><li>管理层用半天时间讨论 OKR。</li><li>管理层作业：向各自主管的部门介绍公司季度OKR，并完成每个部门的OKR设置。</li><li>首席执行官确认部门 OKR。</li><li>自上而下关联。</li><li>个人 OKR（可选）。</li><li>全体会议。</li></ul></li><li>场景4：为最小化可行产品使用OKR</li><li>场景5：使用 OKR 改进周报</li><li>场景6：避开 OKR 常见的坑<ul><li>设置了多个目标</li><li>设置的 OKR 周期过短–一周或者一个月</li><li>用绩效指标来驱动目标开发</li><li>没有设置信息指数</li><li>没有追踪信息指数的变化</li><li>把周一的会议当作汇报例会，而不是谈话</li><li>周五过于严肃</li></ul></li></ul><h3 id="最后的建议"><a href="#最后的建议" class="headerlink" title="最后的建议"></a>最后的建议</h3><h4 id="使用-OKR-的最后建议"><a href="#使用-OKR-的最后建议" class="headerlink" title="使用 OKR 的最后建议"></a>使用 OKR 的最后建议</h4><ul><li><p>只设置一个公司级别的 OKR，除非公司有多条业务线。这就是聚焦。</p></li><li><p>给自己三个月的时间去挑战 OKR，一周内可以完成的目标绝对称不上有挑战。</p></li><li><p>目标里不要有传统的绩效考核指标，目标需要能够鼓舞人心。</p></li><li><p>在每周盘点进度时，先从公司 OKR 开始，然后沟通部门级别的，不需要在会议上沟通个人 OKR，个人 OKR 只要一对一交流就可以了。每周必须确认 OKR 的进度。</p></li><li><p>OKR 是自上而下关联的。先设定公司的 OKR，然后是部门的，最后是个人的。</p></li><li><p>OKr 不是唯一一件你需要做的事情，而是你必须要的一件事。要相信大家可以保证事情顺利进行，不要把每个任务都塞进你的 OKR 里。</p></li><li><p>周一的 OKR 进度确认是一次谈话，而不是汇报或指示。务必要讨论信心指数、状态指标和优先级的变化。</p></li><li><p>鼓励员工对公司 OKR 提出意见和建议。OKR 不只是自上而下的实施，也要有自下而上的成分，要让所有人都能参与其中。</p></li><li><p>把 OKR 公之于众，谷歌把它们放在了公司的内网上。</p></li><li><p>周五的庆祝活动对于周一严酷的业务来说是一种调剂，可以让团队保持乐观积极的态度。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;OKR：Objective and Key Results，目标与关键结果。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;确定目标，确保团队聚焦到重要目标上&quot;&gt;&lt;a href=&quot;#确定目标，确保团队聚焦到重要目标上&quot; class=&quot;head
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://dongzl.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="https://dongzl.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>JVM 相关面试题汇总（附简要答案）</title>
    <link href="https://dongzl.github.io/2020/04/17/23-JVM-Interview-Question/"/>
    <id>https://dongzl.github.io/2020/04/17/23-JVM-Interview-Question/</id>
    <published>2020-04-17T14:48:34.000Z</published>
    <updated>2020-04-21T11:14:43.533Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>1、CMS 和 G1 的异同 – 百度<br>2、G1 什么时候引发 FullGC – 百度<br>3、说一个最熟悉的垃圾回收算法 – 百度<br>4、吞吐量优先和响应时间优先的回收器有哪些 – 百度<br>5、怎么判断内存泄漏 – 顺丰<br>6、讲一下 CMS 的流程 – 顺丰<br>7、为什么压缩指针超过 32G 失效 – 京东<br>8、什么是内存泄漏？GC 调优有经验吗？一般出现 GC 问题你怎么解决？– 淘宝<br>9、ThreadLocal 有没有内存泄漏问题 – 阿里 / 蘑菇街<br>10、G1 两个 Region 不是连续的，而且之间还有可达的引用，我现在要回收一个，另一个怎么处理？– 阿里<br>11、讲一下 JVM 堆内存管理（对象分配过程） – 阿里<br>12、听说过 CMS 的并发预处理和并发可中断预处理吗？ – 阿里<br>13、到底多大的对象会被直接扔到老年代？ – 阿里<br>14、用一句话说明你的 JVM 水平很牛 – 某个有病的企业</p></blockquote><h3 id="1、CMS-和-G1-的异同-–-百度"><a href="#1、CMS-和-G1-的异同-–-百度" class="headerlink" title="1、CMS 和 G1 的异同 – 百度"></a>1、CMS 和 G1 的异同 – 百度</h3><p><a href="https://blog.chriscs.com/2017/06/20/g1-vs-cms/" target="_blank" rel="noopener">G1 收集器与 CMS 收集器的对比与实战</a></p><h3 id="2、G1-什么时候引发-FullGC-–-百度"><a href="#2、G1-什么时候引发-FullGC-–-百度" class="headerlink" title="2、G1 什么时候引发 FullGC – 百度"></a>2、G1 什么时候引发 FullGC – 百度</h3><p>G1 提供了两种 GC 模式，Young GC 和 Mixed GC，两种都是完全 Stop The World 的。 </p><ul><li><p>Young GC：选定所有年轻代里的 Region。通过控制年轻代的 Region 个数，即年轻代内存大小，来控制 Young GC 的时间开销；</p></li><li><p>Mixed GC：选定所有年轻代里的 Region，外加根据 global concurrent marking 统计得出收集收益高的若干老年代 Region。在用户指定的开销目标范围内尽可能选择收益高的老年代 Region。</p></li></ul><p>由上面的描述可知，Mixed GC 不是 Full GC，它只能回收部分老年代的 Region，如果 Mixed GC 实在无法跟上程序分配内存的速度，导致老年代填满无法继续进行 Mixed GC，就会使用 Serial Old GC（Full GC）来收集整个 GC heap，所以我们可以知道，G1 是不提供 Full GC的。</p><p><a href="https://tech.meituan.com/2016/09/23/g1.html" target="_blank" rel="noopener">Java Hotspot G1 GC 的一些关键技术</a></p><h3 id="3、说一个最熟悉的垃圾回收算法-–-百度"><a href="#3、说一个最熟悉的垃圾回收算法-–-百度" class="headerlink" title="3、说一个最熟悉的垃圾回收算法 – 百度"></a>3、说一个最熟悉的垃圾回收算法 – 百度</h3><p>这道题是个开放性问题，可以通过自己熟悉的垃圾回收算法引申一下该算法相应的垃圾收集器实现，比如，<strong>标记–复制</strong>算法，这是 HotSpot 虚拟机新生代垃圾收集器常用的回收算法，对应的实现有 Serial、Parallel Scavenge，在比如<strong>标记–清除</strong>算法，对应的垃圾收集器实现有 CMS 等等。</p><p>一般来说，通过上面的问题，肯定继续引申你所熟悉的 HotSpot 垃圾收集器了，就目前的情况下，我理解主要讲讲 CMS 和 G1 吧；因为在往前说，Serial 和 Parallel 种类的收集器比较老了，在往后说 Shenandoah 和 ZGC 收集器又太新了，工作中使用都不多，目前应该就是 CMS 和 G1，使用比较多，而且实现原理上也比较复杂，和面试官比较有的聊。</p><h3 id="4、吞吐量优先和响应时间优先的回收器有哪些-–-百度"><a href="#4、吞吐量优先和响应时间优先的回收器有哪些-–-百度" class="headerlink" title="4、吞吐量优先和响应时间优先的回收器有哪些 – 百度"></a>4、吞吐量优先和响应时间优先的回收器有哪些 – 百度</h3><h3 id="5、怎么判断内存泄漏-–-顺丰"><a href="#5、怎么判断内存泄漏-–-顺丰" class="headerlink" title="5、怎么判断内存泄漏 – 顺丰"></a>5、怎么判断内存泄漏 – 顺丰</h3><h3 id="6、讲一下-CMS-的流程-–-顺丰"><a href="#6、讲一下-CMS-的流程-–-顺丰" class="headerlink" title="6、讲一下 CMS 的流程 – 顺丰"></a>6、讲一下 CMS 的流程 – 顺丰</h3><ul><li><p>InitialMarking（初始化标记，整个过程STW）</p><ul><li>标记GC Roots可达的老年代对象；</li><li>遍历新生代对象，标记可达的老年代对象。</li></ul></li><li><p>Marking（并发标记）</p></li><li><p>Precleaning（预清理）</p></li><li><p>AbortablePreclean（可中断的预清理）</p></li><li><p>FinalMarking（并发重新标记，STW过程）</p></li></ul><p><a href="https://www.jianshu.com/p/2a1b2f17d3e4" target="_blank" rel="noopener">图解CMS垃圾回收机制，你值得拥有</a></p><h3 id="7、为什么压缩指针超过-32G-失效-–-京东"><a href="#7、为什么压缩指针超过-32G-失效-–-京东" class="headerlink" title="7、为什么压缩指针超过 32G 失效 – 京东"></a>7、为什么压缩指针超过 32G 失效 – 京东</h3><p><a href="https://www.zhihu.com/question/365436606" target="_blank" rel="noopener">为什么JVM开启指针压缩后支持的最大堆内存是32G?</a></p><h3 id="8、什么是内存泄漏？GC-调优有经验吗？一般出现-GC-问题你怎么解决？–-淘宝"><a href="#8、什么是内存泄漏？GC-调优有经验吗？一般出现-GC-问题你怎么解决？–-淘宝" class="headerlink" title="8、什么是内存泄漏？GC 调优有经验吗？一般出现 GC 问题你怎么解决？– 淘宝"></a>8、什么是内存泄漏？GC 调优有经验吗？一般出现 GC 问题你怎么解决？– 淘宝</h3><h3 id="9、ThreadLocal-有没有内存泄漏问题-–-阿里-蘑菇街"><a href="#9、ThreadLocal-有没有内存泄漏问题-–-阿里-蘑菇街" class="headerlink" title="9、ThreadLocal 有没有内存泄漏问题 – 阿里 / 蘑菇街"></a>9、ThreadLocal 有没有内存泄漏问题 – 阿里 / 蘑菇街</h3><h3 id="10、G1-两个-Region-不是连续的，而且之间还有可达的引用，我现在要回收一个，另一个怎么处理？–-阿里"><a href="#10、G1-两个-Region-不是连续的，而且之间还有可达的引用，我现在要回收一个，另一个怎么处理？–-阿里" class="headerlink" title="10、G1 两个 Region 不是连续的，而且之间还有可达的引用，我现在要回收一个，另一个怎么处理？– 阿里"></a>10、G1 两个 Region 不是连续的，而且之间还有可达的引用，我现在要回收一个，另一个怎么处理？– 阿里</h3><h3 id="11、讲一下-JVM-堆内存管理（对象分配过程）-–-阿里"><a href="#11、讲一下-JVM-堆内存管理（对象分配过程）-–-阿里" class="headerlink" title="11、讲一下 JVM 堆内存管理（对象分配过程） – 阿里"></a>11、讲一下 JVM 堆内存管理（对象分配过程） – 阿里</h3><h3 id="12、听说过-CMS-的并发预处理和并发可中断预处理吗？-–-阿里"><a href="#12、听说过-CMS-的并发预处理和并发可中断预处理吗？-–-阿里" class="headerlink" title="12、听说过 CMS 的并发预处理和并发可中断预处理吗？ – 阿里"></a>12、听说过 CMS 的并发预处理和并发可中断预处理吗？ – 阿里</h3><p><a href="https://www.jianshu.com/p/2a1b2f17d3e4" target="_blank" rel="noopener">图解CMS垃圾回收机制，你值得拥有</a></p><h3 id="13、到底多大的对象会被直接扔到老年代？-–-阿里"><a href="#13、到底多大的对象会被直接扔到老年代？-–-阿里" class="headerlink" title="13、到底多大的对象会被直接扔到老年代？ – 阿里"></a>13、到底多大的对象会被直接扔到老年代？ – 阿里</h3><h3 id="14、用一句话说明你的-JVM-水平很牛-–-某个有病的企业"><a href="#14、用一句话说明你的-JVM-水平很牛-–-某个有病的企业" class="headerlink" title="14、用一句话说明你的 JVM 水平很牛 – 某个有病的企业"></a>14、用一句话说明你的 JVM 水平很牛 – 某个有病的企业</h3><p>精通 HotSpot 虚拟机 10 中垃圾收集器实现原理。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;1、CMS 和 G1 的异同 – 百度&lt;br&gt;2、G1 什么时候引发 FullGC – 百度&lt;br&gt;3、说一个最熟悉的垃圾回收算法 – 百度&lt;br&gt;4、吞吐量优先和响应时间优先的回收器有哪些 – 百度&lt;br&gt;5、怎么判断内存泄漏 – 顺丰&lt;br&gt;6
      
    
    </summary>
    
    
      <category term="java开发" scheme="https://dongzl.github.io/categories/java%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JVM" scheme="https://dongzl.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>如何用一句话证明你的 JVM 水平很牛</title>
    <link href="https://dongzl.github.io/2020/04/13/22-JVM-Garbage-Collection/"/>
    <id>https://dongzl.github.io/2020/04/13/22-JVM-Garbage-Collection/</id>
    <published>2020-04-13T10:37:06.000Z</published>
    <updated>2020-04-17T02:00:25.115Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景描述"><a href="#背景描述" class="headerlink" title="背景描述"></a>背景描述</h2><blockquote><p>面试官：用一句话证明你的 JVM 水平很牛；面试者：精通 HotSpot 虚拟机的 10 种垃圾回收器的实现原理。</p></blockquote><p>如果真有面试官这么问，会感觉很不专业，但是据听说的确是有人碰到过，现在的 Java 服务端面试，<code>JVM</code> 的问题基本上是绕不过去的坎儿了，今天这篇文章由这个奇葩的面试题引入，总结一下 <code>JVM</code> 中常用垃圾回收算法的一些知识内容，总结的不一定深入，但是先混个脸儿熟。</p><h2 id="分代收集理论"><a href="#分代收集理论" class="headerlink" title="分代收集理论"></a>分代收集理论</h2><p>分代收集假说：</p><ul><li>弱分代假说（Weak Generational Hypothesis）：绝大多数对象都是朝生夕灭的。</li><li>强分代假说（Strong Generational Hypothesis）：熬过越多次垃圾收集过程的对象就越难以消亡。</li><li>跨代引用假说（Intergenerational Reference Hypothesis）：跨代引用相对于同代引用来说只占极少数。</li></ul><p>基于以上几个分代假说，奠定了多款常用的垃圾收集器的设计原则：</p><ul><li>收集器应该将 Java 堆划分出不同的区域，然后将回收对象依据其年龄（年龄即对象熬过垃圾收集过程的次数）分配到不同的区域之中存储。</li><li>在Java堆划分出不同的区域之后，垃圾收集器才可以每次只回收其中某一个或者某些部分的区域，同时能够针对不同的区域安排与里面存储对象存亡特征相匹配的垃圾收集算法。</li><li>如果对象之间存在跨代引用，那么存在互相引用关系的两个对象，是应该倾向于同时生存或者同时消亡的，所以没必要因为存在跨代引用，在新生代垃圾回收时扫描整个老年代，只需在新生代上建立一个全局的数据结构（该结构被称为“记忆集”，Remembered Set），这个结构把老年代划分成若干小块，标识出老年代的哪一块内存会存在跨代引用。</li></ul><h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><h3 id="标记–清除算法（Mark-Sweep）"><a href="#标记–清除算法（Mark-Sweep）" class="headerlink" title="标记–清除算法（Mark-Sweep）"></a>标记–清除算法（Mark-Sweep）</h3><img src="https://gitee.com/dongzl/article-images/raw/master/2020/22-JVM-Garbage-Collection/JVM-Garbage-Collection-01.png" width="600px"><p>优点：</p><ul><li>系统最初运行时，垃圾回收效率可能会比较高，因为不需要做内存间的拷贝。</li></ul><p>缺点：</p><ul><li>执行效率不稳定，如果 JVM 中包含大量朝生夕灭的对象，就需要进行大量标记和清除的动作，导致标记和清除两个过程的执行效率都随对象数量增长而降低；</li><li>内存空间的碎片化问题，标记、清除之后会产生大量不连续的内存碎片，如果无法给一个大对象分配足够空间，JVM 会提前触发 Full GC。</li></ul><h3 id="标记–复制算法（Copying）"><a href="#标记–复制算法（Copying）" class="headerlink" title="标记–复制算法（Copying）"></a>标记–复制算法（Copying）</h3><img src="https://gitee.com/dongzl/article-images/raw/master/2020/22-JVM-Garbage-Collection/JVM-Garbage-Collection-02.png" width="600px"><p>优点：</p><ul><li>不会有内存碎片化的问题；</li><li>效率很高，不管是拷贝，还是清除整块空间的内存，速度都是非常快的；</li><li>顺带的进行了内存的压缩。</li></ul><p>缺点：</p><ul><li>浪费一半内存空间。</li></ul><h3 id="标记–整理算法（Mark-Compack）"><a href="#标记–整理算法（Mark-Compack）" class="headerlink" title="标记–整理算法（Mark-Compack）"></a>标记–整理算法（Mark-Compack）</h3><img src="https://gitee.com/dongzl/article-images/raw/master/2020/22-JVM-Garbage-Collection/JVM-Garbage-Collection-03.png" width="600px"><p>优点：</p><ul><li>不会有内存碎片化的问题；</li><li>不会有内存空间浪费。</li></ul><p>缺点：</p><ul><li>效率并不算高，比较适用于老年代区的垃圾回收。</li></ul><p>这个算法是老年代内存区的默认算法，因为老年代中，存活对象比较多，垃圾对象比较少，这个算法压缩的过程实际上是将存活的对象替换掉垃圾对象，所以在垃圾对象比较少的情况下，只需要很少的操作就能完成GC。</p><h3 id="JVM-分代算法"><a href="#JVM-分代算法" class="headerlink" title="JVM 分代算法"></a>JVM 分代算法</h3><ul><li><p>年轻代（New / Young）</p><ul><li>存活对象少</li><li>使用 copy 算法，效率高</li></ul></li><li><p>年老代（Old）</p><ul><li>垃圾对象少</li><li>使用 Mark-Compack 算法</li></ul></li></ul><img src="https://gitee.com/dongzl/article-images/raw/master/2020/22-JVM-Garbage-Collection/JVM-Garbage-Collection-04.png" width="600px"><h2 id="HotSpot-虚拟机垃圾收集器"><a href="#HotSpot-虚拟机垃圾收集器" class="headerlink" title="HotSpot 虚拟机垃圾收集器"></a>HotSpot 虚拟机垃圾收集器</h2><img src="https://gitee.com/dongzl/article-images/raw/master/2020/22-JVM-Garbage-Collection/JVM-Garbage-Collection-05.jpg" width="600px"><h3 id="Serial"><a href="#Serial" class="headerlink" title="Serial"></a>Serial</h3><p><strong>a stop-the-world, copying collector which uses a single GC thread.</strong></p><ul><li>客户端模式下的默认新生代收集器；</li><li>简单而高效，额外的内存消耗最小；</li><li>可以管理较小内存（几十兆到一两百兆内存）</li></ul><img src="https://gitee.com/dongzl/article-images/raw/master/2020/22-JVM-Garbage-Collection/JVM-Garbage-Collection-06.jpg" width="600px"><p>Serial/Serial Old收集器运行示意图</p><h3 id="Serial-Old"><a href="#Serial-Old" class="headerlink" title="Serial Old"></a>Serial Old</h3><p><strong>a stop-the-world, mark-sweep-compact collector that uses a single GC thread.</strong></p><p>Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器，使用标记-整理算法。</p><img src="https://gitee.com/dongzl/article-images/raw/master/2020/22-JVM-Garbage-Collection/JVM-Garbage-Collection-06.jpg" width="600px"><h3 id="Parallel-Scavenge"><a href="#Parallel-Scavenge" class="headerlink" title="Parallel Scavenge"></a>Parallel Scavenge</h3><p><strong>a stop-the-world, copying collector which uses multiple GC thread.</strong></p><ul><li>新生代收集器；</li><li>基于标记–复制算法的收集器；</li><li>并行收集的多线程收集器；</li><li>可控制吞吐量的收集器。</li></ul><p>$$吞吐量=\frac{运行用户代码时间}{运行用户代码时间+运行垃圾收集时间}$$</p><ul><li><p>-XX:MaxGCPauseMillis：控制最大垃圾收集停顿时间；该参数允许的值是一个大于 0 的毫秒数，收集器将尽力保证内存回收花费的时间不超过用户设定值；</p></li><li><p>-XX:GCTimeRatio：直接设置吞吐量大小，该参数的值是一个大于 0 小于 100 的整数，也就是垃圾收集时间占总时间的比率，相当于吞吐量的倒数。譬如把此参数设置为 19，那允许的最大垃圾收集时间就占总时间的 5%（即1/(1+19)），默认值为 99，即允许最大 1%（即1/(1+99)）的垃圾收集时间。</p></li><li><p>-XX:+UseAdaptiveSizePolicy：开启自适应调节策略，当这个参数被激活之后，就不需要人工一些参数细节了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。</p></li></ul><h3 id="ParNew"><a href="#ParNew" class="headerlink" title="ParNew"></a>ParNew</h3><ul><li><p>ParNew 收集器实质上是 Serial 收集器的多线程并行版本。</p></li><li><p>除了 Serial 收集器外，目前只有 ParNew 能与 CMS 收集器配合工作。</p></li><li><p>使用 <code>-XX:+UseConcMarkSweepGC</code> 选项激活老年代 CMS 收集器后，ParNew 就是默认开启的新生代收集器，也可以使用 <code>-XX:+/-UseParNewGC</code> 来强制使用或禁止它。</p></li><li><p>JDK 9 之后 -XX：+UseParNewGC 参数被取消，这意味着ParNew和CMS从此只能互相搭配使用，再也没有其他收集器能够和它们配合了。</p></li><li><p>ParNew 收集器默认开启的收集线程数与处理器核心数量相同，在处理器核心非常多的环境中，可以使用 <code>-XX:ParallelGCThreads</code> 参数来限制垃圾收集的线程数。</p></li></ul><img src="https://gitee.com/dongzl/article-images/raw/master/2020/22-JVM-Garbage-Collection/JVM-Garbage-Collection-08.jpg" width="600px"><p>ParNew/Serial Old收集器运行示意图</p><h3 id="Parallel-Old"><a href="#Parallel-Old" class="headerlink" title="Parallel Old"></a>Parallel Old</h3><p>Parallel Old是Parallel Scavenge收集器的老年代版本，支持多线程并发收集，基于标记-整理算法实现。</p><img src="https://gitee.com/dongzl/article-images/raw/master/2020/22-JVM-Garbage-Collection/JVM-Garbage-Collection-09.jpg" width="600px"><p>Parallel Scavenge/Parallel Old收集器运行示意图</p><h3 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h3><p>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器，该收集器基于标记–清除算法实现。</p><p>CMS 垃圾收集四个步骤：</p><ul><li><p>初始标记（CMS initial mark）：Stop The World，初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快；</p></li><li><p>并发标记（CMS concurrent mark）：并发标记阶段就是从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行；</p></li><li><p>重新标记（CMS remark）：Stop The World，重新标记阶段则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短；</p></li><li><p>并发清除（CMS concurrent sweep）：并发清除阶段，清理删除掉标记阶段判断的已经死亡的对象，由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的。</p></li></ul><img src="https://gitee.com/dongzl/article-images/raw/master/2020/22-JVM-Garbage-Collection/JVM-Garbage-Collection-10.jpg" width="600px"><p>Concurrent Mark Sweep收集器运行示意图</p><p>CMS 垃圾收集器不足：</p><ul><li><p>CMS收集器对处理器资源非常敏感；CMS默认启动的回收线程数是（处理器核心数量+3）/4，当处理器核心数比较小时，垃圾回收器会占用比较多的处理器运算资源；</p></li><li><p>CMS 垃圾收集器无法处理“浮动垃圾（Floating Garbage）”，浮动垃圾是 CMS 在并发标记和并发清理阶段用户线程运行产生的垃圾；所以需要预留一段内存空间供并发收集时的程序运作使用，<code>-XX:CMSInitiatingOccu-pancyFraction</code> 参数用于设置该比例，表示老年代使用了该比率的空间后就会被触发垃圾回收；</p></li><li><p>基于标记–清除算法实现，会产生内存碎片。</p><ul><li>-XX:+UseCMS-CompactAtFullCollection：在CMS收集器不得不进行Full GC时开启内存碎片的合并整理过程；</li><li>-XX:CMSFullGCsBefore-Compaction：这个参数的作用是要求 CMS 收集器在执行过若干次（数量由参数值决定）不整理空间的 Full GC 之后，下一次进入 Full GC 前会先进行碎片整理（默认值为 0，表示每次进入 Full GC 时都进行碎片整理）。</li></ul></li></ul><h3 id="Garbage-First"><a href="#Garbage-First" class="headerlink" title="Garbage First"></a>Garbage First</h3><img src="https://gitee.com/dongzl/article-images/raw/master/2020/22-JVM-Garbage-Collection/JVM-Garbage-Collection-11.png" width="600px"><ul><li><p>G1是一款主要面向服务端应用的垃圾收集器。</p></li><li><p>G1不再坚持固定大小以及固定数量的分代区域划分，而是把连续的Java堆划分为多个大小相等的独立区域（Region），每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间。</p></li><li><p>Region中还有一类特殊的Humongous区域，专门用来存储大对象。G1认为只要大小超过了一个Region容量一半的对象即可判定为大对象。</p></li><li><p>-XX:G1HeapRegionSize：指定 Region 大小，取值范围 1MB ~ 32MB， 为 2 的 N 次幂。</p></li><li><p>G1 收集器负责跟踪各个 Region 里面的垃圾堆积的“价值”大小，价值即回收所获得的空间大小以及回收所需时间的经验值，然后在后台维护一个优先级列表，每次根据用户设定允许的收集停顿时间（使用参数-XX:MaxGCPauseMillis指定，默认值是200毫秒），优先处理回收价值收益最大的那些 Region，这也就是“Garbage First” 名字的由来。</p></li></ul><p>G1 收集器工作步骤：</p><ul><li>初始标记 （Initial Marking）</li><li>并发标记（Concurrent Marking）</li><li>最终标记（Final Marking）</li><li>筛选回收（Live Data Counting and Evacuation）</li></ul><img src="https://gitee.com/dongzl/article-images/raw/master/2020/22-JVM-Garbage-Collection/JVM-Garbage-Collection-12.jpg" width="600px"><h3 id="Shenandoah"><a href="#Shenandoah" class="headerlink" title="Shenandoah"></a>Shenandoah</h3><p>Shenandoah 收集器工作过程：</p><ul><li><p>初始标记（Initial Marking）</p></li><li><p>并发标记（Concurrent Marking）</p></li><li><p>最终标记（Final Marking）</p></li><li><p>并发清理（Concurrent Cleanup）</p></li><li><p>并发回收（Concurrent Evacuation）</p></li><li><p>初始引用更新（Initial Update Reference）</p></li><li><p>并发引用更新（Concurrent Update Reference）</p></li><li><p>最终引用更新（Final Update Reference）</p></li><li><p>并发清理（Concurrent Cleanup）</p></li></ul><img src="https://gitee.com/dongzl/article-images/raw/master/2020/22-JVM-Garbage-Collection/JVM-Garbage-Collection-13.png" width="600px"><p>Shenandoah 收集器的工作过程</p><h3 id="ZGC"><a href="#ZGC" class="headerlink" title="ZGC"></a>ZGC</h3><p>ZGC 是一款在 JDK 11 中新加入的具有实验性质的低延迟垃圾收集器。</p><p>ZGC 和 Shenandoah 的目标是高度相似的，都希望在尽可能对吞吐量影响不太大的前提下，实现在任意堆内存大小下都可以把垃圾收集的停顿时间限制在十毫秒以内的低延迟。</p><p>ZGC 也是采用基于Region的堆内存布局，ZGC 的 Region 具有动态性——动态创建和销毁，以及动态的区域容量大小。</p><ul><li><p>小型Region（Small Region）：容量固定为2MB，用于放置小于256KB的小对象。</p></li><li><p>中型Region（Medium Region）：容量固定为32MB，用于放置大于等于256KB但小于4MB的对象。</p></li><li><p>大型 Region（Large Region）：容量不固定，可以动态变化，但必须为2MB的整数倍，用于放置4MB或以上的大对象。</p></li></ul><img src="https://gitee.com/dongzl/article-images/raw/master/2020/22-JVM-Garbage-Collection/JVM-Garbage-Collection-14.jpg" width="600px"><p>ZGC 执行过程：</p><ul><li><p>并发标记 （Concurrent Mark）</p></li><li><p>并发预备重分配 （Concurrent Prepare for Relocate）</p></li><li><p>并发重分配 （Concurrent Relocate）</p></li><li><p>并发重映射 （Concurrent Remap）</p></li></ul><h3 id="Epsilon"><a href="#Epsilon" class="headerlink" title="Epsilon"></a>Epsilon</h3><p>Epsilon 被形容是一个无操作的收集器，如果某个应用只要运行数分钟甚至数秒，只要 Java 虚拟机能正确分配内存，在堆耗尽之前就会退出，那显然运行负载极小、没有任何回收行为的 Epsilon 便是很恰当的选择。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>深入理解Java虚拟机：JVM高级特性与最佳实践（第3版）作者：周志明 机械工业出版社 2029-12-01 出版，ISBN：9787111641247</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景描述&quot;&gt;&lt;a href=&quot;#背景描述&quot; class=&quot;headerlink&quot; title=&quot;背景描述&quot;&gt;&lt;/a&gt;背景描述&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;面试官：用一句话证明你的 JVM 水平很牛；面试者：精通 HotSpot 虚拟机的 10 种垃圾回
      
    
    </summary>
    
    
      <category term="java开发" scheme="https://dongzl.github.io/categories/java%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JVM" scheme="https://dongzl.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Maven Wrapper 工具在开源项目中的使用</title>
    <link href="https://dongzl.github.io/2020/04/08/21-What-Is-Maven-Wrapper/"/>
    <id>https://dongzl.github.io/2020/04/08/21-What-Is-Maven-Wrapper/</id>
    <published>2020-04-08T09:11:54.000Z</published>
    <updated>2020-04-09T10:07:12.932Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>声明：本文内容摘自 <a href="http://www.javacoder.cn/?p=759" target="_blank" rel="noopener">Mvnw 简介</a> 博客内容，部分内容有调整。</p></blockquote><h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>最近一段时间在参与 <a href="http://shardingsphere.apache.org/" target="_blank" rel="noopener">ShardingSphere</a> 开源项目的一些工作，在项目有贡献者提交了 PR，将 <a href="https://github.com/takari/maven-wrapper" target="_blank" rel="noopener">Maven Wrapper</a> 工具集成到了该项目中，第一次听说这个工具，就顺带自己学习了一下，同时也将这个工具集成到了 <a href="http://dolphinscheduler.apache.org" target="_blank" rel="noopener">DolphinScheduler</a> 项目中（PR 地址：<a href="https://github.com/apache/incubator-dolphinscheduler/pull/2381" target="_blank" rel="noopener">Add maven-wrapper support for dolphinscheduler. </a>）。</p><h2 id="Maven-Wrapper-原理"><a href="#Maven-Wrapper-原理" class="headerlink" title="Maven Wrapper 原理"></a>Maven Wrapper 原理</h2><p><code>Maven</code> 是 <code>java</code> 开发中广泛使用的项目构建工具，目前 <code>maven</code> 工具已经发行了很多个版本，如果在一个公司内部，我们可以通过规定要求大家使用统一的 <code>maven</code> 版本，那如果是开源项目，如何保证彼此不熟悉的开源参与者使用的 <code>maven</code> 版本保持一致呢，这时候 <code>Maven Wrapper</code> 就派上用场了。<code>Maven Wrapper</code> 的原理是在 <code>maven-wrapper.properties</code> 文件中记录项目中使用的 <code>maven</code> 版本，当用户执行 <code>mvnw clean</code> 命令时，发现当前用户的 <code>maven</code> 版本和期望的版本不一致，那么就下载指定的版本，然后用指定的版本来执行 <code>mvn</code> 命令。</p><h2 id="Maven-Wrapper-使用"><a href="#Maven-Wrapper-使用" class="headerlink" title="Maven Wrapper 使用"></a>Maven Wrapper 使用</h2><h3 id="在-pom-xml-文件中添加-plugin-声明"><a href="#在-pom-xml-文件中添加-plugin-声明" class="headerlink" title="在 pom.xml 文件中添加 plugin 声明"></a>在 pom.xml 文件中添加 plugin 声明</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.rimerosolutions.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>wrapper-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当执行 <code>mvn wrapper:wrapper</code> 命令时，<code>Maven Wrapper</code> 会自动生成 <code>mvnw.bat、mvnw、maven/maven-wrapper.jar、maven/maven-wrapper.properties</code> 文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">maven</span><br><span class="line">  maven-wrapper.jar</span><br><span class="line">  maven-wrapper.properties</span><br><span class="line">mvnw</span><br><span class="line">mvnw.bat</span><br></pre></td></tr></table></figure><p>然后我们就可以使用 <code>mvnw</code> 代替 <code>mvn</code> 执行所有的 <code>maven</code> 命令，例如 <code>mvnw clean package</code>。</p><h3 id="直接使用-mvn-命令"><a href="#直接使用-mvn-命令" class="headerlink" title="直接使用 mvn 命令"></a>直接使用 mvn 命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mvn -N io.takari:maven:wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3.6.3 表示我们指定使用的 maven 版本</span></span><br><span class="line">mvn -N io.takari:maven:wrapper -Dmaven=3.6.3</span><br></pre></td></tr></table></figure><p>这种方式产生的内容和第一种方式是一样的，只是目录结构有所不同，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.mvn</span><br><span class="line">  wrapper</span><br><span class="line">    maven-wrapper.jar</span><br><span class="line">    maven-wrapper.properties</span><br><span class="line">    MavenWrapperDownloader.java</span><br><span class="line">mvnw</span><br><span class="line">mvnw.cmd</span><br></pre></td></tr></table></figure><p><code>maven-wrapper.jar</code> 和 <code>maven-wrapper.properties</code> 在 <strong>.mvn/wrapper</strong> 目录下。</p><ul><li><p>maven-wrapper.jar file is used to download and invoke maven from the wrapper shell scripts.</p></li><li><p>maven-wrapper.properties is used to specify the URL Maven should be downloaded from if not already present on the system.</p></li><li><p>Maven is downloaded by compiling and executing the Java class file MavenWrapperDownloader.java present in the same .mvn folder.</p></li></ul><h3 id="使用注意事项"><a href="#使用注意事项" class="headerlink" title="使用注意事项"></a>使用注意事项</h3><p>由于使用了指定的 <code>maven</code> 版本，如果 <code>settings.xml</code> 文件没有放到当前用户下的 <code>.m2</code> 目录下，那么执行 <code>mvnw</code> 时是无法读取到原有的 <code>settings.xml</code> 文件。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.cnblogs.com/easonjim/p/7620085.html" target="_blank" rel="noopener">mvnw是什么（Maven Wrapper/Maven保持构建工具版本一直的工具）</a></li><li><a href="https://medium.com/xebia-engineering/a-quick-introduction-to-maven-wrapper-f1d9dbb4ea5e" target="_blank" rel="noopener">A Quick Introduction to Maven Wrapper</a></li><li><a href="https://stackoverflow.com/questions/38723833/what-is-the-purpose-of-mvnw-and-mvnw-cmd-files" target="_blank" rel="noopener">What is the purpose of mvnw and mvnw.cmd files?</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;声明：本文内容摘自 &lt;a href=&quot;http://www.javacoder.cn/?p=759&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Mvnw 简介&lt;/a&gt; 博客内容，部分内容有调整。&lt;/p&gt;
&lt;/blockquote
      
    
    </summary>
    
    
      <category term="web开发" scheme="https://dongzl.github.io/categories/web%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="maven" scheme="https://dongzl.github.io/tags/maven/"/>
    
  </entry>
  
  <entry>
    <title>(转) Java 中锁实现原理以及锁升级过程</title>
    <link href="https://dongzl.github.io/2020/04/03/20-Mashibing-Synchronized-Volatile-CAS/"/>
    <id>https://dongzl.github.io/2020/04/03/20-Mashibing-Synchronized-Volatile-CAS/</id>
    <published>2020-04-03T13:55:43.000Z</published>
    <updated>2020-04-09T03:08:42.653Z</updated>
    
    <content type="html"><![CDATA[<h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><blockquote><p>请描述 synchrnoized 和 ReentrantLock 的底层实现及重入的底层原理 – 百度、阿里<br>请描述锁的四种状态和升级过程 – 百度、阿里<br>CAS 的 ABA 问题如何解决 – 百度<br>请谈一下 AQS，为什么 AQS 的底层是 CAS + volatile – 百度<br>请谈一下你对 volatile 的理解 – 美团、阿里<br>volatile 的可见性和禁止指令重排序是如何实现的 – 美团<br>CAS 是什么 – 美团<br>请描述一下对象的创建过程 – 美团、顺丰<br>对象在内存中的内存布局 – 美团、顺丰<br>DCL 单例为什么要加 volatile – 美团<br>解释一下锁的四种状态 – 顺丰<br>Object o = new Object() 在内存中占了多少字节? – 顺丰<br>请描述 synchronized 和 ReentrantLock 的异同<br>聊聊你对 as-if-serial 和 happens-before 语义的理解 – 京东<br>你了解ThreadLocal吗？你知道ThreadLocal 中如何解决内存泄漏问题吗? – 京东、阿里<br>请描述一下锁的分类以及 JDK 中的应用 – 阿里</p></blockquote><h2 id="用户态与内核态"><a href="#用户态与内核态" class="headerlink" title="用户态与内核态"></a>用户态与内核态</h2><p>JDK1.0，synchronized 叫做重量级锁， 因为申请锁资源必须通过kernel, 系统调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">;hello.asm</span><br><span class="line">;write(int fd, const void *buffer, size_t nbytes)</span><br><span class="line"></span><br><span class="line">section data</span><br><span class="line">    msg db &quot;Hello&quot;, 0xA</span><br><span class="line">    len equ $ - msg</span><br><span class="line"></span><br><span class="line">section .text</span><br><span class="line">global _start</span><br><span class="line">_start:</span><br><span class="line"></span><br><span class="line">    mov edx, len</span><br><span class="line">    mov ecx, msg</span><br><span class="line">    mov ebx, 1 ;文件描述符1 std_out</span><br><span class="line">    mov eax, 4 ;write函数系统调用号 4</span><br><span class="line">    int 0x80</span><br><span class="line"></span><br><span class="line">    mov ebx, 0</span><br><span class="line">    mov eax, 1 ;exit函数系统调用号</span><br><span class="line">    int 0x80</span><br></pre></td></tr></table></figure><h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><p>Compare And Swap (Compare And Exchange) / 自旋 / 自旋锁 / 无锁 （无重量锁）</p><p>因为经常配合循环操作，直到完成为止，所以泛指一类操作</p><p>cas(v, a, b) ，变量v，期待值a, 修改值b</p><p>ABA问题，你的女朋友在离开你的这段儿时间经历了别的人，自旋就是你空转等待，一直等到她接纳你为止</p><p>解决办法（版本号 AtomicStampedReference），基础类型简单值不需要版本号</p><h1 id="Unsafe"><a href="#Unsafe" class="headerlink" title="Unsafe"></a>Unsafe</h1><p>AtomicInteger:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> current = get();</span><br><span class="line">        <span class="keyword">int</span> next = current + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSet(current, next))</span><br><span class="line">            <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Unsafe:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4, <span class="keyword">int</span> var5)</span></span>;</span><br></pre></td></tr></table></figure><p>运用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mashibing.jol;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sun.misc.Unsafe;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T02_TestUnsafe</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> T02_TestUnsafe t = <span class="keyword">new</span> T02_TestUnsafe();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//Unsafe unsafe = Unsafe.getUnsafe();</span></span><br><span class="line"></span><br><span class="line">        Field unsafeField = Unsafe.class.getDeclaredFields()[<span class="number">0</span>];</span><br><span class="line">        unsafeField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Unsafe unsafe = (Unsafe) unsafeField.get(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        Field f = T02_TestUnsafe.class.getDeclaredField(<span class="string">"i"</span>);</span><br><span class="line">        <span class="keyword">long</span> offset = unsafe.objectFieldOffset(f);</span><br><span class="line">        System.out.println(offset);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> success = unsafe.compareAndSwapInt(t, offset, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        System.out.println(success);</span><br><span class="line">        System.out.println(t.i);</span><br><span class="line">        <span class="comment">//unsafe.compareAndSwapInt()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>jdk8u: unsafe.cpp:</p><p>cmpxchg = compare and exchange</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSwapInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x))</span><br><span class="line">  UnsafeWrapper(<span class="string">"Unsafe_CompareAndSwapInt"</span>);</span><br><span class="line">  oop p = JNIHandles::resolve(obj);</span><br><span class="line">  jint* addr = (jint *) index_oop_from_field_offset_long(p, offset);</span><br><span class="line">  <span class="keyword">return</span> (jint)(Atomic::cmpxchg(x, addr, e)) == e;</span><br><span class="line">UNSAFE_END</span><br></pre></td></tr></table></figure><p>jdk8u: atomic_linux_x86.inline.hpp <strong>93行</strong></p><p>is_MP = Multi Processor  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> jint     Atomic::cmpxchg    (jint     exchange_value, <span class="keyword">volatile</span> jint*     dest, jint     compare_value) &#123;</span><br><span class="line">  <span class="keyword">int</span> mp = os::is_MP();</span><br><span class="line">  __<span class="function">asm__ <span class="title">volatile</span> <span class="params">(LOCK_IF_MP(%<span class="number">4</span>) <span class="string">"cmpxchgl %1,(%3)"</span></span></span></span><br><span class="line"><span class="function"><span class="params">                    : <span class="string">"=a"</span> (exchange_value)</span></span></span><br><span class="line"><span class="function"><span class="params">                    : <span class="string">"r"</span> (exchange_value), <span class="string">"a"</span> (compare_value), <span class="string">"r"</span> (dest), <span class="string">"r"</span> (mp)</span></span></span><br><span class="line"><span class="function"><span class="params">                    : <span class="string">"cc"</span>, <span class="string">"memory"</span>)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> exchange_value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>jdk8u: os.hpp is_MP()</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">is_MP</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// During bootstrap if _processor_count is not yet initialized</span></span><br><span class="line">    <span class="comment">// we claim to be MP as that is safest. If any platform has a</span></span><br><span class="line">    <span class="comment">// stub generator that might be triggered in this phase and for</span></span><br><span class="line">    <span class="comment">// which being declared MP when in fact not, is a problem - then</span></span><br><span class="line">    <span class="comment">// the bootstrap routine for the stub generator needs to check</span></span><br><span class="line">    <span class="comment">// the processor count directly and leave the bootstrap routine</span></span><br><span class="line">    <span class="comment">// in place until called after initialization has ocurred.</span></span><br><span class="line">    <span class="keyword">return</span> (_processor_count != <span class="number">1</span>) || AssumeMP;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>jdk8u: atomic_linux_x86.inline.hpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCK_IF_MP(mp) <span class="meta-string">"cmp $0, "</span> #mp <span class="meta-string">"; je 1f; lock; 1: "</span></span></span><br></pre></td></tr></table></figure><p>最终实现：</p><p>cmpxchg = cas修改变量值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock cmpxchg 指令</span><br></pre></td></tr></table></figure><p>硬件：</p><p>lock指令在执行后面指令的时候锁定一个北桥信号</p><p>（不采用锁总线的方式）</p><h2 id="markword"><a href="#markword" class="headerlink" title="markword"></a>markword</h2><h3 id="工具：JOL-Java-Object-Layout"><a href="#工具：JOL-Java-Object-Layout" class="headerlink" title="工具：JOL = Java Object Layout"></a>工具：JOL = Java Object Layout</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.openjdk.jol/jol-core --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jol<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jol-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>jdk8u: markOop.hpp</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bit-format of an object header (most significant first, big endian layout below):</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  32 bits:</span></span><br><span class="line"><span class="comment">//  --------</span></span><br><span class="line"><span class="comment">//             hash:25 ------------&gt;| age:4    biased_lock:1 lock:2 (normal object)</span></span><br><span class="line"><span class="comment">//             JavaThread*:23 epoch:2 age:4    biased_lock:1 lock:2 (biased object)</span></span><br><span class="line"><span class="comment">//             size:32 ------------------------------------------&gt;| (CMS free block)</span></span><br><span class="line"><span class="comment">//             PromotedObject*:29 ----------&gt;| promo_bits:3 -----&gt;| (CMS promoted object)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  64 bits:</span></span><br><span class="line"><span class="comment">//  --------</span></span><br><span class="line"><span class="comment">//  unused:25 hash:31 --&gt;| unused:1   age:4    biased_lock:1 lock:2 (normal object)</span></span><br><span class="line"><span class="comment">//  JavaThread*:54 epoch:2 unused:1   age:4    biased_lock:1 lock:2 (biased object)</span></span><br><span class="line"><span class="comment">//  PromotedObject*:61 ---------------------&gt;| promo_bits:3 -----&gt;| (CMS promoted object)</span></span><br><span class="line"><span class="comment">//  size:64 -----------------------------------------------------&gt;| (CMS free block)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  unused:25 hash:31 --&gt;| cms_free:1 age:4    biased_lock:1 lock:2 (COOPs &amp;&amp; normal object)</span></span><br><span class="line"><span class="comment">//  JavaThread*:54 epoch:2 cms_free:1 age:4    biased_lock:1 lock:2 (COOPs &amp;&amp; biased object)</span></span><br><span class="line"><span class="comment">//  narrowOop:32 unused:24 cms_free:1 unused:4 promo_bits:3 -----&gt;| (COOPs &amp;&amp; CMS promoted object)</span></span><br><span class="line"><span class="comment">//  unused:21 size:35 --&gt;| cms_free:1 unused:7 ------------------&gt;| (COOPs &amp;&amp; CMS free block)</span></span><br></pre></td></tr></table></figure><h2 id="synchronized的横切面详解"><a href="#synchronized的横切面详解" class="headerlink" title="synchronized的横切面详解"></a>synchronized的横切面详解</h2><ol><li>synchronized原理</li><li>升级过程</li><li>汇编实现</li><li>vs reentrantLock的区别</li></ol><h3 id="java源码层级"><a href="#java源码层级" class="headerlink" title="java源码层级"></a>java源码层级</h3><p>synchronized(o) </p><h3 id="字节码层级"><a href="#字节码层级" class="headerlink" title="字节码层级"></a>字节码层级</h3><p>monitorenter moniterexit</p><h3 id="JVM层级（Hotspot）"><a href="#JVM层级（Hotspot）" class="headerlink" title="JVM层级（Hotspot）"></a>JVM层级（Hotspot）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mashibing.insidesync;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.openjdk.jol.info.ClassLayout;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T01_Sync1</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Object o = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">        System.out.println(ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">com.mashibing.insidesync.T01_Sync1$Lock object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      <span class="number">0</span>     <span class="number">4</span>   (object header)  <span class="number">05</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000101</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">5</span>)</span><br><span class="line">      <span class="number">4</span>     <span class="number">4</span>   (object header)  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">0</span>)</span><br><span class="line">      <span class="number">8</span>     <span class="number">4</span>   (object header)  <span class="number">49</span> ce <span class="number">00</span> <span class="number">20</span> (<span class="number">01001001</span> <span class="number">11001110</span> <span class="number">00000000</span> <span class="number">00100000</span>) (<span class="number">536923721</span>)</span><br><span class="line">     <span class="number">12</span>     <span class="number">4</span>        (loss due to the next object alignment)</span><br><span class="line">Instance size: <span class="number">16</span> bytes</span><br><span class="line">Space losses: <span class="number">0</span> bytes internal + <span class="number">4</span> bytes external = <span class="number">4</span> bytes total</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">com.mashibing.insidesync.T02_Sync2$Lock object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      <span class="number">0</span>     <span class="number">4</span>   (object header)  <span class="number">05</span> <span class="number">90</span> <span class="number">2</span>e <span class="number">1</span>e (<span class="number">00000101</span> <span class="number">10010000</span> <span class="number">00101110</span> <span class="number">00011110</span>) (<span class="number">506368005</span>)</span><br><span class="line">      <span class="number">4</span>     <span class="number">4</span>   (object header)  <span class="number">1</span>b <span class="number">02</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00011011</span> <span class="number">00000010</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">539</span>)</span><br><span class="line">      <span class="number">8</span>     <span class="number">4</span>   (object header)  <span class="number">49</span> ce <span class="number">00</span> <span class="number">20</span> (<span class="number">01001001</span> <span class="number">11001110</span> <span class="number">00000000</span> <span class="number">00100000</span>) (<span class="number">536923721</span>)</span><br><span class="line">     <span class="number">12</span>     <span class="number">4</span>        (loss due to the next object alignment)</span><br><span class="line">Instance size: <span class="number">16</span> bytes</span><br><span class="line">Space losses: <span class="number">0</span> bytes internal + <span class="number">4</span> bytes external = <span class="number">4</span> bytes tota</span><br></pre></td></tr></table></figure><p>InterpreterRuntime:: monitorenter方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">IRT_ENTRY_NO_ASYNC(<span class="keyword">void</span>, InterpreterRuntime::monitorenter(JavaThread* thread, BasicObjectLock* elem))</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ASSERT</span></span><br><span class="line">  thread-&gt;last_frame().interpreter_frame_verify_monitor(elem);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">if</span> (PrintBiasedLockingStatistics) &#123;</span><br><span class="line">    Atomic::inc(BiasedLocking::slow_path_entry_count_addr());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">Handle <span class="title">h_obj</span><span class="params">(thread, elem-&gt;obj())</span></span>;</span><br><span class="line">  assert(Universe::heap()-&gt;is_in_reserved_or_null(h_obj()),</span><br><span class="line">         <span class="string">"must be NULL or an object"</span>);</span><br><span class="line">  <span class="keyword">if</span> (UseBiasedLocking) &#123;</span><br><span class="line">    <span class="comment">// Retry fast entry if bias is revoked to avoid unnecessary inflation</span></span><br><span class="line">    ObjectSynchronizer::fast_enter(h_obj, elem-&gt;lock(), <span class="literal">true</span>, CHECK);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ObjectSynchronizer::slow_enter(h_obj, elem-&gt;lock(), CHECK);</span><br><span class="line">  &#125;</span><br><span class="line">  assert(Universe::heap()-&gt;is_in_reserved_or_null(elem-&gt;obj()),</span><br><span class="line">         <span class="string">"must be NULL or an object"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ASSERT</span></span><br><span class="line">  thread-&gt;last_frame().interpreter_frame_verify_monitor(elem);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">IRT_END</span><br></pre></td></tr></table></figure><p>synchronizer.cpp</p><p>revoke_and_rebias</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> ObjectSynchronizer::fast_enter(Handle obj, BasicLock* lock, <span class="keyword">bool</span> attempt_rebias, TRAPS) &#123;</span><br><span class="line"> <span class="keyword">if</span> (UseBiasedLocking) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!SafepointSynchronize::is_at_safepoint()) &#123;</span><br><span class="line">      BiasedLocking::Condition cond = BiasedLocking::revoke_and_rebias(obj, attempt_rebias, THREAD);</span><br><span class="line">      <span class="keyword">if</span> (cond == BiasedLocking::BIAS_REVOKED_AND_REBIASED) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      assert(!attempt_rebias, <span class="string">"can not rebias toward VM thread"</span>);</span><br><span class="line">      BiasedLocking::revoke_at_safepoint(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    assert(!obj-&gt;mark()-&gt;has_bias_pattern(), <span class="string">"biases should be revoked by now"</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> slow_enter (obj, lock, THREAD) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> ObjectSynchronizer::slow_enter(Handle obj, BasicLock* lock, TRAPS) &#123;</span><br><span class="line">  markOop mark = obj-&gt;mark();</span><br><span class="line">  assert(!mark-&gt;has_bias_pattern(), <span class="string">"should not see bias pattern here"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mark-&gt;is_neutral()) &#123;</span><br><span class="line">    <span class="comment">// Anticipate successful CAS -- the ST of the displaced mark must</span></span><br><span class="line">    <span class="comment">// be visible &lt;= the ST performed by the CAS.</span></span><br><span class="line">    lock-&gt;set_displaced_header(mark);</span><br><span class="line">    <span class="keyword">if</span> (mark == (markOop) Atomic::cmpxchg_ptr(lock, obj()-&gt;mark_addr(), mark)) &#123;</span><br><span class="line">      TEVENT (slow_enter: release stacklock) ;</span><br><span class="line">      <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Fall through to inflate() ...</span></span><br><span class="line">  &#125; <span class="keyword">else</span></span><br><span class="line">  <span class="keyword">if</span> (mark-&gt;has_locker() &amp;&amp; THREAD-&gt;is_lock_owned((address)mark-&gt;locker())) &#123;</span><br><span class="line">    assert(lock != mark-&gt;locker(), <span class="string">"must not re-lock the same lock"</span>);</span><br><span class="line">    assert(lock != (BasicLock*)obj-&gt;mark(), <span class="string">"don't relock with same BasicLock"</span>);</span><br><span class="line">    lock-&gt;set_displaced_header(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">  <span class="comment">// The following optimization isn't particularly useful.</span></span><br><span class="line">  <span class="keyword">if</span> (mark-&gt;has_monitor() &amp;&amp; mark-&gt;monitor()-&gt;is_entered(THREAD)) &#123;</span><br><span class="line">    lock-&gt;set_displaced_header (<span class="literal">NULL</span>) ;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// The object header will never be displaced to this lock,</span></span><br><span class="line">  <span class="comment">// so it does not matter what the value is, except that it</span></span><br><span class="line">  <span class="comment">// must be non-zero to avoid looking like a re-entrant lock,</span></span><br><span class="line">  <span class="comment">// and must not look locked either.</span></span><br><span class="line">  lock-&gt;set_displaced_header(markOopDesc::unused_mark());</span><br><span class="line">  ObjectSynchronizer::inflate(THREAD, obj())-&gt;enter(THREAD);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>inflate方法：膨胀为重量级锁</p><h2 id="锁升级过程"><a href="#锁升级过程" class="headerlink" title="锁升级过程"></a>锁升级过程</h2><h3 id="JDK8-markword实现表："><a href="#JDK8-markword实现表：" class="headerlink" title="JDK8 markword实现表："></a>JDK8 markword实现表：</h3><img src="https://gitee.com/dongzl/article-images/raw/master/2020/20-Mashibing-Synchronized-Volatile-CAS/Mashibing-Synchronized-Volatile-CAS-01.png"><p>new - 偏向锁 - 轻量级锁 （无锁, 自旋锁，自适应自旋）- 重量级锁</p><p>synchronized优化的过程和markword息息相关</p><p>用markword中最低的三位代表锁状态 其中1位是偏向锁位 两位是普通锁位</p><ol><li><p>Object o = new Object()<br>锁 = 0 01 无锁态<br>注意：如果偏向锁打开，默认是匿名偏向状态</p></li><li><p>o.hashCode()<br>001 + hashcode</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000001</span> <span class="number">10101101</span> <span class="number">00110100</span> <span class="number">00110110</span></span><br><span class="line"><span class="number">01011001</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br></pre></td></tr></table></figure><p>little endian big endian </p><p>00000000 00000000 00000000 01011001 00110110 00110100 10101101 00000000</p></li><li><p>默认synchronized(o)<br>00 -&gt; 轻量级锁<br>默认情况 偏向锁有个时延，默认是4秒<br>why? 因为JVM虚拟机自己有一些默认启动的线程，里面有好多sync代码，这些sync代码启动时就知道肯定会有竞争，如果使用偏向锁，就会造成偏向锁不断的进行锁撤销和锁升级的操作，效率较低。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:BiasedLockingStartupDelay=0</span><br></pre></td></tr></table></figure></li><li><p>如果设定上述参数<br>new Object () - &gt; 101 偏向锁 -&gt;线程ID为0 -&gt; Anonymous BiasedLock<br>打开偏向锁，new出来的对象，默认就是一个可偏向匿名对象101</p></li><li><p>如果有线程上锁<br>上偏向锁，指的就是，把markword的线程ID改为自己线程ID的过程<br>偏向锁不可重偏向 批量偏向 批量撤销</p></li><li><p>如果有线程竞争<br>撤销偏向锁，升级轻量级锁<br>线程在自己的线程栈生成LockRecord ，用CAS操作将markword设置为指向自己这个线程的LR的指针，设置成功者得到锁</p></li><li><p>如果竞争加剧<br>竞争加剧：有线程超过10次自旋， -XX:PreBlockSpin， 或者自旋线程数超过CPU核数的一半， 1.6之后，加入自适应自旋 Adapative Self Spinning ， JVM自己控制<br>升级重量级锁：-&gt; 向操作系统申请资源，linux mutex , CPU从3级-0级系统调用，线程挂起，进入等待队列，等待操作系统的调度，然后再映射回用户空间</p></li></ol><p>(以上实验环境是JDK11，打开就是偏向锁，而JDK8默认对象头是无锁)</p><p>偏向锁默认是打开的，但是有一个时延，如果要观察到偏向锁，应该设定参数</p><p><strong>如果计算过对象的hashCode，则对象无法进入偏向状态！</strong></p><blockquote><p>轻量级锁重量级锁的hashCode存在与什么地方？</p><p>答案：线程栈中，轻量级锁的LR中，或是代表重量级锁的ObjectMonitor的成员中</p></blockquote><p>关于epoch: (不重要)</p><blockquote><p><strong>批量重偏向与批量撤销</strong>渊源：从偏向锁的加锁解锁过程中可看出，当只有一个线程反复进入同步块时，偏向锁带来的性能开销基本可以忽略，但是当有其他线程尝试获得锁时，就需要等到safe point时，再将偏向锁撤销为无锁状态或升级为轻量级，会消耗一定的性能，所以在多线程竞争频繁的情况下，偏向锁不仅不能提高性能，还会导致性能下降。于是，就有了批量重偏向与批量撤销的机制。</p><p><strong>原理</strong>以class为单位，为每个class维护<strong>解决场景</strong>批量重偏向（bulk rebias）机制是为了解决：一个线程创建了大量对象并执行了初始的同步操作，后来另一个线程也来将这些对象作为锁对象进行操作，这样会导致大量的偏向锁撤销操作。批量撤销（bulk revoke）机制是为了解决：在明显多线程竞争剧烈的场景下使用偏向锁是不合适的。</p><p>一个偏向锁撤销计数器，每一次该class的对象发生偏向撤销操作时，该计数器+1，当这个值达到重偏向阈值（默认20）时，JVM就认为该class的偏向锁有问题，因此会进行批量重偏向。每个class对象会有一个对应的epoch字段，每个处于偏向锁状态对象的Mark Word中也有该字段，其初始值为创建该对象时class中的epoch的值。每次发生批量重偏向时，就将该值+1，同时遍历JVM中所有线程的栈，找到该class所有正处于加锁状态的偏向锁，将其epoch字段改为新值。下次获得锁时，发现当前对象的epoch值和class的epoch不相等，那就算当前已经偏向了其他线程，也不会执行撤销操作，而是直接通过CAS操作将其Mark Word的Thread Id 改成当前线程Id。当达到重偏向阈值后，假设该class计数器继续增长，当其达到批量撤销的阈值后（默认40），JVM就认为该class的使用场景存在多线程竞争，会标记该class为不可偏向，之后，对于该class的锁，直接走轻量级锁的逻辑。</p></blockquote><p>没错，我就是厕所所长</p><p>加锁，指的是锁定对象</p><p>锁升级的过程</p><p>JDK较早的版本 OS的资源 互斥量 用户态 -&gt; 内核态的转换 重量级 效率比较低</p><p>现代版本进行了优化</p><p>无锁 - 偏向锁 -轻量级锁（自旋锁）-重量级锁</p><p>偏向锁 - markword 上记录当前线程指针，下次同一个线程加锁的时候，不需要争用，只需要判断线程指针是否同一个，所以，偏向锁，偏向加锁的第一个线程 。hashCode备份在线程栈上 线程销毁，锁降级为无锁</p><p>有争用 - 锁升级为轻量级锁 - 每个线程有自己的LockRecord在自己的线程栈上，用CAS去争用markword的LR的指针，指针指向哪个线程的LR，哪个线程就拥有锁</p><p>自旋超过10次，升级为重量级锁 - 如果太多线程自旋 CPU消耗过大，不如升级为重量级锁，进入等待队列（不消耗CPU）-XX:PreBlockSpin</p><p>自旋锁在 JDK1.4.2 中引入，使用 -XX:+UseSpinning 来开启。JDK 6 中变为默认开启，并且引入了自适应的自旋锁（适应性自旋锁）。</p><p>自适应自旋锁意味着自旋的时间（次数）不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。如果对于某个锁，自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源。</p><p>偏向锁由于有锁撤销的过程revoke，会消耗系统资源，所以，在锁争用特别激烈的时候，用偏向锁未必效率高。还不如直接使用轻量级锁。</p><h3 id="synchronized最底层实现"><a href="#synchronized最底层实现" class="headerlink" title="synchronized最底层实现"></a>synchronized最底层实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">n</span><span class="params">()</span> </span>&#123; i++; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">publics <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">1000_000</span>; j++) &#123;</span><br><span class="line">            m();</span><br><span class="line">            n();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>java -XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly T</p><p>C1 Compile Level 1 (一级优化)</p><p>C2 Compile Level 2 (二级优化)</p><p>找到m() n()方法的汇编码，会看到 lock comxchg …..指令</p><h3 id="synchronized-vs-Lock-CAS"><a href="#synchronized-vs-Lock-CAS" class="headerlink" title="synchronized vs Lock (CAS)"></a>synchronized vs Lock (CAS)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">在高争用 高耗时的环境下synchronized效率更高</span><br><span class="line">在低争用 低耗时的环境下CAS效率更高</span><br><span class="line">synchronized到重量级之后是等待队列（不消耗CPU）</span><br><span class="line">CAS（等待期间消耗CPU）</span><br><span class="line"></span><br><span class="line">一切以实测为准</span><br></pre></td></tr></table></figure><h2 id="锁消除-lock-eliminate"><a href="#锁消除-lock-eliminate" class="headerlink" title="锁消除 lock eliminate"></a>锁消除 lock eliminate</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String str1,String str2)</span></span>&#123;</span><br><span class="line">         StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">         sb.append(str1).append(str2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们都知道 StringBuffer 是线程安全的，因为它的关键方法都是被 synchronized 修饰过的，但我们看上面这段代码，我们会发现，sb 这个引用只会在 add 方法中使用，不可能被其它线程引用（因为是局部变量，栈私有），因此 sb 是不可能共享的资源，JVM 会自动消除 StringBuffer 对象内部的锁。</p><h2 id="锁粗化-lock-coarsening"><a href="#锁粗化-lock-coarsening" class="headerlink" title="锁粗化 lock coarsening"></a>锁粗化 lock coarsening</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">       </span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer():</span><br><span class="line">    <span class="keyword">while</span>(i &lt; <span class="number">100</span>)&#123;</span><br><span class="line">        sb.append(str);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString():</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JVM 会检测到这样一连串的操作都对同一个对象加锁（while 循环内 100 次执行 append，没有锁粗化的就要进行 100  次加锁/解锁），此时 JVM 就会将加锁的范围粗化到这一连串的操作的外部（比如 while 虚幻体外），使得这一连串操作只需要加一次锁即可。</p><h2 id="锁降级（不重要）"><a href="#锁降级（不重要）" class="headerlink" title="锁降级（不重要）"></a>锁降级（不重要）</h2><p><a href="https://www.zhihu.com/question/63859501" target="_blank" rel="noopener">https://www.zhihu.com/question/63859501</a></p><p>其实，只被VMThread访问，降级也就没啥意义了。所以可以简单认为锁降级不存在！</p><h2 id="超线程"><a href="#超线程" class="headerlink" title="超线程"></a>超线程</h2><p>一个ALU + 两组Registers + PC</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://openjdk.java.net/groups/hotspot/docs/HotSpotGlossary.html" target="_blank" rel="noopener">http://openjdk.java.net/groups/hotspot/docs/HotSpotGlossary.html</a></p><h2 id="volatile的用途"><a href="#volatile的用途" class="headerlink" title="volatile的用途"></a>volatile的用途</h2><h3 id="1-线程可见性"><a href="#1-线程可见性" class="headerlink" title="1.线程可见性"></a>1.线程可见性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mashibing.testvolatile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T01_ThreadVisibility</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">                <span class="comment">//do sth</span></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"end"</span>);</span><br><span class="line">        &#125;, <span class="string">"server"</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        flag = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-防止指令重排序"><a href="#2-防止指令重排序" class="headerlink" title="2.防止指令重排序"></a>2.防止指令重排序</h3><h4 id="问题：DCL单例需不需要加volatile？"><a href="#问题：DCL单例需不需要加volatile？" class="headerlink" title="问题：DCL单例需不需要加volatile？"></a>问题：DCL单例需不需要加volatile？</h4><h4 id="CPU的基础知识"><a href="#CPU的基础知识" class="headerlink" title="CPU的基础知识"></a>CPU的基础知识</h4><ul><li><p>缓存行对齐<br>缓存行64个字节是CPU同步的基本单位，缓存行隔离会比伪共享效率要高<br>Disruptor</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mashibing.juc.c_028_FalseSharing;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T02_CacheLinePadding</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Padding</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">long</span> p1, p2, p3, p4, p5, p6, p7; <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> <span class="keyword">extends</span> <span class="title">Padding</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">long</span> x = <span class="number">0L</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> T[] arr = <span class="keyword">new</span> T[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        arr[<span class="number">0</span>] = <span class="keyword">new</span> T();</span><br><span class="line">        arr[<span class="number">1</span>] = <span class="keyword">new</span> T();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; <span class="number">1000_0000L</span>; i++) &#123;</span><br><span class="line">                arr[<span class="number">0</span>].x = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; <span class="number">1000_0000L</span>; i++) &#123;</span><br><span class="line">                arr[<span class="number">1</span>].x = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println((System.nanoTime() - start)/<span class="number">100_0000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MESI</p></li><li><p>伪共享</p></li><li><p>合并写<br>CPU内部的4个字节的Buffer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mashibing.juc.c_029_WriteCombining;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteCombining</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ITERATIONS = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ITEMS = <span class="number">1</span> &lt;&lt; <span class="number">24</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MASK = ITEMS - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] arrayA = <span class="keyword">new</span> <span class="keyword">byte</span>[ITEMS];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] arrayB = <span class="keyword">new</span> <span class="keyword">byte</span>[ITEMS];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] arrayC = <span class="keyword">new</span> <span class="keyword">byte</span>[ITEMS];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] arrayD = <span class="keyword">new</span> <span class="keyword">byte</span>[ITEMS];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] arrayE = <span class="keyword">new</span> <span class="keyword">byte</span>[ITEMS];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] arrayF = <span class="keyword">new</span> <span class="keyword">byte</span>[ITEMS];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++) &#123;</span><br><span class="line">            System.out.println(i + <span class="string">" SingleLoop duration (ns) = "</span> + runCaseOne());</span><br><span class="line">            System.out.println(i + <span class="string">" SplitLoop  duration (ns) = "</span> + runCaseTwo());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">runCaseOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">        <span class="keyword">int</span> i = ITERATIONS;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (--i != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> slot = i &amp; MASK;</span><br><span class="line">            <span class="keyword">byte</span> b = (<span class="keyword">byte</span>) i;</span><br><span class="line">            arrayA[slot] = b;</span><br><span class="line">            arrayB[slot] = b;</span><br><span class="line">            arrayC[slot] = b;</span><br><span class="line">            arrayD[slot] = b;</span><br><span class="line">            arrayE[slot] = b;</span><br><span class="line">            arrayF[slot] = b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> System.nanoTime() - start;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">runCaseTwo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">        <span class="keyword">int</span> i = ITERATIONS;</span><br><span class="line">        <span class="keyword">while</span> (--i != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> slot = i &amp; MASK;</span><br><span class="line">            <span class="keyword">byte</span> b = (<span class="keyword">byte</span>) i;</span><br><span class="line">            arrayA[slot] = b;</span><br><span class="line">            arrayB[slot] = b;</span><br><span class="line">            arrayC[slot] = b;</span><br><span class="line">        &#125;</span><br><span class="line">        i = ITERATIONS;</span><br><span class="line">        <span class="keyword">while</span> (--i != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> slot = i &amp; MASK;</span><br><span class="line">            <span class="keyword">byte</span> b = (<span class="keyword">byte</span>) i;</span><br><span class="line">            arrayD[slot] = b;</span><br><span class="line">            arrayE[slot] = b;</span><br><span class="line">            arrayF[slot] = b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> System.nanoTime() - start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>指令重排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mashibing.jvm.c3_jmm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T04_Disorder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">0</span>, b =<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            x = <span class="number">0</span>; y = <span class="number">0</span>;</span><br><span class="line">            a = <span class="number">0</span>; b = <span class="number">0</span>;</span><br><span class="line">            Thread one = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="comment">//由于线程one先启动，下面这句话让它等一等线程two. 读着可根据自己电脑的实际性能适当调整等待时间.</span></span><br><span class="line">                    <span class="comment">//shortWait(100000);</span></span><br><span class="line">                    a = <span class="number">1</span>;</span><br><span class="line">                    x = b;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            Thread other = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    b = <span class="number">1</span>;</span><br><span class="line">                    y = a;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            one.start();other.start();</span><br><span class="line">            one.join();other.join();</span><br><span class="line">            String result = <span class="string">"第"</span> + i + <span class="string">"次 ("</span> + x + <span class="string">","</span> + y + <span class="string">"）"</span>;</span><br><span class="line">            <span class="keyword">if</span>(x == <span class="number">0</span> &amp;&amp; y == <span class="number">0</span>) &#123;</span><br><span class="line">                System.err.println(result);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//System.out.println(result);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shortWait</span><span class="params">(<span class="keyword">long</span> interval)</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">        <span class="keyword">long</span> end;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            end = System.nanoTime();</span><br><span class="line">        &#125;<span class="keyword">while</span>(start + interval &gt;= end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="系统底层如何实现数据一致性"><a href="#系统底层如何实现数据一致性" class="headerlink" title="系统底层如何实现数据一致性"></a>系统底层如何实现数据一致性</h3><ol><li>MESI如果能解决，就使用MESI</li><li>如果不能，就锁总线</li></ol><h3 id="系统底层如何保证有序性"><a href="#系统底层如何保证有序性" class="headerlink" title="系统底层如何保证有序性"></a>系统底层如何保证有序性</h3><ol><li>内存屏障sfence mfence lfence等系统原语</li><li>锁总线</li></ol><h3 id="volatile如何解决指令重排序"><a href="#volatile如何解决指令重排序" class="headerlink" title="volatile如何解决指令重排序"></a>volatile如何解决指令重排序</h3><p>1: volatile i</p><p>2: ACC_VOLATILE</p><p>3: JVM的内存屏障</p><p>​    屏障两边的指令不可以重排！保障有序！</p><p>4：hotspot实现</p><p>bytecodeinterpreter.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> field_offset = cache-&gt;f2_as_index();</span><br><span class="line"><span class="keyword">if</span> (cache-&gt;is_volatile()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (support_IRIW_for_not_multiple_copy_atomic_cpu) &#123;</span><br><span class="line">        OrderAccess::fence();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>orderaccess_linux_x86.inline.hpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> OrderAccess::fence() &#123;</span><br><span class="line">  <span class="keyword">if</span> (os::is_MP()) &#123;</span><br><span class="line">    <span class="comment">// always use locked addl since mfence is sometimes expensive</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> AMD64</span></span><br><span class="line">    __<span class="function">asm__ <span class="title">volatile</span> <span class="params">(<span class="string">"lock; addl $0,0(%%rsp)"</span> : : : <span class="string">"cc"</span>, <span class="string">"memory"</span>)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    __<span class="function">asm__ <span class="title">volatile</span> <span class="params">(<span class="string">"lock; addl $0,0(%%esp)"</span> : : : <span class="string">"cc"</span>, <span class="string">"memory"</span>)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>用户空间锁 VS 重量级锁</p><ul><li>偏向锁、自旋锁都是用户空间完成；</li><li>重量级锁是需要向内核申请。</li></ul></li><li><p>为何会有偏向锁？</p><ul><li>多数 sychronized 方法，在很多情况下，只有一个线程在运行；</li><li>例如：StringBuffer 中的一些 sync 方法，Vector 中的一些 sync 方法；</li></ul></li><li><p>偏向锁的实现</p><ul><li>把自己的线程 ID 设置到 markword；</li></ul></li><li><p>自旋锁</p><ul><li>有人竞争（自旋锁，轻量级锁，无锁）；</li><li>每个线程在线程栈中生成 LockRecord，用 CAS 方式尝试把自己的指针更新到 markword；</li><li>每一次锁重入，都会有一个 LockRecord；</li></ul></li><li><p>偏向锁是否一定提高效率？</p><ul><li>不一定</li><li>在明确知道多个线程强烈竞争的时候，系统会把大量资源消耗在撤销上。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;面试题&quot;&gt;&lt;a href=&quot;#面试题&quot; class=&quot;headerlink&quot; title=&quot;面试题&quot;&gt;&lt;/a&gt;面试题&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;请描述 synchrnoized 和 ReentrantLock 的底层实现及重入的底层原理 – 百度、阿
      
    
    </summary>
    
    
      <category term="java开发" scheme="https://dongzl.github.io/categories/java%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="synchronized" scheme="https://dongzl.github.io/tags/synchronized/"/>
    
  </entry>
  
  <entry>
    <title>CountDownLatch 基于 AQS 共享锁模式实现原理分析</title>
    <link href="https://dongzl.github.io/2020/04/01/19-CountDownLatch-AQS-Share-Lock/"/>
    <id>https://dongzl.github.io/2020/04/01/19-CountDownLatch-AQS-Share-Lock/</id>
    <published>2020-04-01T13:34:19.000Z</published>
    <updated>2020-04-09T03:08:42.647Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景描述"><a href="#背景描述" class="headerlink" title="背景描述"></a>背景描述</h2><p><code>CountDownLatch</code> 是 <code>JDK</code> 中提供的一个非常有用的工具类，在实际的工作中也有很多应用场景，比如，在一段业务逻辑中可能要进行几个操作，这些操作彼此之间没有关联，这些操作在完成之后继续进行后续操作，如果采用串行的操作方式，业务逻辑执行时间也是累加关系；如果采用 <code>CountDownLatch</code> 工具类，可以开启多个线程并行执行这些操作，执行成功后调用 <code>countDown()</code> 减一，主线程调用 <code>await()</code> 进入等待状态，当子线程全部执行完毕，count 值减到 0 之后，唤醒主线程继续执行，这个时候代码执行时间就不是累加关系了，而是执行最慢操作执行时间，这就是 <code>CountDownLatch</code> 工具类的妙处。</p><blockquote><p>A synchronization aid that allows one or more threads to wait until a set of operations being performed in other threads completes.</p></blockquote><p>我们来看一下 JDK 注释中给出的 <code>CountDownLatch</code> 的使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Driver2</span> </span>&#123; <span class="comment">// ...</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        CountDownLatch doneSignal = <span class="keyword">new</span> CountDownLatch(N);</span><br><span class="line">        Executor e = ...</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;<span class="comment">// create and start threads</span></span><br><span class="line">            e.execute(<span class="keyword">new</span> WorkerRunnable(doneSignal, i));</span><br><span class="line">        &#125;</span><br><span class="line">        doneSignal.await();           <span class="comment">// wait for all to finish</span></span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WorkerRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch doneSignal;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> i;</span><br><span class="line">    WorkerRunnable(CountDownLatch doneSignal, <span class="keyword">int</span> i) &#123;</span><br><span class="line">        <span class="keyword">this</span>.doneSignal = doneSignal;</span><br><span class="line">        <span class="keyword">this</span>.i = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            doWork(i);</span><br><span class="line">            doneSignal.countDown();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;&#125; <span class="comment">// return;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们来分析一下 <code>CountDownLatch</code> 的实现原理，本文代码分析都是以 <code>JDK1.8</code> 源代码为基础进行分析。</p><h2 id="AQS-原理"><a href="#AQS-原理" class="headerlink" title="AQS 原理"></a>AQS 原理</h2><p><code>CountDownLatch</code> 的核心实现原理是基于 <code>AQS</code>，<code>AQS</code> 全称 <code>AbstractQueuedSynchronizer</code>，是 <code>java.util.concurrent</code> 中提供的一种高效且可扩展的同步机制；它是一种提供了原子式管理同步状态、阻塞和唤醒线程功能以及队列模型的简单框架。除了 <code>CountDownLatch</code> 工具类，JDK 当中的 <code>Semaphore</code>、<code>ReentrantLock</code> 等工具类都是基于 <code>AQS</code> 来实现的。下面我们用 <code>CountDownLatch</code> 来分析一下 <code>AQS</code> 的实现。</p><img src="https://gitee.com/dongzl/article-images/raw/master/2020/19-CountDownLatch-AQS-Share-Lock/CountDownLatch-AQS-Share-Lock-01.png"><img src="https://gitee.com/dongzl/article-images/raw/master/2020/19-CountDownLatch-AQS-Share-Lock/CountDownLatch-AQS-Share-Lock-02.png"><p>其实，如果我们阅读 <code>CountDownLatch</code> 的源码实现，发现其实它的代码实现非常简单，算上注释也才 300+ 行代码，如果去掉注释的话代码不到 100 行，大部分方法实现都是调用的 <code>Sync</code> 这个静态内部类的实现，而 <code>Sync</code> 就是继承自 <code>AbstractQueuedSynchronizer</code>。</p><p><code>Sync</code> 重写了 <code>AQS</code> 中的 <code>tryAcquireShared</code> 和 <code>tryReleaseShared</code> 两个方法。当调用 <code>CountDownLatch</code> 的 <code>awit()</code> 方法时，会调用内部类 <code>Sync</code> 的 <code>acquireSharedInterruptibly()</code> 方法，然后在这个方法中会调用 <code>tryAcquireShared</code> 方法，这个方法就是 <code>Sync</code> 重写的 <code>AQS</code> 中的方法；调用 <code>countDown()</code> 方法原理基本类似。</p><p>通过内部类继承的方式是我们使用 <code>AbstractQueuedSynchronizer</code> 的标准方式：</p><ul><li>内部持有继承自 <code>AbstractQueuedSynchronizer</code> 的对象 <code>Sync</code>；</li><li>在 <code>Sync</code> 内重写 <code>AbstractQueuedSynchronizer</code> 内部 <code>protected</code> 的部分或全部方法：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过需要重写的方法名称我们大致可以得知，<code>AQS</code> 中是分成两种模式的：独占模式和共享模式，其中 <code>CountDownLatch</code> 使用的是共享模式。</p><ul><li><p><code>tryAcquire</code> 和 <code>tryRelease</code> 是对应的，前者是独占模式获取，后者是独占模式释放；</p></li><li><p><code>tryAcquireShared</code> 和 <code>tryReleaseShared</code> 是对应的，前者是共享模式获取，后者是共享模式释放。</p></li></ul><h2 id="源码实现分析"><a href="#源码实现分析" class="headerlink" title="源码实现分析"></a>源码实现分析</h2><h3 id="构造方法实现"><a href="#构造方法实现" class="headerlink" title="构造方法实现"></a>构造方法实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CountDownLatch</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"count &lt; 0"</span>);</span><br><span class="line">    <span class="keyword">this</span>.sync = <span class="keyword">new</span> Sync(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CountDownLatch</code> 的构造方法中调用了 <code>Sync</code> 的构造方法，<code>Sync</code> 的构造方法调用了 <code>AQS</code> 类中的 <code>setState(count);</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Sync(<span class="keyword">int</span> count) &#123;</span><br><span class="line">    setState(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>state</code> 变量是 <code>AQS</code> 类中的一个 volatile 变量。在 <code>CountDownLatch</code> 中这个 <code>state</code> 值就是一个计数器，记录 <code>countDown</code> 是否已经减到 0。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The synchronization state.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br></pre></td></tr></table></figure><h3 id="await-方法实现"><a href="#await-方法实现" class="headerlink" title="await() 方法实现"></a>await() 方法实现</h3><p>在调用 <code>await()</code> 方法时，会直接调用 <code>AQS</code> 类的 <code>acquireSharedInterruptibly</code> 方法，在 <code>acquireSharedInterruptibly</code> 方法内部会继续调用 <code>Sync</code> 实现类中的 <code>tryAcquireShared</code> 方法，在 <code>tryAcquireShared</code> 方法中判断 <code>state</code> 变量值是否为 <code>0</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 <code>state</code> 值不等于 0，说明还有需要等待的线程在运行，则会执行 <code>doAcquireSharedInterruptibly()</code> 方法，执行该方法的第一个动作就是尝试加入等待队列，即调用 <code>addWaiter()</code> 方法，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Acquires in shared interruptible mode.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arg the acquire argument</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">//加入等待队列</span></span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//进入 CAS 循环</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">//当一个节点(关联一个线程)进入等待队列后， 获取此节点的 prev 节点 </span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">// 如果获取到的 prev 是 head，也就是队列中第一个等待线程</span></span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="comment">// 再次尝试申请 反应到 CountDownLatch 就是查看是否还有线程需要等待(state是否为0)</span></span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="comment">// 如果 r &gt;=0 说明 没有线程需要等待了 state==0</span></span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//尝试将第一个线程关联的节点设置为 head </span></span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//经过自旋tryAcquireShared后，state还不为0，就会到这里，第一次的时候，</span></span><br><span class="line">            <span class="comment">//waitStatus是0，那么node的waitStatus就会被置为SIGNAL，第二次再走到这里，</span></span><br><span class="line">            <span class="comment">//就会用LockSupport的park方法把当前线程阻塞住</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就是 <code>AQS</code> 的核心实现，<code>AQS</code> 用内部的一个 <code>Node</code> 类维护一个 <code>CHL Node FIFO</code> 队列。将当前线程加入等待队列，并通过 <code>parkAndCheckInterrupt()</code> 方法实现当前线程的阻塞。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">    <span class="comment">// 尝试快速入队操作，因为大多数时候尾节点不为 null</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果尾节点为空(也就是队列为空) 或者尝试CAS入队失败(由于并发原因)，进入enq方法</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>addWaiter()</code> 方法是向等待队列中添加等待者（waiter）。首先构造一个 <code>Node</code> 实体，参数为当前线程和一个 <code>Node</code> 对象（mode），这个 <code>mode</code> 有两种形式，一种是 <code>SHARED</code>，另一种是 <code>EXCLUSIVE</code>。接下来需要执行入队操作，<code>addWaiter()</code> 方法和 <code>enq()</code> 方法的 else 分支操作是一样的，这里的操作如果成功了，就不用再进到 <code>enq()</code> 方法的循环中去了，可以提高性能；如果没有成功，再调用 <code>enq()</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Inserts node into queue, initializing if necessary. See picture above.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node the node to insert</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> node's predecessor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 死循环 + CAS 保证所有节点都入队</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="comment">// 如果队列为空 设置一个空节点作为 head</span></span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 加入队尾</span></span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面操作就是 <code>AQS</code> 等待队列入队方法，操作在无限循环中进行，如果入队成功则返回新的队尾节点（<font color="red">enq 方法中返回的是 t，感觉不是新队尾节点呢，像是队尾的前一个节点呢，不过影响不大，在 addWaiter 方法中返回的 node 是新的队尾节点</font>），否则一直自旋，直到入队成功。假设入队的节点为 node ，上来直接进入循环，在循环中，先拿到尾节点。</p><ul><li><p>if 分支，如果尾节点为 null，说明现在队列中还没有等待线程，则尝试 CAS 操作将头节点初始化，然后将尾节点也设置为头节点，因为初始化的时候头尾是同一个，这和 AQS 的设计实现有关， AQS 默认要有一个虚拟节点。此时，尾节点不在为空，循环继续，进入 else 分支；</p></li><li><p>else 分支，如果尾节点不为 null，node.prev = t ，也就是将当前尾节点设置为待入队节点的前置节点。然后又是利用 CAS 操作，将待入队的节点设置为队列的尾节点，如果 CAS 返回 false，表示未设置成功，继续循环设置，直到设置成功，接着将之前的尾节点（也就是倒数第二个节点）的 next 属性设置为当前尾节点，对应 t.next = node 语句，然后返回当前尾节点，退出循环。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sets head of queue, and checks if successor may be waiting</span></span><br><span class="line"><span class="comment"> * in shared mode, if so propagating if either propagate &gt; 0 or</span></span><br><span class="line"><span class="comment"> * PROPAGATE status was set.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> propagate the return value from a tryAcquireShared</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 备份现在的 head</span></span><br><span class="line">    Node h = head; <span class="comment">// Record old head for check below</span></span><br><span class="line">    <span class="comment">// 抢到锁的线程被唤醒 将这个节点设置为head</span></span><br><span class="line">    setHead(node);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Try to signal next queued node if:</span></span><br><span class="line"><span class="comment">     *   Propagation was indicated by caller,</span></span><br><span class="line"><span class="comment">     *     or was recorded (as h.waitStatus either before</span></span><br><span class="line"><span class="comment">     *     or after setHead) by a previous operation</span></span><br><span class="line"><span class="comment">     *     (note: this uses sign-check of waitStatus because</span></span><br><span class="line"><span class="comment">     *      PROPAGATE status may transition to SIGNAL.)</span></span><br><span class="line"><span class="comment">     * and</span></span><br><span class="line"><span class="comment">     *   The next node is waiting in shared mode,</span></span><br><span class="line"><span class="comment">     *     or we don't know, because it appears null</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The conservatism in both of these checks may cause</span></span><br><span class="line"><span class="comment">     * unnecessary wake-ups, but only when there are multiple</span></span><br><span class="line"><span class="comment">     * racing acquires/releases, so most need signals now or soon</span></span><br><span class="line"><span class="comment">     * anyway.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// propagate 一般都会大于 0 或者存在可被唤醒的线程</span></span><br><span class="line">    <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">            (h = head) == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        Node s = node.next;</span><br><span class="line">        <span class="comment">// 只有一个节点 或者是共享模式，释放所有等待线程，各自尝试抢占锁</span></span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared())</span><br><span class="line">            doReleaseShared();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>setHeadAndPropagate</code> 方法负责将自旋等待或被 <code>LockSupport</code> 阻塞的线程唤醒。</p><p><code>Node</code> 对象中有一个属性是 <code>waitStatus</code>，它有四种状态，分别是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程已被 cancelled ，这种状态的节点将会被忽略，并移出队列</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 表示当前线程已被挂起，并且后继节点可以尝试抢占锁</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line"><span class="comment">//线程正在等待某些条件</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line"><span class="comment">//共享模式下 无条件所有等待线程尝试抢占锁</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br></pre></td></tr></table></figure><h3 id="countDown-方法"><a href="#countDown-方法" class="headerlink" title="countDown() 方法"></a>countDown() 方法</h3><p>当执行 <code>CountDownLatch</code> 的 <code>countDown()</code> 方法，将计数器减一，也就是将 <code>state</code> 值减一，当减到 0 的时候，等待队列中的线程被释放。是调用 <code>AQS</code> 的 <code>releaseShared()</code> 方法来实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CountDownLatch 类 countDown() 方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AQS 类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// arg 为固定值 1</span></span><br><span class="line">    <span class="comment">// 如果计数器state 为 0 返回true，前提是调用 countDown() 之前能已经为 0</span></span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        <span class="comment">// 唤醒等待队列的线程</span></span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CountDownLatch 类重写 AQS 方法</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Decrement count; signal when transition to zero</span></span><br><span class="line">    <span class="comment">// 依然是循环 + CAS 配合 实现计数器减 1</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> nextc = c-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">            <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AQS 类</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="comment">// 如果节点状态为 SIGNAL，则他的 next 节点也可以尝试被唤醒</span></span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将节点状态设置为 PROPAGATE，表示要向下传播，依次唤醒</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                        !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为这是共享型的，当计数器为 0 后，会唤醒等待队列里的所有线程，所有调用了 <code>await()</code> 方法的线程都被唤醒，并发执行。这种情况对应到的场景是，有多个线程需要等待一些动作完成，比如一个线程完成初始化动作，其他 5 个线程都需要用到初始化的结果，那么在初始化线程调用 <code>countDown()</code> 之前，其他 5 个线程都处在等待状态。一旦执行线程调用了 countDown 方法将计数器减到 0，等待的 5 个线程都被唤醒，开始执行。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p><code>AQS</code> 分为独占模式和共享模式，<code>CountDownLatch</code> 使用了它的共享模式；</p></li><li><p><code>AQS</code> 当第一个等待线程（被包装为 Node）要入队的时候，要保证存在一个 <code>head</code> 节点，这个 <code>head</code> 节点不关联线程，也就是一个虚节点；</p></li><li><p>当队列中的等待节点（关联线程的，非 <code>head</code> 节点）抢到锁，将这个节点设置为 <code>head</code> 节点；</p></li><li><p>第一次自旋抢锁失败后，<code>waitStatus</code> 会被设置为 -1（SIGNAL），第二次再失败，就会被 <code>LockSupport</code> 阻塞挂起；</p></li><li><p>如果一个节点的前置节点为 <code>SIGNAL</code> 状态，则这个节点可以尝试抢占锁。</p></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><p><a href="https://www.cnblogs.com/fengzheng/p/9153720.html" target="_blank" rel="noopener">Java多线程之—用 CountDownLatch 说明 AQS 的实现原理</a></p></li><li><p><a href="https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html" target="_blank" rel="noopener">从ReentrantLock的实现看AQS的原理及应用</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景描述&quot;&gt;&lt;a href=&quot;#背景描述&quot; class=&quot;headerlink&quot; title=&quot;背景描述&quot;&gt;&lt;/a&gt;背景描述&lt;/h2&gt;&lt;p&gt;&lt;code&gt;CountDownLatch&lt;/code&gt; 是 &lt;code&gt;JDK&lt;/code&gt; 中提供的一个非常有用的工具类，
      
    
    </summary>
    
    
      <category term="java开发" scheme="https://dongzl.github.io/categories/java%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="AQS" scheme="https://dongzl.github.io/tags/AQS/"/>
    
      <category term="CountDownLatch" scheme="https://dongzl.github.io/tags/CountDownLatch/"/>
    
  </entry>
  
  <entry>
    <title>Redis 面试常见问题知识点总结</title>
    <link href="https://dongzl.github.io/2020/03/22/18-Redis-Interview-knowledge/"/>
    <id>https://dongzl.github.io/2020/03/22/18-Redis-Interview-knowledge/</id>
    <published>2020-03-22T13:24:37.000Z</published>
    <updated>2020-05-08T10:42:47.624Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景描述"><a href="#背景描述" class="headerlink" title="背景描述"></a>背景描述</h2><p>在面试过程中，<code>缓存雪崩</code>、<code>缓存穿透</code>、<code>缓存击穿</code>、<code>分布式锁</code> 等问题是 Redis 的常见问题，本文根据 <a href="http://www.mashibing.com/" target="_blank" rel="noopener">马士兵教育</a> 公开课内容整理而成，主要总结了上述面试题一些回答思路。</p><h2 id="总结内容"><a href="#总结内容" class="headerlink" title="总结内容"></a>总结内容</h2><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>Redis 中的热点数据集中过期导致 MySQL 在某一时刻承受很大的压力，也有可能是因为 Redis 服务器宕机所致。</p><ul><li><p>数据集中过期：在数据过期时间后加上一个随机值，不要让数据同时过期；</p></li><li><p>Redis 宕机问题：a、设置多级缓存，b、搭建 Redis 集群，防止单点问题。</p></li></ul><img src="https://gitee.com/dongzl/article-images/raw/master/2020/18-Redis-Interview-knowledge/Redis-Interview-knowledge-01.jpg"><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>如果客户端发送的请求，查询的数据，在 Redis 中都查不到，那么缓存就失去意义了。这种情况多数是由恶意用户伪造请求参数，导致 Redis 缓存查不到数据而失效。</p><ul><li>BloomFilter（布隆过滤器）；</li><li>使用分布式锁解决缓存穿透，对于缓存中不存在的数据，在访问 MySQL 数据库时需要抢占分布式锁。</li></ul><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>Redis 中有一条热点数据，过期之后，MySQL 承接了大量的请求。</p><p>一般这种情况在实际工作中出现较少，很少会只有一条热点数据。</p><img src="https://gitee.com/dongzl/article-images/raw/master/2020/18-Redis-Interview-knowledge/Redis-Interview-knowledge-03.jpg"><h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><p>Redis 实现分布式锁的一些问题：</p><ul><li><p>死锁 –&gt; 有过期时间 –&gt; 乱入锁 –&gt; 增大有效期时间 –&gt; 效率低，吞吐量下降；</p></li><li><p>资源浪费。</p></li></ul><img src="https://gitee.com/dongzl/article-images/raw/master/2020/18-Redis-Interview-knowledge/Redis-Interview-knowledge-02.png"><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://juejin.im/post/5c9a67ac6fb9a070cb24bf34" target="_blank" rel="noopener">阿里一面：关于【缓存穿透、缓存击穿、缓存雪崩、热点数据失效】问题的解决方案</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景描述&quot;&gt;&lt;a href=&quot;#背景描述&quot; class=&quot;headerlink&quot; title=&quot;背景描述&quot;&gt;&lt;/a&gt;背景描述&lt;/h2&gt;&lt;p&gt;在面试过程中，&lt;code&gt;缓存雪崩&lt;/code&gt;、&lt;code&gt;缓存穿透&lt;/code&gt;、&lt;code&gt;缓存击穿&lt;/code&gt;、&lt;
      
    
    </summary>
    
    
      <category term="架构设计" scheme="https://dongzl.github.io/categories/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="Redis" scheme="https://dongzl.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>BloomFilter 实现原理及使用</title>
    <link href="https://dongzl.github.io/2020/03/21/17-Bloom-Filter-Summary/"/>
    <id>https://dongzl.github.io/2020/03/21/17-Bloom-Filter-Summary/</id>
    <published>2020-03-21T13:10:04.000Z</published>
    <updated>2020-05-29T09:22:13.120Z</updated>
    
    <content type="html"><![CDATA[<h2 id="布隆过滤器介绍"><a href="#布隆过滤器介绍" class="headerlink" title="布隆过滤器介绍"></a>布隆过滤器介绍</h2><p>布隆过滤器（Bloom Filter）由 <code>Burton Howard Bloom</code> 在 1970 年提出，是一种空间效率高的概率型数据结构。它专门用来检测集合中是否存在特定的元素。其实对于判断集合中是否存在某个元素，我们平时都会直接使用比较算法，例如：</p><ul><li>如果集合用线性表存储，查找的时间复杂度为 O(n)；</li><li>如果用平衡 BST（如 AVL树、红黑树）存储，时间复杂度为 O(logn)；</li><li>如果用哈希表存储，并用链地址法与平衡 BST 解决哈希冲突（参考 JDK8 的 HashMap 实现方法），时间复杂度也要有O[log(n/m)]，m 为哈希分桶数。</li></ul><img src="https://gitee.com/dongzl/article-images/raw/master/2020/17-Bloom-Filter-Summary/Bloom-Filter-Summary-01.png"><p>如果采用上面提到的一些方法，需要将实际数据都要存储到集合中，才能真正判断元素是否存在，会占用很大的内存空间，而且对于上面计算的时间复杂度，如果集合中元素非常多时，查找效率并不高。Bloom Filter 就是为了解决这些问题应运而生的。</p><h2 id="Bloom-Filter-设计思想"><a href="#Bloom-Filter-设计思想" class="headerlink" title="Bloom Filter 设计思想"></a>Bloom Filter 设计思想</h2><p>Bloom Filter 是由一个长度为 m 的比特位数组（bit array）与 k 个哈希函数（hash function）组成的数据结构。位数组均初始化为 0，所有哈希函数都可以分别把输入数据尽量均匀地散列。</p><p>当要插入一个元素时，将其数据分别输入 k 个哈希函数，产生 k 个哈希值。以哈希值作为位数组中的下标，将所有 k 个对应的比特置为 1。</p><p>当要查询（即判断是否存在）一个元素时，同样将其数据输入哈希函数，然后检查对应的 k 个比特。如果有任意一个比特为 0，表明该元素一定不在集合中。如果所有比特均为 1，表明该元素有（较大的）可能性在集合中。为什么不是一定在集合中呢？因为一个比特被置为 1 有可能会受到其他元素的影响，这就是所谓“假阳性”（false positive）。相对地，“假阴性”（false negative）在 Bloom Filter 中是绝不会出现的。</p><p>下图示出一个 m=18, k=3 的 Bloom Filter 示例。集合中的 x、y、z 三个元素通过 3 个不同的哈希函数散列到位数组中。当查询元素 w 时，因为有一个比特为0，因此 w 不在该集合中。</p><img src="https://gitee.com/dongzl/article-images/raw/master/2020/17-Bloom-Filter-Summary/Bloom-Filter-Summary-02.png"><h2 id="Bloom-Filter-的优缺点与用途"><a href="#Bloom-Filter-的优缺点与用途" class="headerlink" title="Bloom Filter 的优缺点与用途"></a>Bloom Filter 的优缺点与用途</h2><p><strong>优点：</strong></p><ul><li>不需要存储数据本身，只用比特表示，因此空间占用相对于传统方式有巨大的优势，并且能够保密数据；</li><li>时间效率也较高，插入和查询的时间复杂度均为O(k)；</li><li>哈希函数之间相互独立，可以在硬件指令层面并行计算。</li></ul><p><strong>缺点：</strong></p><ul><li>存在假阳性的概率，不适用于任何要求 100% 准确率的场景；</li><li>只能插入和查询元素，不能删除元素，这与产生假阳性的原因是相同的。我们可以简单地想到通过计数（即将一个比特扩展为计数值）来记录元素数，但仍然无法保证删除的元素一定在集合中。</li></ul><p>所以，Bloom Filter 在对查准度要求没有那么苛刻，而对时间、空间效率要求较高的场合非常合适，本文第一句话提到的用途即属于此类。另外，由于它不存在 <strong>假阴性</strong> 问题，所以用作“不存在”逻辑的处理时有奇效，比如可以用来作为 <strong>缓存系统（如Redis）的缓冲，防止缓存穿透</strong>。</p><h2 id="Google-Guava-中-Bloom-Filter-的使用"><a href="#Google-Guava-中-Bloom-Filter-的使用" class="headerlink" title="Google Guava 中 Bloom Filter 的使用"></a>Google Guava 中 Bloom Filter 的使用</h2><blockquote><p>A Bloom filter offers an approximate containment test with one-sided error: if it claims that an element is contained in it, this might be in error, but if it claims that an element is <i>not</i> contained in it, then this is definitely true.</p></blockquote><blockquote><p>Bloom filter 提供了一个单方面错误的近似包含测试：如果它声称某个元素包含在其中，则这可能是错误的（可能不包含在其中）；但是如果它声称某个元素不包含在其中，那这一定是正确的（一定不包含在其中）。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.common.hash.BloomFilter;</span><br><span class="line"><span class="keyword">import</span> com.google.common.hash.Funnels;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BloomFilterTest</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BloomFilter&lt;String&gt; filter = BloomFilter.create(Funnels.stringFunnel(Charset.forName(<span class="string">"utf-8"</span>)), <span class="number">1000</span>, <span class="number">0.000001</span>);</span><br><span class="line">        filter.put(<span class="string">"java"</span>);</span><br><span class="line">        filter.put(<span class="string">"c++"</span>);</span><br><span class="line">        filter.put(<span class="string">"python"</span>);</span><br><span class="line">        System.out.println(filter.mightContain(<span class="string">"php"</span>));</span><br><span class="line">        BloomFilter&lt;String&gt; filter2 = BloomFilter.create(Funnels.stringFunnel(Charset.forName(<span class="string">"utf-8"</span>)), <span class="number">1000</span>, <span class="number">0.000001</span>);</span><br><span class="line">        filter2.put(<span class="string">"go"</span>);</span><br><span class="line">        filter2.put(<span class="string">"rust"</span>);</span><br><span class="line">        filter2.put(<span class="string">"c"</span>);</span><br><span class="line">        filter2.putAll(filter);</span><br><span class="line">        System.out.println(filter2.mightContain(<span class="string">"java"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Redis-中-Bloom-Filter-的使用"><a href="#Redis-中-Bloom-Filter-的使用" class="headerlink" title="Redis 中 Bloom Filter 的使用"></a>Redis 中 Bloom Filter 的使用</h2><p>Redis 中使用 BloomFilter 需要安装 <a href="https://github.com/RedisBloom" target="_blank" rel="noopener">RedisBloom</a> 插件，下载源码编译后生成一个 <code>rebloom.so</code> 文件，然后需要在在 Redis 的配置文件 <code>redis.conf</code> 中加入该模块即可:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loadmodule /$&#123;path&#125;/rebloom.so</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bf.add test 1</span><br><span class="line">bf.add test 2</span><br><span class="line">bf.exists test 2</span><br><span class="line">bf.exists test 3</span><br></pre></td></tr></table></figure><p>关于 <code>RedisBloom</code> 的详细说明可以参考文档：<a href="https://oss.redislabs.com/redisbloom/" target="_blank" rel="noopener">RedisBloom - Probabilistic Datatypes Module for Redis</a></p><p>Redis BloomFilter 在 java 中的应用，可以使用 <code>jrebloom-${version}.jar</code> jar 包中提供的功能：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.redislabs<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jrebloom<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.rebloom.client.Client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisBloomFilterTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Client client = <span class="keyword">new</span> Client(<span class="string">"192.168.202.121"</span>, <span class="number">6395</span>);</span><br><span class="line">        client.add(<span class="string">"test"</span>, <span class="string">"1"</span>);</span><br><span class="line">        client.add(<span class="string">"test"</span>, <span class="string">"2"</span>);</span><br><span class="line">        System.out.println(client.exists(<span class="string">"test"</span>, <span class="string">"2"</span>));</span><br><span class="line">        System.out.println(client.exists(<span class="string">"test"</span>, <span class="string">"3"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="row">    <embed src="https://gitee.com/dongzl/article-images/raw/master/2020/17-Bloom-Filter-Summary/Bloom-Filter-Summary-03.pdf" width="100%" height="550" type="application/pdf"></div><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://llimllib.github.io/bloomfilter-tutorial/" target="_blank" rel="noopener">Bloom Filters by Example</a></li><li><a href="https://www.jianshu.com/p/bef2ec1c361f" target="_blank" rel="noopener">布隆过滤器（Bloom Filter）原理及 Guava 中的具体实现</a></li><li><a href="https://oss.redislabs.com/redisbloom/" target="_blank" rel="noopener">RedisBloom - Probabilistic Datatypes Module for Redis</a></li><li><a href="https://www.cnblogs.com/heihaozi/p/12174478.html" target="_blank" rel="noopener">详细解析Redis中的布隆过滤器及其应用</a></li><li><a href="https://baijiahao.baidu.com/s?id=1655304940308056733&wfr=spider&for=pc" target="_blank" rel="noopener">帮你解读什么是Redis缓存穿透和缓存雪崩（包含解决方案）</a></li><li><a href="https://blog.csdn.net/ChenMMo/article/details/93615438" target="_blank" rel="noopener">Redis安装布隆过滤器插件 bloomfilter</a></li><li><a href="https://juejin.im/post/5e9c110151882573793e8940" target="_blank" rel="noopener">通俗易懂讲布隆过滤器</a></li><li><a href="https://mp.weixin.qq.com/s/Y7OJ0ntjU0pumWuwFoY8mQ" target="_blank" rel="noopener">布隆过滤器究竟是什么，这篇讲的明明白白的！</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;布隆过滤器介绍&quot;&gt;&lt;a href=&quot;#布隆过滤器介绍&quot; class=&quot;headerlink&quot; title=&quot;布隆过滤器介绍&quot;&gt;&lt;/a&gt;布隆过滤器介绍&lt;/h2&gt;&lt;p&gt;布隆过滤器（Bloom Filter）由 &lt;code&gt;Burton Howard Bloom&lt;/co
      
    
    </summary>
    
    
      <category term="架构设计" scheme="https://dongzl.github.io/categories/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="BloomFilter" scheme="https://dongzl.github.io/tags/BloomFilter/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 数据库 Lock 知识总结</title>
    <link href="https://dongzl.github.io/2020/03/19/16-MySQL-Lock-Summary/"/>
    <id>https://dongzl.github.io/2020/03/19/16-MySQL-Lock-Summary/</id>
    <published>2020-03-19T14:13:22.000Z</published>
    <updated>2020-05-22T07:49:37.891Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MySQL-中锁的基本知识"><a href="#MySQL-中锁的基本知识" class="headerlink" title="MySQL 中锁的基本知识"></a>MySQL 中锁的基本知识</h2><p><strong>锁是计算机协调多个进程或线程并发访问某一资源的机制。</strong> 在数据库中，除传统的计算资源（如 CPU、RAM、I/O 等）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。</p><p>​相对其他数据库而言，MySQL 的锁机制比较简单，其最显著的特点是不同的 <strong>存储引擎</strong> 支持不同的锁机制。比如，MyISAM 和 MEMORY 存储引擎采用的是表级锁（table-level locking）；InnoDB 存储引擎既支持行级锁（row-level locking），也支持表级锁，但默认情况下是采用行级锁。</p><ul><li><p><strong>表级锁</strong>：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低； </p></li><li><p><strong>行级锁</strong>：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。  </p></li></ul><p>​从上述特点可见，很难笼统地说哪种锁更好，只能就具体应用的特点来说哪种锁更合适。仅从锁的角度来说：<strong>表级锁</strong>更适合于以查询为主，只有少量按索引条件更新数据的应用，如Web应用；而<strong>行级锁</strong>则更适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用，如一些在线事务处理（OLTP）系统。 </p><h2 id="MySQL-中锁的分类"><a href="#MySQL-中锁的分类" class="headerlink" title="MySQL 中锁的分类"></a>MySQL 中锁的分类</h2><ul><li><p>共享锁：Shared Locks（简称 S 锁，属于行锁）</p></li><li><p>排他锁：Exclusive Locks（简称 X 锁，属于行锁）</p></li><li><p>意向共享锁：Intention Shared Locks（简称 IS 锁，属于表锁）</p></li><li><p>意向排他锁：Intention Exclusive Locks（简称 IX 锁，属于表锁）</p></li><li><p>自增锁 AUTO-INC Locks</p></li></ul><h3 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h3><p>共享锁就是多个事务对于同一数据可以共享一把锁，都能访问到数据库，但是只能读不能修改；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#事务A：</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span> <span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share</span> <span class="keyword">mode</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#事务B:</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span>; <span class="comment">--(读取数据没问题)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#事务B:</span></span><br><span class="line"><span class="keyword">update</span> student <span class="keyword">set</span> <span class="keyword">name</span>=<span class="string">'hehe'</span> <span class="keyword">where</span> <span class="keyword">id</span>  =<span class="number">1</span>;</span><br><span class="line"><span class="comment">--注意：无法修改会卡死，当事务A提交事务之后，会立刻修改成功</span></span><br></pre></td></tr></table></figure><h3 id="排他锁"><a href="#排他锁" class="headerlink" title="排他锁"></a>排他锁</h3><p>排它锁不能与其他锁并存，如一个事务获取了一个数据行的排它锁，其他事务就不能再获取改行的锁，只有当前获取了排它锁的事务可以对数据进行读取和修改。<code>delete、update、insert</code> 默认是排他锁：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#事务A:</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#事务B:</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span> <span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share</span> <span class="keyword">mode</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 注意：事务B操作的时候回卡死，提交事务立马成功。</span></span><br></pre></td></tr></table></figure><h3 id="意向共享锁和意向排他锁"><a href="#意向共享锁和意向排他锁" class="headerlink" title="意向共享锁和意向排他锁"></a>意向共享锁和意向排他锁</h3><ul><li><p>意向共享锁：表示事务准备给数据行加入共享锁，也就是说一个数据行在加共享锁之前必须先取得该表的 IS 锁;</p></li><li><p>意向排他锁：表示事务准备给数据行加入排它锁，也就是说一个数据行加排它锁之前必须先取得该表的 IX 锁。</p></li></ul><p><strong>PS. 意向锁是InnoDB数据操作之前自动加的，不需要用户干预。</strong></p><h3 id="自增锁"><a href="#自增锁" class="headerlink" title="自增锁"></a>自增锁</h3><p>针对自增列自增长的一个特殊的表级别锁</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">VARIABLES</span> <span class="keyword">LIKE</span> <span class="string">'innodb_autoinc_lock_mode'</span>;</span><br><span class="line"><span class="comment">--默认值1 代表连续，事务未提交则id永久丢失</span></span><br></pre></td></tr></table></figure><h2 id="MyISAM-表锁"><a href="#MyISAM-表锁" class="headerlink" title="MyISAM 表锁"></a>MyISAM 表锁</h2><p>MySQL 的表级锁有两种模式：<strong>表共享读锁（Table Read Lock）</strong>和<strong>表独占写锁（Table Write Lock）</strong>。  </p><p>对 MyISAM 表的读操作，不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写请求；对 MyISAM 表的写操作，则会阻塞其他用户对同一表的读和写操作；MyISAM 表的读操作与写操作之间，以及写操作之间是串行的！ </p><p>建表语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`mylock`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`NAME`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=MyISAM <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`mylock`</span> (<span class="string">`id`</span>, <span class="string">`NAME`</span>) <span class="keyword">VALUES</span> (<span class="string">'1'</span>, <span class="string">'a'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`mylock`</span> (<span class="string">`id`</span>, <span class="string">`NAME`</span>) <span class="keyword">VALUES</span> (<span class="string">'2'</span>, <span class="string">'b'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`mylock`</span> (<span class="string">`id`</span>, <span class="string">`NAME`</span>) <span class="keyword">VALUES</span> (<span class="string">'3'</span>, <span class="string">'c'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`mylock`</span> (<span class="string">`id`</span>, <span class="string">`NAME`</span>) <span class="keyword">VALUES</span> (<span class="string">'4'</span>, <span class="string">'d'</span>);</span><br></pre></td></tr></table></figure><p><strong>MyISAM写锁阻塞读的案例：</strong></p><p>​当一个线程获得对一个表的写锁之后，只有持有锁的线程可以对表进行更新操作。其他线程的读写操作都会等待，直到锁释放为止。</p><table><thead><tr><th align="center">session1</th><th align="center">session2</th></tr></thead><tbody><tr><td align="center">获取表的write锁定<br>lock table mylock write;</td><td align="center"></td></tr><tr><td align="center">当前session对表的查询，插入，更新操作都可以执行<br>select * from mylock;<br>insert into mylock values(5,’e’);</td><td align="center">当前session对表的查询会被阻塞<br>select * from mylock；</td></tr><tr><td align="center">释放锁：<br>unlock tables；</td><td align="center">当前session能够立刻执行，并返回对应结果</td></tr></tbody></table><p><strong>MyISAM读阻塞写的案例：</strong></p><p>一个 session 使用 <code>lock table</code> 给表加读锁，这个 session 可以锁定表中的记录，但更新和访问其他表都会提示错误，同时，另一个 session 可以查询表中的记录，但更新就会出现锁等待。</p><table><thead><tr><th align="center">session1</th><th align="center">session2</th></tr></thead><tbody><tr><td align="center">获得表的read锁定<br>lock table mylock read;</td><td align="center"></td></tr><tr><td align="center">当前session可以查询该表记录：<br>select * from mylock;</td><td align="center">当前session可以查询该表记录：<br>select * from mylock;</td></tr><tr><td align="center">当前session不能查询没有锁定的表<br>select * from person;<br>Table ‘person’ was not locked with LOCK TABLES</td><td align="center">当前session可以查询或者更新未锁定的表<br>select * from person;<br>insert into person values(1,’zhangsan’);</td></tr><tr><td align="center">当前session插入或者更新表会提示错误<br>insert into mylock values(6,’f’);<br>Table ‘mylock’ was locked with a READ lock and can’t be updated<br>update mylock set name=’aa’ where id = 1;<br>Table ‘mylock’ was locked with a READ lock and can’t be updated</td><td align="center">当前session插入数据会等待获得锁<br>insert into mylock values(6,’f’);</td></tr><tr><td align="center">释放锁<br>unlock tables;</td><td align="center">获得锁，更新成功</td></tr></tbody></table><p><strong>注意：MyISAM 在执行查询语句之前，会自动给涉及的所有表加读锁，在执行更新操作前，会自动给涉及的表加写锁，这个过程并不需要用户干预，因此用户一般不需要使用命令来显式加锁，上例中的加锁时为了演示效果。</strong></p><p><strong>MyISAM 的并发插入问题：</strong></p><p>MyISAM 表的读和写是串行的，这是就总体而言的，在一定条件下，MyISAM 也支持查询和插入操作的并发执行</p><table><thead><tr><th align="center">session1</th><th align="center">session2</th></tr></thead><tbody><tr><td align="center">获取表的read local锁定<br>lock table mylock read local;</td><td align="center"></td></tr><tr><td align="center">当前session不能对表进行更新或者插入操作<br>insert into mylock values(6,’f’);<br>Table ‘mylock’ was locked with a READ lock and can’t be updated<br>update mylock set name=’aa’ where id = 1;<br>Table ‘mylock’ was locked with a READ lock and can’t be updated</td><td align="center">其他session可以查询该表的记录<br>select* from mylock</td></tr><tr><td align="center">当前session不能查询没有锁定的表<br>select * from person;<br>Table ‘person’ was not locked with LOCK TABLES</td><td align="center">其他session可以进行<font color="red">插入</font>操作，但是<font color="red">更新</font>会阻塞<br>update mylock set name = ‘aa’ where id = 1;</td></tr><tr><td align="center">当前session不能访问其他session插入的记录；</td><td align="center"></td></tr><tr><td align="center">释放锁资源：unlock tables;</td><td align="center">当前session获取锁，更新操作完成</td></tr><tr><td align="center">当前session可以查看其他session插入的记录</td><td align="center"></td></tr></tbody></table><p> 可以通过检查 <code>table_locks_waited</code> 和 <code>table_locks_immediate</code>状态变量来分析系统上的表锁定争夺：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show status like 'table%';</span><br><span class="line">+<span class="comment">-----------------------+-------+</span></span><br><span class="line">| Variable_name         | Value |</span><br><span class="line">+<span class="comment">-----------------------+-------+</span></span><br><span class="line">| Table_locks_immediate | 352   |</span><br><span class="line">| Table_locks_waited    | 2     |</span><br><span class="line">+<span class="comment">-----------------------+-------+</span></span><br><span class="line"><span class="comment">--如果 Table_locks_waited 的值比较高，则说明存在着较严重的表级锁争用情况。</span></span><br></pre></td></tr></table></figure><h2 id="InnoDB锁"><a href="#InnoDB锁" class="headerlink" title="InnoDB锁"></a>InnoDB锁</h2><p>可以通过检查 <code>Innodb_row_lock</code> 状态变量来分析系统上的行锁的争夺情况：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show status like 'innodb_row_lock%';</span><br><span class="line">+<span class="comment">-------------------------------+-------+</span></span><br><span class="line">| Variable_name                 | Value |</span><br><span class="line">+<span class="comment">-------------------------------+-------+</span></span><br><span class="line">| Innodb_row_lock_current_waits | 0     |</span><br><span class="line">| Innodb_row_lock_time          | 18702 |</span><br><span class="line">| Innodb_row_lock_time_avg      | 18702 |</span><br><span class="line">| Innodb_row_lock_time_max      | 18702 |</span><br><span class="line">| Innodb_row_lock_waits         | 1     |</span><br><span class="line">+<span class="comment">-------------------------------+-------+</span></span><br><span class="line"><span class="comment">--如果发现锁争用比较严重，如InnoDB_row_lock_waits和InnoDB_row_lock_time_avg的值比较高</span></span><br></pre></td></tr></table></figure><p><strong>InnoDB的行锁模式及加锁方法</strong>：</p><ul><li><strong>共享锁（s）</strong>：又称读锁。允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。若事务 T 对数据对象 A 加上 S 锁，则事务 T 可以读 A 但不能修改 A，其他事务只能再对 A 加 S 锁，而不能加 X 锁，直到 T 释放 A 上的 S 锁，这保证了其他事务可以读 A，但在 T 释放 A 上的 S 锁之前不能对 A 做任何修改；<br>​</li><li><strong>排他锁（x）</strong>：又称写锁。允许获取排他锁的事务更新数据，阻止其他事务取得相同的数据集共享读锁和排他写锁。若事务 T 对数据对象 A 加上 X 锁，事务 T 可以读 A 也可以修改 A，其他事务不能再对 A 加任何锁，直到 T 释放 A 上的锁。</li></ul><p>​MySQL InnoDB引 擎默认的修改数据语句：<strong>update, delete, insert都会自动给涉及到的数据加上排他锁，select 语句默认不会加任何锁类型</strong>，如果加排他锁可以使用 <code>select …for update</code> 语句，加共享锁可以使用 <code>select … lock in share mode</code> 语句。<strong>所以加过排他锁的数据行在其他事务种是不能修改数据的，也不能通过for update和lock in share mode锁的方式查询数据，但可以直接通过select …from…查询数据，因为普通查询没有任何锁机制。</strong> </p><p><strong>InnoDB行锁实现方式</strong>：</p><p>InnoDB 行锁是通过给<strong>索引</strong>上的索引项加锁来实现的，这一点 MySQL 与 Oracle 不同，后者是通过在数据块中对相应数据行加锁来实现的。InnoDB 这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB 才使用行级锁，<strong>否则，InnoDB将使用表锁！</strong>  </p><ul><li>在不通过索引条件查询的时候，InnoDB 使用的是表锁而不是行锁</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tab_no_index(<span class="keyword">id</span> <span class="built_in">int</span>,<span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">10</span>)) <span class="keyword">engine</span>=<span class="keyword">innodb</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tab_no_index <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'1'</span>),(<span class="number">2</span>,<span class="string">'2'</span>),(<span class="number">3</span>,<span class="string">'3'</span>),(<span class="number">4</span>,<span class="string">'4'</span>);</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">session1</th><th align="center">session2</th></tr></thead><tbody><tr><td align="center">set autocommit = 0;<br>select * from tab_no_index where id = 1;</td><td align="center">set autocommit = 0;<br>select * from tab_no_index where id = 2;</td></tr><tr><td align="center">select * from tab_no_index where id = 1 for update;</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">select * from tab_no_index where id = 2 for update;</td></tr></tbody></table><p>session1 只给一行加了排他锁，但是 session2 在请求其他行的排他锁的时候，会出现锁等待。原因是在没有索引的情况下，InnoDB 只能使用表锁。</p><ul><li>创建带索引的表进行条件查询，InnoDB 使用的是行锁</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tab_with_index(<span class="keyword">id</span> <span class="built_in">int</span>,<span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">10</span>)) <span class="keyword">engine</span>=<span class="keyword">innodb</span>;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tab_with_index <span class="keyword">add</span> <span class="keyword">index</span> <span class="keyword">id</span>(<span class="keyword">id</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tab_with_index <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'1'</span>),(<span class="number">2</span>,<span class="string">'2'</span>),(<span class="number">3</span>,<span class="string">'3'</span>),(<span class="number">4</span>,<span class="string">'4'</span>);</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">session1</th><th align="center">session2</th></tr></thead><tbody><tr><td align="center">set autocommit = 0;<br>select * from tab_with_indexwhere id = 1;</td><td align="center">set autocommit = 0;<br>select * from tab_with_indexwhere id =2;</td></tr><tr><td align="center">select * from tab_with_indexwhere id = 1 for update;</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">select * from tab_with_indexwhere id = 2 for update;</td></tr></tbody></table><ul><li>由于 MySQL 的行锁是针对索引加的锁，不是针对记录加的锁，所以虽然是访问不同行的记录，但是依然无法访问到具体的数据</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tab_with_index <span class="keyword">drop</span> <span class="keyword">index</span> <span class="keyword">id</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tab_with_index  <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'4'</span>);</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">session1</th><th align="center">session2</th></tr></thead><tbody><tr><td align="center">set autocommit = 0;</td><td align="center">set autocommit = 0;</td></tr><tr><td align="center">select * from tab_with_index where id = 1 and name=’1’ for update;</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">select * from tab_with_index where id = 1 and name=’4’ for update;<br>虽然 session2 访问的是和 session1 不同的记录，但是锁的是具体的表，所以需要等待锁</td></tr></tbody></table><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>对于MyISAM的表锁，主要讨论了以下几点：</strong> </p><ul><li><p>共享读锁（S）之间是兼容的，但共享读锁（S）与排他写锁（X）之间，以及排他写锁（X）之间是互斥的，也就是说读和写是串行的；  </p></li><li><p>在一定条件下，MyISAM 允许查询和插入并发执行，我们可以利用这一点来解决应用中对同一表查询和插入的锁争用问题；</p></li><li><p>MyISAM 默认的锁调度机制是写优先，这并不一定适合所有应用，用户可以通过设置 <code>LOW_PRIORITY_UPDATES</code> 参数，或在 <code>INSERT、UPDATE、DELETE</code> 语句中指定 <code>LOW_PRIORITY</code> 选项来调节读写锁的争用。 </p></li><li><p>由于表锁的锁定粒度大，读写之间又是串行的，因此，如果更新操作较多，MyISAM 表可能会出现严重的锁等待，可以考虑采用 InnoDB 引擎来减少锁冲突。</p></li></ul><p><strong>对于InnoDB表，本文主要讨论了以下几项内容：</strong> </p><ul><li>InnoDB 的行锁是基于索引实现的，如果不通过索引访问数据，InnoDB 会使用表锁；</li><li>在不同的隔离级别下，InnoDB 的锁机制和一致性读策略不同；</li></ul><p>在了解 InnoDB 锁特性后，用户可以通过设计和 SQL 调整等措施减少锁冲突和死锁，包括：</p><ul><li><p>尽量使用较低的隔离级别；精心设计索引，并尽量使用索引访问数据，使加锁更精确，从而减少锁冲突的机会；</p></li><li><p>选择合理的事务大小，小事务发生锁冲突的几率也更小；</p></li><li><p>给记录集显式加锁时，最好一次性请求足够级别的锁。比如要修改数据的话，最好直接申请排他锁，而不是先申请共享锁，修改时再请求排他锁，这样容易产生死锁；</p></li><li><p>不同的程序访问一组表时，应尽量约定以相同的顺序访问各表，对一个表而言，尽可能以固定的顺序存取表中的行。这样可以大大减少死锁的机会；</p></li><li><p>尽量用相等条件访问数据，这样可以避免间隙锁对并发插入的影响；不要申请超过实际需要的锁级别；除非必须，查询时不要显示加锁；</p></li><li><p>对于一些特定的事务，可以使用表锁来提高处理速度或减少死锁的可能。</p></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://tech.meituan.com/2014/08/20/innodb-lock.html" target="_blank" rel="noopener">Innodb中的事务隔离级别和锁的关系</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;MySQL-中锁的基本知识&quot;&gt;&lt;a href=&quot;#MySQL-中锁的基本知识&quot; class=&quot;headerlink&quot; title=&quot;MySQL 中锁的基本知识&quot;&gt;&lt;/a&gt;MySQL 中锁的基本知识&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;锁是计算机协调多个进程或线程并发访问
      
    
    </summary>
    
    
      <category term="数据库" scheme="https://dongzl.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MySQL" scheme="https://dongzl.github.io/tags/MySQL/"/>
    
      <category term="Lock" scheme="https://dongzl.github.io/tags/Lock/"/>
    
  </entry>
  
  <entry>
    <title>JDK ThreadPoolExecutor 源码解析</title>
    <link href="https://dongzl.github.io/2020/03/18/15-ThreadPoolExecutor-Source-Code/"/>
    <id>https://dongzl.github.io/2020/03/18/15-ThreadPoolExecutor-Source-Code/</id>
    <published>2020-03-18T14:02:59.000Z</published>
    <updated>2020-05-07T10:08:45.366Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>学习 Java 的多线程知识就绕不开线程池，提起线程池那就必然要说到 ThreadPoolExecutor 类，自从 <code>阿里巴巴编码规范</code> 问世以来，ThreadPoolExecutor 可能也跟着火了一把，现在随便问个 Java 开发的基本都能背出来<code>线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险</code>。</p><p>笔者所参与的项目中很多地方都使用了线程池的 ThreadPoolExecutor 类去自定义线程池的一些参数。当然凡事没有绝对，使用 Executors 去创建线程池也是有的，如果只是开启数量可控的很少的线程去执行任务，也没必要大动干戈。</p><p><strong>为什么需要线程池</strong>：<br>在实际使用中，线程是很占用系统资源的，如果对线程管理不善，很容易导致系统问题。因此，在大多数并发框架中都会使用线程池来管理线程，使用线程池管理线程主要有如下好处:</p><ul><li>使用线程池可以重复利用已有的线程继续执行任务，避免线程在创建和销毁时造成的消耗；</li><li>由于没有线程创建和销毁时的消耗，可以提高系统响应速度；</li><li>通过线程可以对线程进行合理的管理，根据系统的承受能力调整可运行线程数量的大小等。</li></ul><h2 id="线程池工作原理"><a href="#线程池工作原理" class="headerlink" title="线程池工作原理"></a>线程池工作原理</h2><img src="https://gitee.com/dongzl/article-images/raw/master/2020/15-ThreadPoolExecutor-Source-Code/ThreadPoolExecutor-Source-Code-04.png"><p>线程池执行所提交的任务过程: </p><ul><li>先判断线程池中核心线程池所有的线程是否都在执行任务。如果不是，则新创建一个线程执行刚提交的任务，否则，核心线程池中所有的线程都在执行任务，则进入第2步;</li><li>判断当前阻塞队列是否已满，如果未满，则将提交的任务放置在阻塞队列中；否则，则进入第3步；</li><li>判断线程池中所有的线程是否都在执行任务，如果没有，则创建一个新的线程来执行任务，否则，则交给饱和策略进行处理。</li></ul><img src="https://gitee.com/dongzl/article-images/raw/master/2020/15-ThreadPoolExecutor-Source-Code/ThreadPoolExecutor-Source-Code-05.png"><h2 id="JDK-自带线程池实现"><a href="#JDK-自带线程池实现" class="headerlink" title="JDK 自带线程池实现"></a>JDK 自带线程池实现</h2><img src="https://gitee.com/dongzl/article-images/raw/master/2020/15-ThreadPoolExecutor-Source-Code/ThreadPoolExecutor-Source-Code-01.png"><table><thead><tr><th>线程池</th><th>corePoolSize</th><th>maximumPoolSize</th><th>keepAliveTime</th><th>unit</th><th>workQueue</th><th>threadFactory</th><th>handler</th></tr></thead><tbody><tr><td>newCachedThreadPool</td><td>0</td><td>Integer.MAX_VALUE</td><td>60</td><td>TimeUnit.SECONDS</td><td>SynchronousQueue</td><td>DefaultThreadFactory</td><td>AbortPolicy</td></tr><tr><td>newFixedThreadPool</td><td>nThreads</td><td>nThreads</td><td>0</td><td>TimeUnit.MILLISECONDS</td><td>LinkedBlockingQueue</td><td>DefaultThreadFactory</td><td>AbortPolicy</td></tr><tr><td>newSingleThreadExecutor</td><td>1</td><td>1</td><td>0</td><td>TimeUnit.MILLISECONDS</td><td>LinkedBlockingQueue</td><td>DefaultThreadFactory</td><td>AbortPolicy</td></tr><tr><td>newSingleThreadScheduledExecutor</td><td>1</td><td>Integer.MAX_VALUE</td><td>0</td><td>TimeUnit.NANOSECONDS</td><td>DelayedWorkQueue</td><td>DefaultThreadFactory</td><td>AbortPolicy</td></tr><tr><td>newSingleThreadScheduledExecutor</td><td>corePoolSize</td><td>Integer.MAX_VALUE</td><td>0</td><td>TimeUnit.NANOSECONDS</td><td>DelayedWorkQueue</td><td>DefaultThreadFactory</td><td>AbortPolicy</td></tr><tr><td>newWorkStealingPool</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr></tbody></table><p>补充： </p><ul><li><p>各种线程池实现中 threadFactory 参数可以自定义，也可以使用使用 JDK 默认 <code>DefaultThreadFactory</code> 实现类。</p></li><li><p><code>newWorkStealingPool</code> 属于 <code>ForkJoinPool</code> 线程池框架内容，实现上比较特殊。</p></li></ul><p>参数说明</p><ul><li>corePoolSize：核心线程池的大小。</li><li>maximumPoolSize：线程池能创建线程的最大个数</li><li>keepAliveTime：空闲线程存活时间</li><li>unit：时间单位，为keepAlive Time指定时间单位</li><li>workQueue：阻塞队列，用于保存任务的阻塞队列</li><li>threadFactory：创建线程的工程类</li><li>handler：饱和策略(拒绝策略)</li></ul><h2 id="JDK-自带阻塞队列实现"><a href="#JDK-自带阻塞队列实现" class="headerlink" title="JDK 自带阻塞队列实现"></a>JDK 自带阻塞队列实现</h2><img src="https://gitee.com/dongzl/article-images/raw/master/2020/15-ThreadPoolExecutor-Source-Code/ThreadPoolExecutor-Source-Code-02.png"><h2 id="线程池的生命周期"><a href="#线程池的生命周期" class="headerlink" title="线程池的生命周期"></a>线程池的生命周期</h2><img src="https://gitee.com/dongzl/article-images/raw/master/2020/15-ThreadPoolExecutor-Source-Code/ThreadPoolExecutor-Source-Code-03.png"><ul><li><p>RUNNING：能接受新提交的任务，并且也能处理阻塞队列中的任务；</p></li><li><p>SHUTDOWN：关闭状态，不再接受新提交的任务，但却可以继续处理阻塞队列中已保存的任务；</p></li><li><p>STOP：不能接受新任务，也不处理队列中的任务，会中断正在处理任务的线程；</p></li><li><p>TIDYING：如果所有的任务都已终止了，workerCount(有效线程数)为0，线程池进入该状态后会调用 terminated() 方法进入TERMINATED状态；</p></li><li><p>TERMINATED：在 terminated (方法执行完后进入该状态，默认 terminated() 方法中什么也没有做。</p></li></ul><h2 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h2><ul><li><code>ThreadPoolExecutor.AbortPolicy</code>：丢弃任务并抛出 <code>RejectedExecutionException</code> 异常；</li><li><code>ThreadPoolExecutor.DiscardPolicy</code>：也是丢弃任务，但是不抛<br>出异常；</li><li><code>ThreadPoolExecutor.DiscardOldestPolicy</code>：丢弃队列最前面的<br>任务，然后重新尝试执行任务(重复此过程)；</li><li><code>ThreadPoolExecutor.CallerRunsPolicy</code>：由调用线程处理该任务。</li></ul><h2 id="ThreadPoolExecutor-源码解析"><a href="#ThreadPoolExecutor-源码解析" class="headerlink" title="ThreadPoolExecutor 源码解析"></a>ThreadPoolExecutor 源码解析</h2><h3 id="常用变量的解释"><a href="#常用变量的解释" class="headerlink" title="常用变量的解释"></a>常用变量的解释</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. `ctl`，可以看做一个int类型的数字，高3位表示线程池状态，低29位表示worker数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"><span class="comment">// 2. `COUNT_BITS`，`Integer.SIZE`为32，所以`COUNT_BITS`为29</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"><span class="comment">// 3. `CAPACITY`，线程池允许的最大线程数。1左移29位，然后减1，即为 2^29 - 1</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// runState is stored in the high-order bits</span></span><br><span class="line"><span class="comment">// 4. 线程池有5种状态，按大小排序如下：RUNNING &lt; SHUTDOWN &lt; STOP &lt; TIDYING &lt; TERMINATED</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Packing and unpacking ctl</span></span><br><span class="line"><span class="comment">// 5. `runStateOf()`，获取线程池状态，通过按位与操作，低29位将全部变成0</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span>     </span>&#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125;</span><br><span class="line"><span class="comment">// 6. `workerCountOf()`，获取线程池worker数量，通过按位与操作，高3位将全部变成0</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span>  </span>&#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;</span><br><span class="line"><span class="comment">// 7. `ctlOf()`，根据线程池状态和线程池worker数量，生成ctl值</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>&#123; <span class="keyword">return</span> rs | wc; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Bit field accessors that don't require unpacking ctl.</span></span><br><span class="line"><span class="comment"> * These depend on the bit layout and on workerCount being never negative.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 8. `runStateLessThan()`，线程池状态小于xx</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">runStateLessThan</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c &lt; s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 9. `runStateAtLeast()`，线程池状态大于等于xx</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">runStateAtLeast</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c &gt;= s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 基本类型参数校验</span></span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="comment">// 空指针校验</span></span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="comment">// 根据传入参数`unit`和`keepAliveTime`，将存活时间转换为纳秒存到变量`keepAliveTime `中</span></span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="提交执行-task-的过程"><a href="#提交执行-task-的过程" class="headerlink" title="提交执行 task 的过程"></a>提交执行 task 的过程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Proceed in 3 steps:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 1. If fewer than corePoolSize threads are running, try to</span></span><br><span class="line"><span class="comment">     * start a new thread with the given command as its first</span></span><br><span class="line"><span class="comment">     * task.  The call to addWorker atomically checks runState and</span></span><br><span class="line"><span class="comment">     * workerCount, and so prevents false alarms that would add</span></span><br><span class="line"><span class="comment">     * threads when it shouldn't, by returning false.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 2. If a task can be successfully queued, then we still need</span></span><br><span class="line"><span class="comment">     * to double-check whether we should have added a thread</span></span><br><span class="line"><span class="comment">     * (because existing ones died since last checking) or that</span></span><br><span class="line"><span class="comment">     * the pool shut down since entry into this method. So we</span></span><br><span class="line"><span class="comment">     * recheck state and if necessary roll back the enqueuing if</span></span><br><span class="line"><span class="comment">     * stopped, or start a new thread if there are none.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 3. If we cannot queue task, then we try to add a new</span></span><br><span class="line"><span class="comment">     * thread.  If it fails, we know we are shut down or saturated</span></span><br><span class="line"><span class="comment">     * and so reject the task.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="comment">// worker数量比核心线程数小，直接创建worker执行任务</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// worker数量超过核心线程数，任务直接进入队列</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="comment">// 线程池状态不是RUNNING状态，说明执行过shutdown命令，需要对新加入的任务执行reject()操作。</span></span><br><span class="line">        <span class="comment">// 这儿为什么需要recheck，是因为任务入队列前后，线程池的状态可能会发生变化。</span></span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="comment">// 这儿为什么需要判断0值，主要是在线程池构造方法中，核心线程数允许为0</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果线程池不是运行状态，或者任务进入队列失败，则尝试创建worker执行任务。</span></span><br><span class="line">    <span class="comment">// 这儿有3点需要注意：</span></span><br><span class="line">    <span class="comment">// 1. 线程池不是运行状态时，addWorker内部会判断线程池状态</span></span><br><span class="line">    <span class="comment">// 2. addWorker第2个参数表示是否创建核心线程</span></span><br><span class="line">    <span class="comment">// 3. addWorker返回false，则说明任务执行失败，需要执行reject操作</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="addworker-源码解析"><a href="#addworker-源码解析" class="headerlink" title="addworker 源码解析"></a>addworker 源码解析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">    retry:</span><br><span class="line">    <span class="comment">// 外层自旋</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这个条件写得比较难懂，我对其进行了调整，和下面的条件等价</span></span><br><span class="line">        <span class="comment">// (rs &gt; SHUTDOWN) || </span></span><br><span class="line">        <span class="comment">// (rs == SHUTDOWN &amp;&amp; firstTask != null) || </span></span><br><span class="line">        <span class="comment">// (rs == SHUTDOWN &amp;&amp; workQueue.isEmpty())</span></span><br><span class="line">        <span class="comment">// 1. 线程池状态大于SHUTDOWN时，直接返回false</span></span><br><span class="line">        <span class="comment">// 2. 线程池状态等于SHUTDOWN，且firstTask不为null，直接返回false</span></span><br><span class="line">        <span class="comment">// 3. 线程池状态等于SHUTDOWN，且队列为空，直接返回false</span></span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">               firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">               ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 内层自旋</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">            <span class="comment">// worker数量超过容量，直接返回false</span></span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// 使用CAS的方式增加worker数量。</span></span><br><span class="line">            <span class="comment">// 若增加成功，则直接跳出外层循环进入到第二部分</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">            c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">            <span class="comment">// 线程池状态发生变化，对外层循环进行自旋</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">            <span class="comment">// 其他情况，直接内层循环进行自旋即可</span></span><br><span class="line">            <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">    Worker w = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">        <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">            <span class="comment">// worker的添加必须是串行的，因此需要加锁</span></span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// Recheck while holding lock.</span></span><br><span class="line">                <span class="comment">// Back out on ThreadFactory failure or if</span></span><br><span class="line">                <span class="comment">// shut down before lock acquired.</span></span><br><span class="line">                <span class="comment">// 这儿需要重新检查线程池状态</span></span><br><span class="line">                <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    <span class="comment">// worker已经调用过了start()方法，则不再创建worker</span></span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                    <span class="comment">// worker创建并添加到workers成功</span></span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    <span class="comment">// 更新`largestPoolSize`变量</span></span><br><span class="line">                    <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 启动worker线程</span></span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// worker线程启动失败，说明线程池状态发生了变化（关闭操作被执行），需要进行shutdown相关操作</span></span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程池-worker-任务单元"><a href="#线程池-worker-任务单元" class="headerlink" title="线程池 worker 任务单元"></a>线程池 worker 任务单元</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This class will never be serialized, but we provide a</span></span><br><span class="line"><span class="comment">     * serialVersionUID to suppress a javac warning.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6138294804551838833L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Thread this worker is running in.  Null if factory fails. */</span></span><br><span class="line">    <span class="keyword">final</span> Thread thread;</span><br><span class="line">    <span class="comment">/** Initial task to run.  Possibly null. */</span></span><br><span class="line">    Runnable firstTask;</span><br><span class="line">    <span class="comment">/** Per-thread task counter */</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> completedTasks;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates with given first task and thread from ThreadFactory.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> firstTask the first task (null if none)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Worker(Runnable firstTask) &#123;</span><br><span class="line">        setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker</span></span><br><span class="line">        <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">        <span class="comment">// 这儿是Worker的关键所在，使用了线程工厂创建了一个线程。传入的参数为当前worker</span></span><br><span class="line">        <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Delegates main run loop to outer runWorker  */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        runWorker(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="核心线程执行逻辑-runWorker"><a href="#核心线程执行逻辑-runWorker" class="headerlink" title="核心线程执行逻辑-runWorker"></a>核心线程执行逻辑-runWorker</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    Thread wt = Thread.currentThread();</span><br><span class="line">    Runnable task = w.firstTask;</span><br><span class="line">    w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 调用unlock()是为了让外部可以中断</span></span><br><span class="line">    w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">    <span class="comment">// 这个变量用于判断是否进入过自旋（while循环）</span></span><br><span class="line">    <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 这儿是自旋</span></span><br><span class="line">        <span class="comment">// 1. 如果firstTask不为null，则执行firstTask；</span></span><br><span class="line">        <span class="comment">// 2. 如果firstTask为null，则调用getTask()从队列获取任务。</span></span><br><span class="line">        <span class="comment">// 3. 阻塞队列的特性就是：当队列为空时，当前线程会被阻塞等待</span></span><br><span class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 这儿对worker进行加锁，是为了达到下面的目的</span></span><br><span class="line">            <span class="comment">// 1. 降低锁范围，提升性能</span></span><br><span class="line">            <span class="comment">// 2. 保证每个worker执行的任务是串行的</span></span><br><span class="line">            w.lock();</span><br><span class="line">            <span class="comment">// If pool is stopping, ensure thread is interrupted;</span></span><br><span class="line">            <span class="comment">// if not, ensure thread is not interrupted.  This</span></span><br><span class="line">            <span class="comment">// requires a recheck in second case to deal with</span></span><br><span class="line">            <span class="comment">// shutdownNow race while clearing interrupt</span></span><br><span class="line">            <span class="comment">// 如果线程池正在停止，则对当前线程进行中断操作</span></span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                 (Thread.interrupted() &amp;&amp;</span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            <span class="comment">// 执行任务，且在执行前后通过`beforeExecute()`和`afterExecute()`来扩展其功能。</span></span><br><span class="line">            <span class="comment">// 这两个方法在当前类里面为空实现。</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 帮助gc</span></span><br><span class="line">                task = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 已完成任务数加一 </span></span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 自旋操作被退出，说明线程池正在结束</span></span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://mp.weixin.qq.com/s/ahHKn8qs96bTHURQlcvuNA" target="_blank" rel="noopener">Java 线程池 ThreadPoolExecutor 八种拒绝策略浅析</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;学习 Java 的多线程知识就绕不开线程池，提起线程池那就必然要说到 ThreadPoolExecutor 类，自从 &lt;code&gt;阿里巴巴编
      
    
    </summary>
    
    
      <category term="java开发" scheme="https://dongzl.github.io/categories/java%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="ThreadPoolExecutor" scheme="https://dongzl.github.io/tags/ThreadPoolExecutor/"/>
    
      <category term="线程池" scheme="https://dongzl.github.io/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>Redis 高可用之主从复制</title>
    <link href="https://dongzl.github.io/2020/03/17/14-Redis-HA-Master-Salve/"/>
    <id>https://dongzl.github.io/2020/03/17/14-Redis-HA-Master-Salve/</id>
    <published>2020-03-17T10:39:21.000Z</published>
    <updated>2020-04-09T03:08:42.587Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景描述"><a href="#背景描述" class="headerlink" title="背景描述"></a>背景描述</h2><p>单机的 Redis，能够承载的 QPS 大概就在十万左右。对于缓存来说，一般都是用来支撑读高并发的，做成 <code>master-slave</code> 架构，一主多从，<code>master</code> 节点负责写，并且将数据复制到其它的 <code>slave</code> 节点，<code>slave</code> 节点负责读，所有的读请求全部走 <code>slave</code> 节点，这样也可以很轻松实现水平扩容，支撑读高并发。</p><h2 id="Redis-replication-的核心机制"><a href="#Redis-replication-的核心机制" class="headerlink" title="Redis replication 的核心机制"></a>Redis replication 的核心机制</h2><ul><li>Redis 采用异步方式复制数据到 slave 节点，不过 Redis2.8 开始，slave node 会周期性地确认自己每次复制的数据量；</li><li>一个 master node 是可以配置多个 slave node 的；</li><li>slave node 也可以连接其他的 slave node；</li><li>slave node 做复制的时候，不会阻塞 master node 的正常读写；</li><li>slave node 在做复制的时候，也不会阻塞对自己的读操作，它会用旧的数据集来提供服务；但是复制完成的时候，需要删除旧数据集，加载新数据集，这个时候会暂停服务；</li><li>slave node 主要用来进行横向扩容，做读写分离，扩容的 slave node 可以提高读的吞吐量。</li></ul><p>PS. 如果采用了主从架构，那么建议必须开启 master node 的持久化，不建议用 slave node 作为 master node 的数据热备，因为如果关掉了 master 的持久化，可能在 master 宕机重启后数据是空的，这个时候 slave node 做数据同步，slave node 的数据也丢了。</p><p>另外，master node 也需要进行各种备份。一旦本地的所有文件丢失了，从备份中挑选一份 RDB 文件去恢复 master 数据，这样才能确保启动的时候，是有数据的，防止数据全部丢失。</p><h2 id="Redis-主从复制的核心原理"><a href="#Redis-主从复制的核心原理" class="headerlink" title="Redis 主从复制的核心原理"></a>Redis 主从复制的核心原理</h2><p>当启动一个 slave node 的时候，它会发送一个 <code>PSYNC</code> 命令给 master node。如果这是 slave node 初次连接到 master node，那么会触发一次 <code>full resynchronization</code> 全量复制。此时 master 会启动一个后台线程，开始生成一份 RDB 快照文件，同时还会将客户端 client 新收到的所有写命令缓存在内存中。RDB 文件生成完毕后， master 会将这个 RDB 文件发送给 slave，slave 会先写入本地磁盘，然后再从本地磁盘加载到内存中，接着 master 会将内存中缓存的写命令发送到 slave，slave 也会同步这些数据。slave node 如果跟 master node 有网络故障，断开了连接，会自动重连，连接之后 master node 仅会复制给 slave 部分缺少的数据。</p><img src="https://gitee.com/dongzl/article-images/raw/master/2020/14-Redis-HA-Master-Salve/Redis-HA-Master-Salve-01.png"><h3 id="主从复制的断点续传"><a href="#主从复制的断点续传" class="headerlink" title="主从复制的断点续传"></a>主从复制的断点续传</h3><p>从 Redis2.8 开始，就支持主从复制的断点续传，如果主从复制过程中，网络连接断掉了，那么可以接着上次复制的地方，继续复制下去，而不是从头开始复制一份。</p><p>master node 会在内存中维护一个 <code>backlog</code>，master 和 slave 都会保存一个 <code>replica offset</code> 还有一个 <code>master run id</code>，<code>offset</code> 就是保存在 <code>backlog</code> 中的。如果 master 和 slave 网络连接断掉了，slave 会让 master 从上次 <code>replica offset</code> 开始继续复制，如果没有找到对应的 <code>offset</code>，那么就会执行一次 <code>resynchronization</code>。</p><blockquote><p>如果根据 host + ip 定位 master node，是不靠谱的，如果 master node 重启或者数据发生了变化，那么 slave node 应该根据不同的 run id 区分。</p></blockquote><h3 id="无磁盘化复制"><a href="#无磁盘化复制" class="headerlink" title="无磁盘化复制"></a>无磁盘化复制</h3><p>master 在内存中直接创建 <code>RDB</code>，然后发送给 slave，不会在自己本地落地磁盘了。只需要在配置文件中开启 <code>repl-diskless-sync yes</code> 即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">repl-diskless-sync yes</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 等待 5s 后再开始复制，因为要等更多 slave 重新连接过来</span></span><br><span class="line">repl-diskless-sync-delay 5</span><br></pre></td></tr></table></figure><h3 id="slave-对过期-key-处理"><a href="#slave-对过期-key-处理" class="headerlink" title="slave 对过期 key 处理"></a>slave 对过期 key 处理</h3><p>slave 不会处理过期 key，只会等待 master 过期 key。如果 master 过期了一个 key，或者通过 LRU 淘汰了一个 key，那么会模拟一条 del 命令发送给 slave。</p><h2 id="复制的完整流程"><a href="#复制的完整流程" class="headerlink" title="复制的完整流程"></a>复制的完整流程</h2><p>slave node 启动时，会在自己本地保存 master node 的信息，包括 master node 的 <code>host</code> 和 <code>ip</code>，但是复制流程没开始。</p><p>slave node 内部有个定时任务，每秒检查是否有新的 master node 要连接和复制，如果发现，就跟 master node 建立 <code>socket</code> 网络连接。然后 slave node 发送 <code>ping</code> 命令给 master node。如果 master 设置了 <code>requirepass</code>，那么 slave node 必须发送 <code>masterauth</code> 的口令过去进行认证。master node 第一次执行全量复制，将所有数据发给 slave node。而在后续，master node 持续将写命令，异步复制给 slave node。</p><img src="https://gitee.com/dongzl/article-images/raw/master/2020/14-Redis-HA-Master-Salve/Redis-HA-Master-Salve-02.png"><h3 id="全量复制"><a href="#全量复制" class="headerlink" title="全量复制"></a>全量复制</h3><ul><li><p>master 执行 <code>bgsave</code>，在本地生成一份 <code>RDB</code> 快照文件；</p></li><li><p>master node 将 RDB 快照文件发送给 slave node，如果 RDB 复制时间超过 <code>60</code> 秒（<code>repl-timeout</code>），那么 slave node 就会认为复制失败，所以需要根据实际情况适当调大这个参数；</p></li><li><p>master node 在生成 RDB 文件时，会将所有新的写命令缓存在内存中，在 slave node 保存了 RDB 之后，再将新的写命令复制给 slave node。</p></li><li><p>如果在复制期间，内存缓冲区持续消耗超过 <code>64MB</code>，或者一次性超过 <code>256MB</code>，那么将会停止复制，复制失败；</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client-output-buffer-limit slave 256MB 64MB 60</span><br></pre></td></tr></table></figure><ul><li><p>slave node 接收到 <code>RDB</code> 之后，清空自己的旧数据，然后重新加载 <code>RDB</code> 到自己的内存中，同时基于旧的数据版本对外提供服务；</p></li><li><p>如果 slave node 开启了 <code>AOF</code>，那么会立即执行 <code>BGREWRITEAOF</code>，重写 <code>AOF</code>。</p></li></ul><img src="https://gitee.com/dongzl/article-images/raw/master/2020/14-Redis-HA-Master-Salve/Redis-HA-Master-Salve-03.png"><img src="https://gitee.com/dongzl/article-images/raw/master/2020/14-Redis-HA-Master-Salve/Redis-HA-Master-Salve-04.png"><h3 id="增量复制"><a href="#增量复制" class="headerlink" title="增量复制"></a>增量复制</h3><ul><li><p>如果全量复制过程中，master-slave 网络连接断掉，那么 slave 重新连接 master 时，会触发增量复制；</p></li><li><p>master 直接从自己的 <code>backlog</code> 中获取部分丢失的数据，发送给 slave node，默认 <code>backlog</code> 就是 <code>1MB</code>。</p></li><li><p>master 就是根据 slave 发送的 <code>psync</code> 中的 <code>offset</code> 来从 <code>backlog</code> 中获取数据的。</p></li></ul><h3 id="heartbeat"><a href="#heartbeat" class="headerlink" title="heartbeat"></a>heartbeat</h3><p>主从节点互相都会发送 <code>heartbeat</code> 信息。</p><p>master 默认每隔 <code>10秒</code> 发送一次 <code>heartbeat</code>，slave node 每隔 <code>1秒</code> 发送一个 <code>heartbeat</code>。</p><h3 id="异步复制"><a href="#异步复制" class="headerlink" title="异步复制"></a>异步复制</h3><p>master 每次接收到写命令之后，先在内部写入数据，然后异步发送给 slave node。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><p><a href="https://blog.csdn.net/juded/article/details/90245371" target="_blank" rel="noopener">Redis：解决异步复制丢失、脑裂数据丢失状况</a></p></li><li><p><a href="https://github.com/antirez/redis-doc/blob/master/topics/replication.md" target="_blank" rel="noopener">Replication</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/91770135" target="_blank" rel="noopener">如何保障mysql和redis之间的数据一致性？</a></p></li><li><p><a href="https://blog.51cto.com/14257804/2376731" target="_blank" rel="noopener">深入Redis 主从复制原理</a></p></li><li><p><a href="https://www.cnblogs.com/leeSmall/p/8398401.html" target="_blank" rel="noopener">Redis系列八：redis主从复制和哨兵</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景描述&quot;&gt;&lt;a href=&quot;#背景描述&quot; class=&quot;headerlink&quot; title=&quot;背景描述&quot;&gt;&lt;/a&gt;背景描述&lt;/h2&gt;&lt;p&gt;单机的 Redis，能够承载的 QPS 大概就在十万左右。对于缓存来说，一般都是用来支撑读高并发的，做成 &lt;code&gt;mas
      
    
    </summary>
    
    
      <category term="架构设计" scheme="https://dongzl.github.io/categories/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="Redis" scheme="https://dongzl.github.io/tags/Redis/"/>
    
      <category term="主从复制" scheme="https://dongzl.github.io/tags/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>Kafka 是如何解决使用 MQ 中容易出现的一些问题</title>
    <link href="https://dongzl.github.io/2020/03/16/13-Solve-MQ-Problem-With-Kafka/"/>
    <id>https://dongzl.github.io/2020/03/16/13-Solve-MQ-Problem-With-Kafka/</id>
    <published>2020-03-16T12:58:08.000Z</published>
    <updated>2020-05-29T08:52:53.209Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景描述"><a href="#背景描述" class="headerlink" title="背景描述"></a>背景描述</h2><p>目前，很多的业务系统都会或多或少的使用各种 <code>MQ</code> 消息队列框架，例如：<code>RabbitMQ</code>、<code>Kafka</code>、<code>RocketMQ</code> 等等，使用 <code>MQ</code> 消息队列，可以满足业务系统 <code>解耦</code>、<code>异步</code>、<code>削峰填谷</code> 场景的需要，但是使用 <code>MQ</code> 中也不得不面临一些问题，这些问题总结如下：</p><blockquote><p>1、如何保证消息队列的高可用？<br>2、如何保证消息不被重复消费？（如何保证消息消费的幂等性）<br>3、如何保证消息的可靠传输？（如何处理消息丢失的问题）<br>4、如何保证消息的顺序性？</p></blockquote><p>其实这些问题也是在面试中 <code>MQ</code> 经常被问到的问题，下面我们就总结分析一下，<code>Kafka</code> 中是如何解决上述问题的。</p><h2 id="Kafka-如何保证高可用"><a href="#Kafka-如何保证高可用" class="headerlink" title="Kafka 如何保证高可用"></a>Kafka 如何保证高可用</h2><p><code>Kafka</code> 的基本架构组成是：由多个 <code>broker</code> 组成一个集群，每个 <code>broker</code> 是一个节点；当创建一个 <code>topic</code> 时，这个 <code>topic</code> 会被划分为多个 <code>partition</code>，每个 <code>partition</code> 可以存在于不同的 <code>broker</code> 上，每个 <code>partition</code> 只存放一部分数据。</p><p>这就是<strong>天然的分布式消息队列</strong>，就是说一个 <code>topic</code> 的数据，是<strong>分散放在多个机器上的，每个机器就放一部分数据</strong>。</p><p>在 <code>Kafka 0.8</code> 版本之前，是没有 <code>HA</code> 机制的，当任何一个 <code>broker</code> 所在节点宕机了，这个 <code>broker</code> 上的 <code>partition</code> 就无法提供读写服务，所以这个版本之前，<code>Kafka</code> 没有什么高可用性可言。</p><p>在 <code>Kafka 0.8</code> 以后，提供了 <code>HA</code> 机制，就是 <code>replica</code> 副本机制。每个 <code>partition</code> 上的数据都会同步到其它机器，形成自己的多个 <code>replica</code> 副本。所有 <code>replica</code> 会选举一个 <code>leader</code> 出来，消息的生产者和消费者都跟这个 <code>leader</code> 打交道，其他 <code>replica</code> 作为 <code>follower</code>。写的时候，<code>leader</code> 会负责把数据同步到所有 <code>follower</code> 上去，读的时候就直接读 <code>leader</code> 上的数据即可。<code>Kafka</code> 负责均匀的将一个 <code>partition</code> 的所有 <code>replica</code> 分布在不同的机器上，这样才可以提高容错性。</p><img src="https://gitee.com/dongzl/article-images/raw/master/2020/13-Solve-MQ-Problem-With-Kafka/Solve-MQ-Problem-With-Kafka-01.png" width="800px"><p>拥有了 <code>replica</code> 副本机制，如果某个 <code>broker</code> 宕机了，这个 <code>broker</code> 上的 <code>partition</code> 在其他机器上还存在副本。如果这个宕机的 <code>broker</code> 上面有某个 <code>partition</code> 的 <code>leader</code>，那么此时会从其 <code>follower</code> 中重新选举一个新的 <code>leader</code> 出来，这个新的 <code>leader</code> 会继续提供读写服务，这就有达到了所谓的高可用性。</p><p>写数据的时候，生产者只将数据写入 <code>leader</code> 节点，<code>leader</code> 会将数据写入本地磁盘，接着其他 <code>follower</code> 会主动从 <code>leader</code> 来拉取数据，<code>follower</code> 同步好数据了，就会发送 <code>ack</code> 给 <code>leader</code>，<code>leader</code> 收到所有 <code>follower</code> 的 <code>ack</code> 之后，就会返回写成功的消息给生产者。</p><p>消费数据的时候，消费者只会从 <code>leader</code> 节点去读取消息，但是只有当一个消息已经被所有 <code>follower</code> 都同步成功返回 <code>ack</code> 的时候，这个消息才会被消费者读到。</p><img src="https://gitee.com/dongzl/article-images/raw/master/2020/13-Solve-MQ-Problem-With-Kafka/Solve-MQ-Problem-With-Kafka-02.png" width="800px"><h2 id="使用-Kafka，如何保证消息不被重复消费"><a href="#使用-Kafka，如何保证消息不被重复消费" class="headerlink" title="使用 Kafka，如何保证消息不被重复消费"></a>使用 Kafka，如何保证消息不被重复消费</h2><h3 id="Kafka-在什么场景下会导致消费者消费到重复数据"><a href="#Kafka-在什么场景下会导致消费者消费到重复数据" class="headerlink" title="Kafka 在什么场景下会导致消费者消费到重复数据"></a>Kafka 在什么场景下会导致消费者消费到重复数据</h3><p><code>Kafka</code> 实际上有个 <code>offset</code> 的概念，就是每个消息写到 <code>partition</code> 里，都会有一个 <code>offset</code>，代表消息的序号，在 <code>consumer</code> 消费了数据之后，<strong>每隔一段时间（定时定期）</strong>，<code>consumer</code> 会把自己消费过的消息的 <code>offset</code> 提交一下，表示<strong>这些消息已经消费过了，如果发生异常，下次我将从上次消费到的 offset 来继续消费</strong>。</p><p>但是这个过程还是会有意外出现，比如 <code>consumer</code> 机器突然宕机，这会导致 <code>consumer</code> 有些消息已经处理了，但是没来得及提交 <code>offset</code>，这个时候重启之后，就会有少数宕机之前会来得及提交 <code>offset</code> 的消息会被再消费一次。</p><h3 id="如何解决消费到重复数据问题"><a href="#如何解决消费到重复数据问题" class="headerlink" title="如何解决消费到重复数据问题"></a>如何解决消费到重复数据问题</h3><p>对于重复消费的问题，我理解对于任何 <code>MQ</code> 消息队列都是无法避免的，所以就需要我们在业务系统进行<strong>重复消费的幂等性</strong>验证，当然也要考虑业务场景需要，比如一个日志采集系统，每天上千万的数据，某条重复数据的影响几乎可以忽略不计，这个时候也是不需要考虑；如果是其他场景，需要保证幂等性，可以从如下几方面考虑：</p><ul><li>如果是写数据库，可以将消息中的某个字段做为数据库唯一约束，在数据处理之前，先根据唯一约束查询一下，判断是否已经消费过；</li><li>如果是写入 <code>Redis</code>，可以直接调用 <code>set</code> 方法，天然具备幂等性；</li><li>在生产者发送每消息的时候，在消息里面加一个全局唯一的 <code>id</code>，类似订单 <code>id</code> 之类的数据，当消费到这个数据之后，先根据这个全局 <code>id</code> 去比如 <code>Redis</code> 里查一下，如果不存在，说明没有消费过，就继续处理，然后这个 <code>id</code> 写 <code>Redis</code>；如果存在，说明已经消费过，消息直接丢弃。</li></ul><h2 id="使用-Kafka，如何保证消息的可靠传输"><a href="#使用-Kafka，如何保证消息的可靠传输" class="headerlink" title="使用 Kafka，如何保证消息的可靠传输"></a>使用 Kafka，如何保证消息的可靠传输</h2><p>对于保证消息的可靠传输，其实就是如何解决消息丢失的问题；那么我们首先需要弄明白消息为什么会丢失，对于一个消息队列，会有 <code>生产者</code>、<code>MQ</code>、<code>消费者</code> 这三个角色，在这三个角色数据处理和传输过程中，都有可能会出现消息丢失，</p><img src="https://gitee.com/dongzl/article-images/raw/master/2020/13-Solve-MQ-Problem-With-Kafka/Solve-MQ-Problem-With-Kafka-03.png" width="800px"><p>下面我们就结合 <code>Kafka</code> 来分析一下消息丢失的原因以及解决办法：</p><h3 id="消费者异常导致的消息丢失"><a href="#消费者异常导致的消息丢失" class="headerlink" title="消费者异常导致的消息丢失"></a>消费者异常导致的消息丢失</h3><p>消费者可能导致数据丢失的情况是：消费者获取到了这条消息后，还未处理，<code>Kafka</code> 就自动提交了 <code>offset</code>，这时 <code>Kafka</code> 就认为消费者已经处理完这条消息，其实消费者才刚准备处理这条消息，这时如果消费者宕机，那这条消息就丢失了。</p><p>消费者引起消息丢失的主要原因就是消息还未处理完 <code>Kafka</code> 会自动提交了 <code>offset</code>，那么只要关闭自动提交 <code>offset</code>，消费者在处理完之后手动提交 <code>offset</code>，就可以保证消息不会丢失。但是此时需要注意重复消费问题，比如消费者刚处理完，还没提交 <code>offset</code>，这时自己宕机了，此时这条消息肯定会被重复消费一次，这就需要消费者根据实际情况保证幂等性。</p><h3 id="Kafka-导致的消息丢失"><a href="#Kafka-导致的消息丢失" class="headerlink" title="Kafka 导致的消息丢失"></a>Kafka 导致的消息丢失</h3><p><code>Kafka</code> 导致的数据丢失一个常见的场景就是 <code>Kafka</code> 某个 <code>broker</code> 宕机，，而这个节点正好是某个 <code>partition</code> 的 <code>leader</code> 节点，这时需要重新重新选举该 <code>partition</code> 的 <code>leader</code>。如果该 <code>partition</code> 的 <code>leader</code> 在宕机时刚好还有些数据没有同步到 <code>follower</code>，此时 <code>leader</code> 挂了，在选举某个 <code>follower</code> 成 <code>leader</code> 之后，就会丢失一部分数据。</p><p>对于这个问题，<code>Kafka</code> 可以设置如下 4 个参数，来尽量避免消息丢失：</p><ul><li>给 <code>topic</code> 设置 <code>replication.factor</code> 参数：这个值必须大于 <code>1</code>，要求每个 <code>partition</code> 必须有至少 <code>2</code> 个副本；</li><li>在 <code>Kafka</code> 服务端设置 <code>min.insync.replicas</code> 参数：这个值必须大于 <code>1</code>，这个参数的含义是一个 <code>leader</code> 至少感知到有至少一个 <code>follower</code> 还跟自己保持联系，没掉队，这样才能确保 <code>leader</code> 挂了还有一个 <code>follower</code> 节点。</li><li>在 <code>producer</code> 端设置 <code>acks=all</code>，这个是要求每条数据，必须是写入所有 <code>replica</code> 之后，才能认为是写成功了；</li><li>在 <code>producer</code> 端设置 <code>retries=MAX</code>（很大很大很大的一个值，无限次重试的意思）：这个参数的含义是一旦写入失败，就无限重试，卡在这里了。</li></ul><h3 id="生产者数据传输导致的消息丢失"><a href="#生产者数据传输导致的消息丢失" class="headerlink" title="生产者数据传输导致的消息丢失"></a>生产者数据传输导致的消息丢失</h3><p>对于生产者数据传输导致的数据丢失主常见情况是生产者发送消息给 <code>Kafka</code>，由于网络等原因导致消息丢失，对于这种情况也是通过在 <strong>producer</strong> 端设置 <strong>acks=all</strong> 来处理，这个参数是要求 <code>leader</code> 接收到消息后，需要等到所有的 <code>follower</code> 都同步到了消息之后，才认为本次写成功了。如果没满足这个条件，生产者会自动不断的重试。</p><p><a href="https://mp.weixin.qq.com/s/qttczGROYoqSulzi8FLXww" target="_blank" rel="noopener">面试官问我如何保证Kafka不丢失消息?我哭了！</a></p><h2 id="Kafka-如何保证消息的顺序性"><a href="#Kafka-如何保证消息的顺序性" class="headerlink" title="Kafka 如何保证消息的顺序性"></a>Kafka 如何保证消息的顺序性</h2><p>在某些业务场景下，我们需要保证对于有逻辑关联的多条MQ消息被按顺序处理，比如对于某一条数据，正常处理顺序是<code>新增-更新-删除</code>，最终结果是数据被删除；如果消息没有按序消费，处理顺序可能是<code>删除-新增-更新</code>，最终数据没有被删掉，可能会产生一些逻辑错误。对于如何保证消息的顺序性，主要需要考虑如下两点：</p><ul><li>如何保证消息在 <code>MQ</code> 中顺序性；</li><li>如何保证消费者处理消费的顺序性。</li></ul><h3 id="如何保证消息在-MQ-中顺序性"><a href="#如何保证消息在-MQ-中顺序性" class="headerlink" title="如何保证消息在 MQ 中顺序性"></a>如何保证消息在 MQ 中顺序性</h3><p>对于 <code>Kafka</code>，如果我们创建了一个 <code>topic</code>，默认有三个 <code>partition</code>。生产者在写数据的时候，可以指定一个 <code>key</code>，比如在订单 <code>topic</code> 中我们可以指定订单 <code>id</code> 作为 <code>key</code>，那么相同订单 <code>id</code> 的数据，一定会被分发到同一个 <code>partition</code> 中去，而且这个 <code>partition</code> 中的数据一定是有顺序的。消费者从 <code>partition</code> 中取出来数据的时候，也一定是有顺序的。通过制定 <code>key</code> 的方式首先可以保证在 <code>kafka</code> 内部消息是有序的。</p><h3 id="如何保证消费者处理消费的顺序性"><a href="#如何保证消费者处理消费的顺序性" class="headerlink" title="如何保证消费者处理消费的顺序性"></a>如何保证消费者处理消费的顺序性</h3><p>对于某个 <code>topic</code> 的一个 <code>partition</code>，只能被同组内部的一个 <code>consumer</code> 消费，如果这个 <code>consumer</code> 内部还是单线程处理，那么其实只要保证消息在 <code>MQ</code> 内部是有顺序的就可以保证消费也是有顺序的。但是单线程吞吐量太低，在处理大量 <code>MQ</code> 消息时，我们一般会开启多线程消费机制，那么如何保证消息在多个线程之间是被顺序处理的呢？对于多线程消费我们可以预先设置 <code>N</code> 个内存 <code>Queue</code>，具有相同 <code>key</code> 的数据都放到同一个内存 <code>Queue</code> 中；然后开启 <code>N</code> 个线程，每个线程分别消费一个内存 <code>Queue</code> 的数据即可，这样就能保证顺序性。当然，消息放到内存 <code>Queue</code> 中，有可能还未被处理，<code>consumer</code> 发生宕机，内存 <code>Queue</code> 中的数据会全部丢失，这就转变为上面提到的<strong>如何保证消息的可靠传输</strong>的问题了。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.cnblogs.com/qingyunzong/p/9004703.html" target="_blank" rel="noopener">Kafka学习之路 （三）Kafka的高可用</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景描述&quot;&gt;&lt;a href=&quot;#背景描述&quot; class=&quot;headerlink&quot; title=&quot;背景描述&quot;&gt;&lt;/a&gt;背景描述&lt;/h2&gt;&lt;p&gt;目前，很多的业务系统都会或多或少的使用各种 &lt;code&gt;MQ&lt;/code&gt; 消息队列框架，例如：&lt;code&gt;RabbitMQ
      
    
    </summary>
    
    
      <category term="架构设计" scheme="https://dongzl.github.io/categories/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="Kafka" scheme="https://dongzl.github.io/tags/Kafka/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 主从复制原理及配置</title>
    <link href="https://dongzl.github.io/2020/03/15/12-MySQL-Master-Slave-Replication/"/>
    <id>https://dongzl.github.io/2020/03/15/12-MySQL-Master-Slave-Replication/</id>
    <published>2020-03-15T03:04:01.000Z</published>
    <updated>2020-04-09T03:08:42.579Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MySQL-主从复制原理"><a href="#MySQL-主从复制原理" class="headerlink" title="MySQL 主从复制原理"></a>MySQL 主从复制原理</h2><h3 id="什么是-MySQL-的主从复制"><a href="#什么是-MySQL-的主从复制" class="headerlink" title="什么是 MySQL 的主从复制"></a>什么是 MySQL 的主从复制</h3><p>MySQL 主从复制是指数据可以从一个 MySQL 数据库服务器主节点复制到一个或多个从节点。MySQL 默认采用异步复制方式，这样从节点不用一直访问主服务器来更新自己的数据，数据的更新可以在远程连接上进行，从节点可以复制主数据库中的所有数据库或者特定的数据库，或者特定的表。</p><h3 id="为什么需要主从复制"><a href="#为什么需要主从复制" class="headerlink" title="为什么需要主从复制"></a>为什么需要主从复制</h3><ul><li>提高数据库读写性能，提升系统吞吐量</li></ul><p>在业务复杂的系统中，如果有一条 SQL 语句的执行需要锁表，导致 MySQL 暂时不能提供读的服务，那么就很影响运行中的业务，使用主从复制，让主库负责写，从库负责读，这样即使主库出现了锁表的情景，通过读从库也可以保证业务的正常运作。</p><ul><li><p>做数据库热备</p></li><li><p>架构扩展需要</p></li></ul><p>业务量越来越大，I/O 访问频率过高，单机无法满足，此时做多库的存储，降低磁盘I/O 访问的频率，提升整个数据库性能。</p><h3 id="MySQL-的复制原理"><a href="#MySQL-的复制原理" class="headerlink" title="MySQL 的复制原理"></a>MySQL 的复制原理</h3><p><strong>原理</strong>：</p><ul><li><p>master 服务器将数据的改变记录二进制 binlog 日志，当 master 上的数据发生改变时，则将其改变写入二进制日志中；</p></li><li><p>slave 服务器会在一定时间间隔内对 master 二进制日志进行探测其是否发生改变，如果发生改变，则开始一个 I/OThread 请求 master 二进制事件；</p></li><li><p>同时主节点为每个 I/O 线程启动一个 dump 线程，用于向其发送二进制事件，并保存至从节点本地的中继日志中，从节点将启动 SQL 线程从中继日志中读取二进制日志，在本地重放，使得其数据和主节点的保持一致，最后 I/OThread 和 SQLThread 将进入睡眠状态，等待下一次被唤醒。</p></li></ul><p><strong>也就是</strong>：</p><ul><li><p>从库会生成两个线程,一个 I/O 线程,一个 SQL 线程；</p></li><li><p>I/O 线程会去请求主库的 binlog，并将得到的 binlog 写到本地的 relay-log（中继日志）文件中；主库会生成一个 log dump 线程,用来给从库 I/O 线程传 binlog；</p></li><li><p>SQL 线程，会读取 relay log 文件中的日志，并解析成sql语句逐一执行。</p></li></ul><p><strong>注意</strong>：</p><ul><li><p>master 将操作语句记录到 binlog 日志中，然后授予 slave 远程连接的权限（master 一定要开启 binlog 二进制日志功能；通常为了数据安全考虑，slave 也开启binlog功能）；</p></li><li><p>slave 开启两个线程：IO 线程和 SQL 线程。其中：IO 线程负责读取 master 的 binlog 内容到中继日志 relay log 里；SQL 线程负责从 relay log 日志里读出 binlog 内容，并更新到 slave 的数据库里，这样就能保证 slave 数据和 master 数据保持一致了；</p></li><li><p>MySQL 复制至少需要两个 MySQL 的服务，当然 MySQL 服务可以分布在不同的服务器上，也可以在一台服务器上启动多个服务；</p></li><li><p>MySQL复制最好确保 master 和 slave 服务器上的 MySQL 版本相同（如果不能满足版本一致，那么要保证 master 主节点的版本低于 slave 从节点的版本）；</p></li><li><p>master 和 slave 两节点间时间需同步。</p></li></ul><img src="https://gitee.com/dongzl/article-images/raw/master/2020/12-MySQL-Master-Slave-Replication/MySQL-Master-Slave-Replication-01.jpeg"><p><strong>具体步骤</strong>：</p><ul><li><p>从库通过手工执行 change master to 语句连接主库，提供了连接的用户一切条件（user 、password、port、ip），并且让从库知道，二进制日志的起点位置（file名 position 号）start slave；</p></li><li><p>从库的 IO 线程和主库的 dump 线程建立连接；</p></li><li><p>从库根据 change master to 语句提供的 file 名和 position 号，IO 线程向主库发起 binlog 的请求；</p></li><li><p>主库 dump 线程根据从库的请求，将本地 binlog 以 events 的方式发给从库IO 线程；</p></li><li><p>从库 IO 线程接收 binlog events，并存放到本地 relay-log 中，传送过来的信息，会记录到 <code>master.info</code> 中；</p></li><li><p>从库 SQL 线程应用 relay-log，并且把应用过的记录到 <code>relay-log.info</code> 中，默认情况下，已经应用过的 relay 会自动被清理 purge。</p></li></ul><h3 id="MySQL-主从复制的形式"><a href="#MySQL-主从复制的形式" class="headerlink" title="MySQL 主从复制的形式"></a>MySQL 主从复制的形式</h3><ul><li><p>一主一从</p></li><li><p>主主复制</p></li><li><p>一主多从</p></li><li><p>多主一从</p></li><li><p>级联复制</p></li></ul><img src="https://gitee.com/dongzl/article-images/raw/master/2020/12-MySQL-Master-Slave-Replication/MySQL-Master-Slave-Replication-02.png"><h3 id="MySQL-主从复制延时分析"><a href="#MySQL-主从复制延时分析" class="headerlink" title="MySQL 主从复制延时分析"></a>MySQL 主从复制延时分析</h3><p>MySQL 的主从复制都是单线程的操作，主库对所有 DDL 和 DML 产生的日志写进 binlog，由于 binlog 是顺序写，所以效率很高，slave 的 SQL thread 线程将主库的 DDL 和 DML 操作事件在 slave 中重放。DML 和 DDL 的 IO 操作是随机的，不是顺序，所以成本要高很多，另一方面，由于 SQL thread 也是单线程的，当主库的并发较高时，产生的 DML 数量超过 slave 的 SQL thread 所能处理的速度，或者当 slave 中有大型 query 语句产生了锁等待，那么延时就产生了。</p><p><strong>解决方案</strong>：</p><ul><li>业务的持久层实现采用分库架构，mysql 服务可以水平扩展，分散压力；</li><li>单个库读写分离，一主多从，主写从读，分散压力；这样从库压力可能会比主库高，保护主库。</li><li>服务的基础架构在业务系统和mysql之间加入memcache或者redis 的cache层，降低mysql读压力。</li><li>不同业务的mysql物理上放在不同的机器，分散压力。</li><li>使用比主库更好的硬件设备作为slave，mysql压力小，延迟自然会变小。</li><li>使用更加强劲的硬件设备。</li></ul><h2 id="MySQL-主从复制安装配置"><a href="#MySQL-主从复制安装配置" class="headerlink" title="MySQL 主从复制安装配置"></a>MySQL 主从复制安装配置</h2><h3 id="基础设置准备"><a href="#基础设置准备" class="headerlink" title="基础设置准备"></a>基础设置准备</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">操作系统：</span></span><br><span class="line">centos6.5</span><br><span class="line"><span class="meta">#</span><span class="bash">mysql版本：</span></span><br><span class="line">5.7</span><br><span class="line"><span class="meta">#</span><span class="bash">两台虚拟机：</span></span><br><span class="line">node1:192.168.85.111（主）</span><br><span class="line">node2:192.168.85.112（从）</span><br></pre></td></tr></table></figure><h3 id="安装-MySQL-数据库"><a href="#安装-MySQL-数据库" class="headerlink" title="安装 MySQL 数据库"></a>安装 MySQL 数据库</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">## 在两台数据库中分别创建数据库</span></span></span><br><span class="line"></span><br><span class="line">```sql</span><br><span class="line">--注意两台必须全部执行</span><br><span class="line">create database test;</span><br></pre></td></tr></table></figure><h3 id="在主（node1）服务器进行如下配置："><a href="#在主（node1）服务器进行如下配置：" class="headerlink" title="在主（node1）服务器进行如下配置："></a>在主（node1）服务器进行如下配置：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">修改配置文件，执行以下命令打开mysql配置文件</span></span><br><span class="line">vi /etc/my.cnf</span><br><span class="line"><span class="meta">#</span><span class="bash">在mysqld模块中添加如下配置信息</span></span><br><span class="line">log-bin=master-bin #二进制文件名称</span><br><span class="line">binlog-format=ROW  #二进制日志格式，有row、statement、mixed三种格式，row指的是把改变的内容复制过去，而不是把命令在从服务器上执行一遍，statement指的是在主服务器上执行的SQL语句，在从服务器上执行同样的语句。MySQL默认采用基于语句的复制，效率比较高。mixed指的是默认采用基于语句的复制，一旦发现基于语句的无法精确的复制时，就会采用基于行的复制。</span><br><span class="line">server-id=1   #要求各个服务器的id必须不一样</span><br><span class="line">binlog-do-db=test   #同步的数据库名称</span><br></pre></td></tr></table></figure><h3 id="配置从服务器登录主服务器的账号授权"><a href="#配置从服务器登录主服务器的账号授权" class="headerlink" title="配置从服务器登录主服务器的账号授权"></a>配置从服务器登录主服务器的账号授权</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--授权操作</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> validate_password_policy=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> validate_password_length=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">replication</span> <span class="keyword">slave</span> <span class="keyword">on</span> *.* <span class="keyword">to</span> <span class="string">'root'</span>@<span class="string">'%'</span> <span class="keyword">identified</span> <span class="keyword">by</span> <span class="string">'123456'</span>;</span><br><span class="line"><span class="comment">--刷新权限</span></span><br><span class="line"><span class="keyword">flush</span> <span class="keyword">privileges</span>;</span><br></pre></td></tr></table></figure><h3 id="从服务器的配置"><a href="#从服务器的配置" class="headerlink" title="从服务器的配置"></a>从服务器的配置</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">修改配置文件，执行以下命令打开mysql配置文件</span></span><br><span class="line">vi /etc/my.cnf</span><br><span class="line"><span class="meta">#</span><span class="bash">在mysqld模块中添加如下配置信息</span></span><br><span class="line">log-bin=master-bin#二进制文件的名称</span><br><span class="line">binlog-format=ROW#二进制文件的格式</span><br><span class="line">server-id=2#服务器的id</span><br></pre></td></tr></table></figure><h3 id="重启主服务器的mysqld服务"><a href="#重启主服务器的mysqld服务" class="headerlink" title="重启主服务器的mysqld服务"></a>重启主服务器的mysqld服务</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">重启mysql服务</span></span><br><span class="line">service mysqld restart</span><br><span class="line"><span class="meta">#</span><span class="bash">登录mysql数据库</span></span><br><span class="line">mysql -uroot -p</span><br><span class="line"><span class="meta">#</span><span class="bash">查看master的状态</span></span><br><span class="line">show master status；</span><br></pre></td></tr></table></figure><h3 id="重启从服务器并进行相关配置"><a href="#重启从服务器并进行相关配置" class="headerlink" title="重启从服务器并进行相关配置"></a>重启从服务器并进行相关配置</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">重启mysql服务</span></span><br><span class="line">service mysqld restart</span><br><span class="line"><span class="meta">#</span><span class="bash">登录mysql</span></span><br><span class="line">mysql -uroot -p</span><br><span class="line"><span class="meta">#</span><span class="bash">连接主服务器</span></span><br><span class="line">change master to master_host='192.168.85.11',master_user='root',master_password='123456',master_port=3306,master_log_file='master-bin.000001',master_log_pos=154;</span><br><span class="line"><span class="meta">#</span><span class="bash">启动slave</span></span><br><span class="line">start slave</span><br><span class="line"><span class="meta">#</span><span class="bash">查看slave的状态</span></span><br><span class="line">show slave status\G(注意没有分号)</span><br></pre></td></tr></table></figure><blockquote><p>内容来源：<a href="http://www.mashibing.com/" target="_blank" rel="noopener">马士兵教育</a> 公开课内容知识整理</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;MySQL-主从复制原理&quot;&gt;&lt;a href=&quot;#MySQL-主从复制原理&quot; class=&quot;headerlink&quot; title=&quot;MySQL 主从复制原理&quot;&gt;&lt;/a&gt;MySQL 主从复制原理&lt;/h2&gt;&lt;h3 id=&quot;什么是-MySQL-的主从复制&quot;&gt;&lt;a href=
      
    
    </summary>
    
    
      <category term="数据库" scheme="https://dongzl.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="主从复制" scheme="https://dongzl.github.io/tags/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
    
      <category term="MySQL" scheme="https://dongzl.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 数据库优化知识总结</title>
    <link href="https://dongzl.github.io/2020/03/14/11-MySQL-Optimization-Knowledge-Summary/"/>
    <id>https://dongzl.github.io/2020/03/14/11-MySQL-Optimization-Knowledge-Summary/</id>
    <published>2020-03-14T14:06:18.000Z</published>
    <updated>2020-05-22T07:49:42.312Z</updated>
    
    <content type="html"><![CDATA[<h2 id="性能监控"><a href="#性能监控" class="headerlink" title="性能监控"></a>性能监控</h2><h3 id="show-profile-查询剖析工具"><a href="#show-profile-查询剖析工具" class="headerlink" title="show profile 查询剖析工具"></a>show profile 查询剖析工具</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">## https://dev.mysql.com/doc/refman/5.7/en/show-profile.html</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">profiles</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">## 开启 show profile 监控</span></span><br><span class="line"><span class="keyword">set</span> profiling=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">## 根据 Type 查询</span></span><br><span class="line"><span class="keyword">show</span> profile cpu <span class="keyword">for</span> <span class="keyword">query</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">show</span> profile <span class="keyword">all</span> <span class="keyword">for</span> <span class="keyword">query</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">## 未来有可能被移除，推荐使用 Performance Schema</span></span><br><span class="line">Note: </span><br><span class="line">The <span class="keyword">SHOW</span> PROFILE <span class="keyword">and</span> <span class="keyword">SHOW</span> <span class="keyword">PROFILES</span> statements <span class="keyword">are</span> deprecated <span class="keyword">and</span> will be removed <span class="keyword">in</span> a future MySQL release. </span><br><span class="line"><span class="keyword">Use</span> the <span class="keyword">Performance</span> <span class="keyword">Schema</span> instead; see Section 25.19.1, “Query Profiling Using Performance Schema”.</span><br><span class="line"></span><br><span class="line"><span class="comment">## 查看MySQL支持存储引擎类型</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">engines</span>;</span><br></pre></td></tr></table></figure><h3 id="Performance-Schema-库"><a href="#Performance-Schema-库" class="headerlink" title="Performance Schema 库"></a>Performance Schema 库</h3><p>5.7 新提供自带监控数据库，有 87 张数据表。</p><p><a href="https://dev.mysql.com/doc/refman/5.7/en/performance-schema.html" target="_blank" rel="noopener">MySQL Performance Schema</a></p><h3 id="使用-show-processlist-查看连接"><a href="#使用-show-processlist-查看连接" class="headerlink" title="使用 show processlist 查看连接"></a>使用 show processlist 查看连接</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">processlist</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'%max_connection%'</span>;</span><br></pre></td></tr></table></figure><h2 id="schema-与数据类型优化"><a href="#schema-与数据类型优化" class="headerlink" title="schema 与数据类型优化"></a>schema 与数据类型优化</h2><h3 id="数据类型优化"><a href="#数据类型优化" class="headerlink" title="数据类型优化"></a>数据类型优化</h3><ul><li>更小的通常更好</li><li>简单就好<ul><li>整型比字符类型代价更低</li><li>使用MySQL自带类型而不是字符串类型还存储日期和时间</li><li>用整型存储IP地址</li></ul></li></ul><ul><li>尽量避免 null</li><li>实际细则</li></ul><h3 id="索引优化细节"><a href="#索引优化细节" class="headerlink" title="索引优化细节"></a>索引优化细节</h3><ul><li><p>当使用索引列进行查询的时候尽量不要使用表达式，把计算放到业务层而不是数据层（表达式会导致索引失效）；</p></li><li><p>尽量使用主键查询，而不是其它索引，因为主键查询不会触发回表查询，减少 IO 次数；</p></li><li><p>使用前缀索引，前缀索引可以减少空间占用；</p></li><li><p>使用索引扫描来排序；</p></li><li><p>union all，in，or 都能够使用索引，但是推荐使用 in；</p></li><li><p>范围列可以用到索引；</p></li><li><p>强制类型转换会导致全表扫描，即索引失效；</p></li><li><p>更新十分频繁，数据区分度不高的字段上不宜建立索引；</p></li><li><p>创建索引的列，不允许为 null，可能会得到不符合预期的结果（null != null）；</p></li><li><p>当需要进行表连接的时候，最好不要超过三张表，因为需要 join 的字段，数据类型必须一致；</p></li><li><p>能使用 limit 的时候尽量使用 limit，减少后续查询操作（limit 1）；</p></li><li><p>单表索引建议控制在 5 个以内；</p></li><li><p>单索引字段数不允许超过 5 个（组合索引字段个数）；</p></li><li><p>创建索引的时候需要避免的错误概念：1、索引越多越好；2、过早优化，在不了解系统的情况下进行优化。</p></li></ul><h2 id="MySQL-执行计划"><a href="#MySQL-执行计划" class="headerlink" title="MySQL 执行计划"></a>MySQL 执行计划</h2><p>​在企业的应用场景中，为了知道优化SQL语句的执行，需要查看SQL语句的具体执行过程，以加快SQL语句的执行效率。</p><p>可以使用 explain + SQL 语句来模拟优化器执行 SQL 查询语句，从而知道 MySQL 是如何处理 SQL 语句的。</p><p>​<a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html" target="_blank" rel="noopener">EXPLAIN Output Format</a></p><h3 id="执行计划中包含的信息"><a href="#执行计划中包含的信息" class="headerlink" title="执行计划中包含的信息"></a>执行计划中包含的信息</h3><table><thead><tr><th align="center">Column</th><th align="center">Meaning</th></tr></thead><tbody><tr><td align="center">id</td><td align="center">The <code>SELECT</code> identifier</td></tr><tr><td align="center">select_type</td><td align="center">The <code>SELECT</code> type</td></tr><tr><td align="center">table</td><td align="center">The table for the output row</td></tr><tr><td align="center">partitions</td><td align="center">The matching partitions</td></tr><tr><td align="center">type</td><td align="center">The join type</td></tr><tr><td align="center">possible_keys</td><td align="center">The possible indexes to choose</td></tr><tr><td align="center">key</td><td align="center">The index actually chosen</td></tr><tr><td align="center">key_len</td><td align="center">The length of the chosen key</td></tr><tr><td align="center">ref</td><td align="center">The columns compared to the index</td></tr><tr><td align="center">rows</td><td align="center">Estimate of rows to be examined</td></tr><tr><td align="center">filtered</td><td align="center">Percentage of rows filtered by table condition</td></tr><tr><td align="center">extra</td><td align="center">Additional information</td></tr></tbody></table><p><strong>id</strong></p><p>select 查询的序列号，包含一组数字，表示查询中执行 select 子句或者操作表的顺序</p><p>id 号分为三种情况：</p><p>​1、如果 id 相同，那么执行顺序从上到下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp e <span class="keyword">join</span> dept d <span class="keyword">on</span> e.deptno = d.deptno <span class="keyword">join</span> salgrade sg <span class="keyword">on</span> e.sal <span class="keyword">between</span> sg.losal <span class="keyword">and</span> sg.hisal;</span><br></pre></td></tr></table></figure><p>​2、如果 id 不同，如果是子查询，id 的序号会递增，id 值越大优先级越高，越先被执行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp e <span class="keyword">where</span> e.deptno <span class="keyword">in</span> (<span class="keyword">select</span> d.deptno <span class="keyword">from</span> dept d <span class="keyword">where</span> d.dname = <span class="string">'SALES'</span>);</span><br></pre></td></tr></table></figure><p>3、id 相同和不同的，同时存在：相同的可以认为是一组，从上往下顺序执行，在所有组中，id 值越大，优先级越高，越先执行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp e <span class="keyword">join</span> dept d <span class="keyword">on</span> e.deptno = d.deptno <span class="keyword">join</span> salgrade sg <span class="keyword">on</span> e.sal <span class="keyword">between</span> sg.losal <span class="keyword">and</span> sg.hisal <span class="keyword">where</span> e.deptno <span class="keyword">in</span> (<span class="keyword">select</span> d.deptno <span class="keyword">from</span> dept d <span class="keyword">where</span> d.dname = <span class="string">'SALES'</span>);</span><br></pre></td></tr></table></figure><p><strong>select_type</strong></p><p>主要用来分辨查询的类型，是普通查询还是联合查询还是子查询</p><table><thead><tr><th align="center"><code>select_type</code> Value</th><th align="center">Meaning</th></tr></thead><tbody><tr><td align="center">SIMPLE</td><td align="center">Simple SELECT (not using UNION or subqueries)</td></tr><tr><td align="center">PRIMARY</td><td align="center">Outermost SELECT</td></tr><tr><td align="center">UNION</td><td align="center">Second or later SELECT statement in a UNION</td></tr><tr><td align="center">DEPENDENT UNION</td><td align="center">Second or later SELECT statement in a UNION, dependent on outer query</td></tr><tr><td align="center">UNION RESULT</td><td align="center">Result of a UNION.</td></tr><tr><td align="center">SUBQUERY</td><td align="center">First SELECT in subquery</td></tr><tr><td align="center">DEPENDENT SUBQUERY</td><td align="center">First SELECT in subquery, dependent on outer query</td></tr><tr><td align="center">DERIVED</td><td align="center">Derived table</td></tr><tr><td align="center">UNCACHEABLE SUBQUERY</td><td align="center">A subquery for which the result cannot be cached and must be re-evaluated for each row of the outer query</td></tr><tr><td align="center">UNCACHEABLE UNION</td><td align="center">The second or later select in a UNION that belongs to an uncacheable subquery (see UNCACHEABLE SUBQUERY)</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--sample:简单的查询，不包含子查询和union</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp;</span><br><span class="line"></span><br><span class="line"><span class="comment">--primary:查询中若包含任何复杂的子查询，最外层查询则被标记为Primary</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> staname,ename supname <span class="keyword">from</span> (<span class="keyword">select</span> ename staname,mgr <span class="keyword">from</span> emp) t <span class="keyword">join</span> emp <span class="keyword">on</span> t.mgr=emp.empno ;</span><br><span class="line"></span><br><span class="line"><span class="comment">--union:若第二个select出现在union之后，则被标记为union</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> deptno = <span class="number">10</span> <span class="keyword">union</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> sal &gt;<span class="number">2000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--dependent union:跟union类似，此处的depentent表示union或union all联合而成的结果会受外部表影响</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp e <span class="keyword">where</span> e.empno  <span class="keyword">in</span> ( <span class="keyword">select</span> empno <span class="keyword">from</span> emp <span class="keyword">where</span> deptno = <span class="number">10</span> <span class="keyword">union</span> <span class="keyword">select</span> empno <span class="keyword">from</span> emp <span class="keyword">where</span> sal &gt;<span class="number">2000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">--union result:从union表获取结果的select</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> deptno = <span class="number">10</span> <span class="keyword">union</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> sal &gt;<span class="number">2000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--subquery:在select或者where列表中包含子查询</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> sal &gt; (<span class="keyword">select</span> <span class="keyword">avg</span>(sal) <span class="keyword">from</span> emp) ;</span><br><span class="line"></span><br><span class="line"><span class="comment">--dependent subquery:subquery的子查询要受到外部表查询的影响</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp e <span class="keyword">where</span> e.deptno <span class="keyword">in</span> (<span class="keyword">select</span> <span class="keyword">distinct</span> deptno <span class="keyword">from</span> dept);</span><br><span class="line"></span><br><span class="line"><span class="comment">--DERIVED: from子句中出现的子查询，也叫做派生类，</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> staname,ename supname <span class="keyword">from</span> (<span class="keyword">select</span> ename staname,mgr <span class="keyword">from</span> emp) t <span class="keyword">join</span> emp <span class="keyword">on</span> t.mgr=emp.empno ;</span><br><span class="line"></span><br><span class="line"><span class="comment">--UNCACHEABLE SUBQUERY：表示使用子查询的结果不能被缓存</span></span><br><span class="line"> <span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> empno = (<span class="keyword">select</span> empno <span class="keyword">from</span> emp <span class="keyword">where</span> deptno=@@sort_buffer_size);</span><br><span class="line"> </span><br><span class="line"><span class="comment">--uncacheable union:表示union的查询结果不能被缓存：sql语句未验证</span></span><br></pre></td></tr></table></figure><p><strong>table</strong></p><p>对应行正在访问哪一个表，表名或者别名，可能是临时表或者 union 合并结果集</p><p>1、如果是具体的表名，则表明从实际的物理表中获取数据，当然也可以是表的别名</p><p>2、表名是 derivedN 的形式，表示使用了 id 为 N 的查询产生的衍生表</p><p>3、当有 union result 的时候，表名是 union n1,n2 等的形式，n1,n2 表示参与 union 的 id</p><p><strong>type</strong></p><p>type 显示的是访问类型，访问类型表示我是以何种方式去访问我们的数据，最容易想的是全表扫描，直接暴力的遍历一张表去寻找需要的数据，效率非常低下，访问的类型有很多，效率从最好到最坏依次是：</p><p>system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL </p><p>一般情况下，得保证查询至少达到 range 级别，最好能达到 ref</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--all:全表扫描，一般情况下出现这样的sql语句而且数据量比较大的话那么就需要进行优化。</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp;</span><br><span class="line"></span><br><span class="line"><span class="comment">--index：全索引扫描这个比all的效率要好，主要有两种情况，一种是当前的查询时覆盖索引，即我们需要的数据在索引中就可以索取，或者是使用了索引进行排序，这样就避免数据的重排序</span></span><br><span class="line"><span class="keyword">explain</span>  <span class="keyword">select</span> empno <span class="keyword">from</span> emp;</span><br><span class="line"></span><br><span class="line"><span class="comment">--range：表示利用索引查询的时候限制了范围，在指定范围内进行查询，这样避免了index的全索引扫描，适用的操作符： =, &lt;&gt;, &gt;, &gt;=, &lt;, &lt;=, IS NULL, BETWEEN, LIKE, or IN() </span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> empno <span class="keyword">between</span> <span class="number">7000</span> <span class="keyword">and</span> <span class="number">7500</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--index_subquery：利用索引来关联子查询，不再扫描全表</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> emp.job <span class="keyword">in</span> (<span class="keyword">select</span> job <span class="keyword">from</span> t_job);</span><br><span class="line"></span><br><span class="line"><span class="comment">--unique_subquery:该连接类型类似与index_subquery,使用的是唯一索引</span></span><br><span class="line"> <span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp e <span class="keyword">where</span> e.deptno <span class="keyword">in</span> (<span class="keyword">select</span> <span class="keyword">distinct</span> deptno <span class="keyword">from</span> dept);</span><br><span class="line"> </span><br><span class="line"><span class="comment">--index_merge：在查询过程中需要多个索引组合使用，没有模拟出来</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--ref_or_null：对于某个字段即需要关联条件，也需要null值的情况下，查询优化器会选择这种访问方式</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp e <span class="keyword">where</span>  e.mgr <span class="keyword">is</span> <span class="literal">null</span> <span class="keyword">or</span> e.mgr=<span class="number">7369</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--ref：使用了非唯一性索引进行数据的查找</span></span><br><span class="line"> <span class="keyword">create</span> <span class="keyword">index</span> idx_3 <span class="keyword">on</span> emp(deptno);</span><br><span class="line"> <span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp e,dept d <span class="keyword">where</span> e.deptno =d.deptno;</span><br><span class="line"></span><br><span class="line"><span class="comment">--eq_ref ：使用唯一性索引进行数据查找</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp,emp2 <span class="keyword">where</span> emp.empno = emp2.empno;</span><br><span class="line"></span><br><span class="line"><span class="comment">--const：这个表至多有一个匹配行，</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> empno = <span class="number">7369</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">--system：表只有一行记录（等于系统表），这是const类型的特例，平时不会出现</span></span><br></pre></td></tr></table></figure><p> <strong>possible_keys</strong> </p><p>显示可能应用在这张表中的索引，一个或多个，查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询实际使用</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp,dept <span class="keyword">where</span> emp.deptno = dept.deptno <span class="keyword">and</span> emp.deptno = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p><strong>key</strong></p><p>实际使用的索引，如果为 null，则没有使用索引，查询中若使用了覆盖索引，则该索引和查询的 select 字段重叠。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp,dept <span class="keyword">where</span> emp.deptno = dept.deptno <span class="keyword">and</span> emp.deptno = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p><strong>key_len</strong></p><p>表示索引中使用的字节数，可以通过 key_len 计算查询中使用的索引长度，在不损失精度的情况下长度越短越好。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp,dept <span class="keyword">where</span> emp.deptno = dept.deptno <span class="keyword">and</span> emp.deptno = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p><strong>ref</strong></p><p>显示索引的哪一列被使用了，如果可能的话，是一个常数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp,dept <span class="keyword">where</span> emp.deptno = dept.deptno <span class="keyword">and</span> emp.deptno = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p><strong>rows</strong></p><p>根据表的统计信息及索引使用情况，大致估算出找出所需记录需要读取的行数，此参数很重要，直接反应的 SQL 找了多少数据，在完成目的的情况下越少越好</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp;</span><br></pre></td></tr></table></figure><p><strong>extra</strong></p><p>包含额外的信息。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--using filesort:说明mysql无法利用索引进行排序，只能利用排序算法进行排序，会消耗额外的位置</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">order</span> <span class="keyword">by</span> sal;</span><br><span class="line"></span><br><span class="line"><span class="comment">--using temporary:建立临时表来保存中间结果，查询完成之后把临时表删除</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> ename,<span class="keyword">count</span>(*) <span class="keyword">from</span> emp <span class="keyword">where</span> deptno = <span class="number">10</span> <span class="keyword">group</span> <span class="keyword">by</span> ename;</span><br><span class="line"></span><br><span class="line"><span class="comment">--using index:这个表示当前的查询时覆盖索引的，直接从索引中读取数据，而不用访问数据表。如果同时出现using where 表名索引被用来执行索引键值的查找，如果没有，表面索引被用来读取数据，而不是真的查找</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> deptno,<span class="keyword">count</span>(*) <span class="keyword">from</span> emp <span class="keyword">group</span> <span class="keyword">by</span> deptno <span class="keyword">limit</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--using where:使用where进行条件过滤</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> t_user <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--using join buffer:使用连接缓存，情况没有模拟出来</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--impossible where：where语句的结果总是false</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> empno = <span class="number">7469</span>;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://zhenganwen.top/posts/433a3305/" target="_blank" rel="noopener">MySQL优化面试</a></li><li><a href="http://tigcms.jd.com/details/HkO5QrfPQ.html" target="_blank" rel="noopener">MySQL explain详解</a></li><li><a href="http://tigcms.jd.com/details/ryG-r2dM7.html" target="_blank" rel="noopener">MySQL数据库开发规范</a></li><li><a href="https://tech.meituan.com/2014/06/30/mysql-index.html" target="_blank" rel="noopener">MySQL索引原理及慢查询优化</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;性能监控&quot;&gt;&lt;a href=&quot;#性能监控&quot; class=&quot;headerlink&quot; title=&quot;性能监控&quot;&gt;&lt;/a&gt;性能监控&lt;/h2&gt;&lt;h3 id=&quot;show-profile-查询剖析工具&quot;&gt;&lt;a href=&quot;#show-profile-查询剖析工具&quot; class
      
    
    </summary>
    
    
      <category term="数据库" scheme="https://dongzl.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MySQL" scheme="https://dongzl.github.io/tags/MySQL/"/>
    
      <category term="调优" scheme="https://dongzl.github.io/tags/%E8%B0%83%E4%BC%98/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 数据库索引的实现原理</title>
    <link href="https://dongzl.github.io/2020/03/14/10-The-Implementation-Principles-Of-MySQL-Index/"/>
    <id>https://dongzl.github.io/2020/03/14/10-The-Implementation-Principles-Of-MySQL-Index/</id>
    <published>2020-03-14T05:52:04.000Z</published>
    <updated>2020-04-09T03:08:42.566Z</updated>
    
    <content type="html"><![CDATA[<h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><blockquote><p>1、MySQL 数据库索引分类。<br>2、MySQL 数据库 InnoDB 存储引擎的底层数据结构。<br>3、为什么底层使用 B+ 树而不用 B 树</p></blockquote><h2 id="MySQL-架构"><a href="#MySQL-架构" class="headerlink" title="MySQL 架构"></a>MySQL 架构</h2><img src="https://gitee.com/dongzl/article-images/raw/master/2020/10-The-Implementation-Principles-Of-MySQL-Index/The-Implementation-Principles-Of-MySQL-Index-03.png"><h2 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h2><p>MySQL 索引分五种类型：主键索引、唯一索引、普通索引和全文索引、组合索引。通过给字段添加索引可以提高数据的读取速度，提高项目的并发能力和抗压能力。</p><ul><li><p>主键索引：主键是一种唯一性索引，但它必须指定为 PRIMARY KEY，每个表只能有一个主键；</p></li><li><p>唯一索引：索引列的所有值都只能出现一次，即必须唯一，但是值可以为空；</p></li><li><p>普通索引：基本的索引类型，值可以为空，没有唯一性的限制；</p></li><li><p>全文索引：全文索引的索引类型为 FULLTEXT，全文索引可以在 varchar、char、text 类型的列上创建；（使用较少，一般都使用专门的搜索框架，例如 ElasticSearch）</p></li><li><p>组合索引：多列值组成一个索引，专门用于组合搜索。</p></li></ul><h2 id="MySQL-索引实现原理分析"><a href="#MySQL-索引实现原理分析" class="headerlink" title="MySQL 索引实现原理分析"></a>MySQL 索引实现原理分析</h2><p><strong>为什么没有使用 Hash 表的索引格式</strong></p><p>使用类似于 JDK 中 HashMap 的数据结构来存储索引数据，有如下特点：</p><ul><li><p>优点：查询速度快，Hash 数据结构查询时间复杂度为 O(1);</p></li><li><p>缺点：</p><ul><li>1、需要将数据文件 load 到内存，比较耗费内存空间；</li><li>2、Hash 快速查询只适合等值查询，对于范围查询效率低下，在实际工作中范围查询的场景比较多。</li></ul></li></ul><p><strong>为什么没有使用二叉树和红黑树索引格式</strong></p><p>无论是二叉树还是红黑树，都会因为树的深度过深而造成 IO 次数变多，影响数据读取效率。</p><p><strong>为什么没有使用 B 树索引格式</strong></p><p>B 树特点：</p><p>1、所有键值分布在整棵树中；<br>2、搜索有可能在非叶子节点结束，在关键字全集内做一次查找，性能逼近二分查找；<br>3、每个节点最多拥有 m 个子树；<br>4、根节点至少有 2 个子树；<br>5、分支节点至少拥有 m / 2 棵子树（除根节点和叶子节点外都是分支节点）；<br>6、所有叶子节点都在同一层、每个节点最多可以有 m - 1 个 key，并且以升序排列。</p><p>B 树缺点：</p><ul><li><p>每个节点都有 key，同时也包含 data，而每个页存储空间是有限的，如果 data 比较大的话会导致每个节点存储的 key 数量变小；</p></li><li><p>当存储的数据量很大的时候会导致深度较大，增大查询时磁盘 IO 次数，进而影响查询性能。</p></li></ul><img src="https://gitee.com/dongzl/article-images/raw/master/2020/10-The-Implementation-Principles-Of-MySQL-Index/The-Implementation-Principles-Of-MySQL-Index-01.png"><p><strong>MySQL B+ 树索引格式实现原理</strong></p><p>B+ 树是在 B 树的基础上做的一种优化，优化如下：</p><ul><li><p>B+ 树每个节点可以包含更多的节点（非叶子节点不在存储数据），这样做的原因有两个，第一是为了降低树的高度，第二个原因是将数据范围变为多个区间，区间越多，数据检索越快；</p></li><li><p>非叶子节点存储 key ，叶子节点存储 key 和数据；</p></li><li><p>叶子节点两两指针互相连接（符合磁盘的预读特性），顺序查询性能更高。</p></li></ul><p><strong>MySQL InnoDB–B+ 树，叶子节点直接存储数据</strong></p><ul><li><p>InnoDB 是通过 B+ 树结构对主键创建索引，在叶子节点中存储记录数据，如果没有主键，就选择唯一键，如果没有唯一键，那么会生成一个 6 位的 row_id 来作为主键；</p></li><li><p>如果创建索引的键是其他字段，那么在叶子节点中存储的是该记录的主键，然后在通过主键索引找到对应的记录，这个过程叫做回表。</p></li></ul><p><strong>MySQL MyISAM–B+ 树，叶子节点存储表中数据的地址</strong></p><img src="https://gitee.com/dongzl/article-images/raw/master/2020/10-The-Implementation-Principles-Of-MySQL-Index/The-Implementation-Principles-Of-MySQL-Index-02.png"><h2 id="MySQL-索引的一些其他内容"><a href="#MySQL-索引的一些其他内容" class="headerlink" title="MySQL 索引的一些其他内容"></a>MySQL 索引的一些其他内容</h2><h3 id="回表"><a href="#回表" class="headerlink" title="回表"></a>回表</h3><p>如果 MySQL 中的索引不是主键索引，在使用这个索引进行数据查询时，需要现在这个索引的 B+ 树中找到叶子节点存储的主键 ID，然后根据主键 ID 到主键索引的 B+ 树中查找到最终记录，这个过程就叫做回表。</p><h3 id="最左匹配原则"><a href="#最左匹配原则" class="headerlink" title="最左匹配原则"></a>最左匹配原则</h3><p>在创建联合索引时，如果在查询条件中包含索引的最左列，那么这个索引可以匹配到，如果不包含最左列，这个索引无法匹配，这个称做最左原则。</p><p>比如某个表有联合索引，索引字段为 (column1, column2)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a、<span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> column1 = <span class="string">'c1'</span> <span class="keyword">and</span> column2 = <span class="string">'c2'</span>;</span><br><span class="line"></span><br><span class="line">b、<span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> column2 = <span class="string">'c2'</span> <span class="keyword">and</span> column1 = <span class="string">'c1'</span>;</span><br><span class="line"></span><br><span class="line">c、<span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> column1 = <span class="string">'c1'</span>;</span><br><span class="line"></span><br><span class="line">d、<span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> column2 = <span class="string">'c2'</span>;</span><br></pre></td></tr></table></figure><p>上述 a、b、c 三个查询可以使用该索引，查询 d 无法使用该索引。</p><p>知识补充，如果上述四条SQL语句都希望走索引，需要创建两个索引：</p><p>组合索引: (column1, column2), 和 column2 单列索引；</p><p>或者是组合索引: (column2, column1), 和 column1 单列索引；</p><p>具体选择哪种方案，需要对比 column1、column2 字段类型，在满足查询优化情况尽量减少磁盘空间占用。</p><p>PS.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 范围查询只能用到 column2 列上索引，column2 上用不到</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> column1 &gt; <span class="string">'c1'</span> <span class="keyword">and</span> column2 = <span class="string">'c2'</span>;</span><br></pre></td></tr></table></figure><h3 id="索引覆盖"><a href="#索引覆盖" class="headerlink" title="索引覆盖"></a>索引覆盖</h3><p>如果索引中包含查询结果需要的全部字段，那么将不需要在回表查询该记录的所有数据，这个过程就是索引覆盖，覆盖索引在查询计划中表现为：<code>using index</code>。</p><h3 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h3><p>例如有 user_table 表，表上有 (user_name, age) 联合索引<br>如果现在有一个需求，查出名称中以“张”开头且年龄小于等于 10 的用户信息：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> user_table <span class="keyword">where</span> user_name <span class="keyword">like</span> <span class="string">'张%'</span> <span class="keyword">and</span> age &gt; <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>这条查询语句有两种执行可能：</p><ul><li><p>根据 (user_name, age) 联合索引查询所有满足名称以“张”开头的索引，然后回表查询出相应的全行数据，然后再筛选出满足年龄小于等于10的用户数据。</p></li><li><p>根据 (user_name, age) 联合索引查询所有满足名称以“张”开头的索引，然后直接再筛选出年龄小于等于10的索引，之后再回表查询全行数据。</p></li></ul><p>很明显，后一种方式需要回表查询的全行数据比较少，这就是 MySQL 的索引下推。</p><h3 id="聚簇索引与非聚簇索引"><a href="#聚簇索引与非聚簇索引" class="headerlink" title="聚簇索引与非聚簇索引"></a>聚簇索引与非聚簇索引</h3><p>聚簇索引并不是一种索引类型，而是一种数据存储方式，指的是数据行跟相邻的键值紧凑的存储在一起。费聚簇索引是指数据文件和索引文件分开存放。</p><p>MySQL 数据库中 InnoDB 存储引擎，B+ 树索引可以分为聚簇索引（也称聚集索引，clustered index）和辅助索引（有时也称非聚簇索引或二级索引，secondary index，non-clustered index）。这两种索引内部都是B+树，聚集索引的叶子节点存放着一整行的数据。</p><p>InnoDB 中的主键索引是一种聚簇索引，非聚簇索引都是辅助索引，像复合索引、前缀索引、唯一索引。</p><p>InnoDB 使用的是聚簇索引，MyISAM 使用的是非聚簇索引。</p><p><strong>聚簇索引的优缺点</strong>：</p><p>优点：</p><ul><li><p>数据访问更快，因为聚簇索引将索引和数据保存在同一个B+树中，因此从聚簇索引中获取数据比非聚簇索引更快；</p></li><li><p>聚簇索引对于主键的排序查找和范围查找速度非常快。</p></li></ul><p>缺点：</p><ul><li><p>插入速度严重依赖于插入顺序，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个自增的ID列为主键</p></li><li><p>更新主键的代价很高，因为将会导致被更新的行移动。因此，对于 InnoDB 表，我们一般定义主键为不可更新。</p></li><li><p>二级索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据。</p></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.jianshu.com/p/bdc9e57ccf8b" target="_blank" rel="noopener">MySQL 索引篇之覆盖索引、联合索引、索引下推</a></li><li><a href="https://blog.csdn.net/mccand1234/article/details/95799942" target="_blank" rel="noopener">索引下推（5.6版本+）</a></li><li><a href="https://zhenganwen.top/posts/433a3305/" target="_blank" rel="noopener">MySQL优化面试</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;面试题&quot;&gt;&lt;a href=&quot;#面试题&quot; class=&quot;headerlink&quot; title=&quot;面试题&quot;&gt;&lt;/a&gt;面试题&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;1、MySQL 数据库索引分类。&lt;br&gt;2、MySQL 数据库 InnoDB 存储引擎的底层数据结构。&lt;b
      
    
    </summary>
    
    
      <category term="数据库" scheme="https://dongzl.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MySQL" scheme="https://dongzl.github.io/tags/MySQL/"/>
    
      <category term="索引" scheme="https://dongzl.github.io/tags/%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
</feed>
