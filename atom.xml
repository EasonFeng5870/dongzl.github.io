<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>董宗磊的博客</title>
  
  <subtitle>董宗磊的博客--善积跬步，方以千里</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://dongzl.github.io/"/>
  <updated>2020-04-03T14:34:32.716Z</updated>
  <id>https://dongzl.github.io/</id>
  
  <author>
    <name>[object Object]</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>(转) Java 中锁实现原理以及锁升级过程</title>
    <link href="https://dongzl.github.io/2020/04/03/20-Mashibing-Synchronized-Volatile-CAS/"/>
    <id>https://dongzl.github.io/2020/04/03/20-Mashibing-Synchronized-Volatile-CAS/</id>
    <published>2020-04-03T13:55:43.000Z</published>
    <updated>2020-04-03T14:34:32.716Z</updated>
    
    <content type="html"><![CDATA[<h2 id="用户态与内核态"><a href="#用户态与内核态" class="headerlink" title="用户态与内核态"></a>用户态与内核态</h2><p>JDK1.0，synchronized 叫做重量级锁， 因为申请锁资源必须通过kernel, 系统调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">;hello.asm</span><br><span class="line">;write(int fd, const void *buffer, size_t nbytes)</span><br><span class="line"></span><br><span class="line">section data</span><br><span class="line">    msg db &quot;Hello&quot;, 0xA</span><br><span class="line">    len equ $ - msg</span><br><span class="line"></span><br><span class="line">section .text</span><br><span class="line">global _start</span><br><span class="line">_start:</span><br><span class="line"></span><br><span class="line">    mov edx, len</span><br><span class="line">    mov ecx, msg</span><br><span class="line">    mov ebx, 1 ;文件描述符1 std_out</span><br><span class="line">    mov eax, 4 ;write函数系统调用号 4</span><br><span class="line">    int 0x80</span><br><span class="line"></span><br><span class="line">    mov ebx, 0</span><br><span class="line">    mov eax, 1 ;exit函数系统调用号</span><br><span class="line">    int 0x80</span><br></pre></td></tr></table></figure><h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><p>Compare And Swap (Compare And Exchange) / 自旋 / 自旋锁 / 无锁 （无重量锁）</p><p>因为经常配合循环操作，直到完成为止，所以泛指一类操作</p><p>cas(v, a, b) ，变量v，期待值a, 修改值b</p><p>ABA问题，你的女朋友在离开你的这段儿时间经历了别的人，自旋就是你空转等待，一直等到她接纳你为止</p><p>解决办法（版本号 AtomicStampedReference），基础类型简单值不需要版本号</p><h1 id="Unsafe"><a href="#Unsafe" class="headerlink" title="Unsafe"></a>Unsafe</h1><p>AtomicInteger:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> current = get();</span><br><span class="line">        <span class="keyword">int</span> next = current + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSet(current, next))</span><br><span class="line">            <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Unsafe:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4, <span class="keyword">int</span> var5)</span></span>;</span><br></pre></td></tr></table></figure><p>运用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mashibing.jol;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sun.misc.Unsafe;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T02_TestUnsafe</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> T02_TestUnsafe t = <span class="keyword">new</span> T02_TestUnsafe();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//Unsafe unsafe = Unsafe.getUnsafe();</span></span><br><span class="line"></span><br><span class="line">        Field unsafeField = Unsafe.class.getDeclaredFields()[<span class="number">0</span>];</span><br><span class="line">        unsafeField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Unsafe unsafe = (Unsafe) unsafeField.get(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        Field f = T02_TestUnsafe.class.getDeclaredField(<span class="string">"i"</span>);</span><br><span class="line">        <span class="keyword">long</span> offset = unsafe.objectFieldOffset(f);</span><br><span class="line">        System.out.println(offset);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> success = unsafe.compareAndSwapInt(t, offset, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        System.out.println(success);</span><br><span class="line">        System.out.println(t.i);</span><br><span class="line">        <span class="comment">//unsafe.compareAndSwapInt()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>jdk8u: unsafe.cpp:</p><p>cmpxchg = compare and exchange</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSwapInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x))</span><br><span class="line">  UnsafeWrapper(<span class="string">"Unsafe_CompareAndSwapInt"</span>);</span><br><span class="line">  oop p = JNIHandles::resolve(obj);</span><br><span class="line">  jint* addr = (jint *) index_oop_from_field_offset_long(p, offset);</span><br><span class="line">  <span class="keyword">return</span> (jint)(Atomic::cmpxchg(x, addr, e)) == e;</span><br><span class="line">UNSAFE_END</span><br></pre></td></tr></table></figure><p>jdk8u: atomic_linux_x86.inline.hpp <strong>93行</strong></p><p>is_MP = Multi Processor  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> jint     Atomic::cmpxchg    (jint     exchange_value, <span class="keyword">volatile</span> jint*     dest, jint     compare_value) &#123;</span><br><span class="line">  <span class="keyword">int</span> mp = os::is_MP();</span><br><span class="line">  __<span class="function">asm__ <span class="title">volatile</span> <span class="params">(LOCK_IF_MP(%<span class="number">4</span>) <span class="string">"cmpxchgl %1,(%3)"</span></span></span></span><br><span class="line"><span class="function"><span class="params">                    : <span class="string">"=a"</span> (exchange_value)</span></span></span><br><span class="line"><span class="function"><span class="params">                    : <span class="string">"r"</span> (exchange_value), <span class="string">"a"</span> (compare_value), <span class="string">"r"</span> (dest), <span class="string">"r"</span> (mp)</span></span></span><br><span class="line"><span class="function"><span class="params">                    : <span class="string">"cc"</span>, <span class="string">"memory"</span>)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> exchange_value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>jdk8u: os.hpp is_MP()</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">is_MP</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// During bootstrap if _processor_count is not yet initialized</span></span><br><span class="line">    <span class="comment">// we claim to be MP as that is safest. If any platform has a</span></span><br><span class="line">    <span class="comment">// stub generator that might be triggered in this phase and for</span></span><br><span class="line">    <span class="comment">// which being declared MP when in fact not, is a problem - then</span></span><br><span class="line">    <span class="comment">// the bootstrap routine for the stub generator needs to check</span></span><br><span class="line">    <span class="comment">// the processor count directly and leave the bootstrap routine</span></span><br><span class="line">    <span class="comment">// in place until called after initialization has ocurred.</span></span><br><span class="line">    <span class="keyword">return</span> (_processor_count != <span class="number">1</span>) || AssumeMP;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>jdk8u: atomic_linux_x86.inline.hpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCK_IF_MP(mp) <span class="meta-string">"cmp $0, "</span> #mp <span class="meta-string">"; je 1f; lock; 1: "</span></span></span><br></pre></td></tr></table></figure><p>最终实现：</p><p>cmpxchg = cas修改变量值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock cmpxchg 指令</span><br></pre></td></tr></table></figure><p>硬件：</p><p>lock指令在执行后面指令的时候锁定一个北桥信号</p><p>（不采用锁总线的方式）</p><h2 id="markword"><a href="#markword" class="headerlink" title="markword"></a>markword</h2><h3 id="工具：JOL-Java-Object-Layout"><a href="#工具：JOL-Java-Object-Layout" class="headerlink" title="工具：JOL = Java Object Layout"></a>工具：JOL = Java Object Layout</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.openjdk.jol/jol-core --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jol<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jol-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>jdk8u: markOop.hpp</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bit-format of an object header (most significant first, big endian layout below):</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  32 bits:</span></span><br><span class="line"><span class="comment">//  --------</span></span><br><span class="line"><span class="comment">//             hash:25 ------------&gt;| age:4    biased_lock:1 lock:2 (normal object)</span></span><br><span class="line"><span class="comment">//             JavaThread*:23 epoch:2 age:4    biased_lock:1 lock:2 (biased object)</span></span><br><span class="line"><span class="comment">//             size:32 ------------------------------------------&gt;| (CMS free block)</span></span><br><span class="line"><span class="comment">//             PromotedObject*:29 ----------&gt;| promo_bits:3 -----&gt;| (CMS promoted object)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  64 bits:</span></span><br><span class="line"><span class="comment">//  --------</span></span><br><span class="line"><span class="comment">//  unused:25 hash:31 --&gt;| unused:1   age:4    biased_lock:1 lock:2 (normal object)</span></span><br><span class="line"><span class="comment">//  JavaThread*:54 epoch:2 unused:1   age:4    biased_lock:1 lock:2 (biased object)</span></span><br><span class="line"><span class="comment">//  PromotedObject*:61 ---------------------&gt;| promo_bits:3 -----&gt;| (CMS promoted object)</span></span><br><span class="line"><span class="comment">//  size:64 -----------------------------------------------------&gt;| (CMS free block)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  unused:25 hash:31 --&gt;| cms_free:1 age:4    biased_lock:1 lock:2 (COOPs &amp;&amp; normal object)</span></span><br><span class="line"><span class="comment">//  JavaThread*:54 epoch:2 cms_free:1 age:4    biased_lock:1 lock:2 (COOPs &amp;&amp; biased object)</span></span><br><span class="line"><span class="comment">//  narrowOop:32 unused:24 cms_free:1 unused:4 promo_bits:3 -----&gt;| (COOPs &amp;&amp; CMS promoted object)</span></span><br><span class="line"><span class="comment">//  unused:21 size:35 --&gt;| cms_free:1 unused:7 ------------------&gt;| (COOPs &amp;&amp; CMS free block)</span></span><br></pre></td></tr></table></figure><h2 id="synchronized的横切面详解"><a href="#synchronized的横切面详解" class="headerlink" title="synchronized的横切面详解"></a>synchronized的横切面详解</h2><ol><li>synchronized原理</li><li>升级过程</li><li>汇编实现</li><li>vs reentrantLock的区别</li></ol><h3 id="java源码层级"><a href="#java源码层级" class="headerlink" title="java源码层级"></a>java源码层级</h3><p>synchronized(o) </p><h3 id="字节码层级"><a href="#字节码层级" class="headerlink" title="字节码层级"></a>字节码层级</h3><p>monitorenter moniterexit</p><h3 id="JVM层级（Hotspot）"><a href="#JVM层级（Hotspot）" class="headerlink" title="JVM层级（Hotspot）"></a>JVM层级（Hotspot）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mashibing.insidesync;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.openjdk.jol.info.ClassLayout;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T01_Sync1</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Object o = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">        System.out.println(ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">com.mashibing.insidesync.T01_Sync1$Lock object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      <span class="number">0</span>     <span class="number">4</span>   (object header)  <span class="number">05</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000101</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">5</span>)</span><br><span class="line">      <span class="number">4</span>     <span class="number">4</span>   (object header)  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">0</span>)</span><br><span class="line">      <span class="number">8</span>     <span class="number">4</span>   (object header)  <span class="number">49</span> ce <span class="number">00</span> <span class="number">20</span> (<span class="number">01001001</span> <span class="number">11001110</span> <span class="number">00000000</span> <span class="number">00100000</span>) (<span class="number">536923721</span>)</span><br><span class="line">     <span class="number">12</span>     <span class="number">4</span>        (loss due to the next object alignment)</span><br><span class="line">Instance size: <span class="number">16</span> bytes</span><br><span class="line">Space losses: <span class="number">0</span> bytes internal + <span class="number">4</span> bytes external = <span class="number">4</span> bytes total</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">com.mashibing.insidesync.T02_Sync2$Lock object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      <span class="number">0</span>     <span class="number">4</span>   (object header)  <span class="number">05</span> <span class="number">90</span> <span class="number">2</span>e <span class="number">1</span>e (<span class="number">00000101</span> <span class="number">10010000</span> <span class="number">00101110</span> <span class="number">00011110</span>) (<span class="number">506368005</span>)</span><br><span class="line">      <span class="number">4</span>     <span class="number">4</span>   (object header)  <span class="number">1</span>b <span class="number">02</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00011011</span> <span class="number">00000010</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">539</span>)</span><br><span class="line">      <span class="number">8</span>     <span class="number">4</span>   (object header)  <span class="number">49</span> ce <span class="number">00</span> <span class="number">20</span> (<span class="number">01001001</span> <span class="number">11001110</span> <span class="number">00000000</span> <span class="number">00100000</span>) (<span class="number">536923721</span>)</span><br><span class="line">     <span class="number">12</span>     <span class="number">4</span>        (loss due to the next object alignment)</span><br><span class="line">Instance size: <span class="number">16</span> bytes</span><br><span class="line">Space losses: <span class="number">0</span> bytes internal + <span class="number">4</span> bytes external = <span class="number">4</span> bytes tota</span><br></pre></td></tr></table></figure><p>InterpreterRuntime:: monitorenter方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">IRT_ENTRY_NO_ASYNC(<span class="keyword">void</span>, InterpreterRuntime::monitorenter(JavaThread* thread, BasicObjectLock* elem))</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ASSERT</span></span><br><span class="line">  thread-&gt;last_frame().interpreter_frame_verify_monitor(elem);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">if</span> (PrintBiasedLockingStatistics) &#123;</span><br><span class="line">    Atomic::inc(BiasedLocking::slow_path_entry_count_addr());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">Handle <span class="title">h_obj</span><span class="params">(thread, elem-&gt;obj())</span></span>;</span><br><span class="line">  assert(Universe::heap()-&gt;is_in_reserved_or_null(h_obj()),</span><br><span class="line">         <span class="string">"must be NULL or an object"</span>);</span><br><span class="line">  <span class="keyword">if</span> (UseBiasedLocking) &#123;</span><br><span class="line">    <span class="comment">// Retry fast entry if bias is revoked to avoid unnecessary inflation</span></span><br><span class="line">    ObjectSynchronizer::fast_enter(h_obj, elem-&gt;lock(), <span class="literal">true</span>, CHECK);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ObjectSynchronizer::slow_enter(h_obj, elem-&gt;lock(), CHECK);</span><br><span class="line">  &#125;</span><br><span class="line">  assert(Universe::heap()-&gt;is_in_reserved_or_null(elem-&gt;obj()),</span><br><span class="line">         <span class="string">"must be NULL or an object"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ASSERT</span></span><br><span class="line">  thread-&gt;last_frame().interpreter_frame_verify_monitor(elem);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">IRT_END</span><br></pre></td></tr></table></figure><p>synchronizer.cpp</p><p>revoke_and_rebias</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> ObjectSynchronizer::fast_enter(Handle obj, BasicLock* lock, <span class="keyword">bool</span> attempt_rebias, TRAPS) &#123;</span><br><span class="line"> <span class="keyword">if</span> (UseBiasedLocking) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!SafepointSynchronize::is_at_safepoint()) &#123;</span><br><span class="line">      BiasedLocking::Condition cond = BiasedLocking::revoke_and_rebias(obj, attempt_rebias, THREAD);</span><br><span class="line">      <span class="keyword">if</span> (cond == BiasedLocking::BIAS_REVOKED_AND_REBIASED) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      assert(!attempt_rebias, <span class="string">"can not rebias toward VM thread"</span>);</span><br><span class="line">      BiasedLocking::revoke_at_safepoint(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    assert(!obj-&gt;mark()-&gt;has_bias_pattern(), <span class="string">"biases should be revoked by now"</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> slow_enter (obj, lock, THREAD) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> ObjectSynchronizer::slow_enter(Handle obj, BasicLock* lock, TRAPS) &#123;</span><br><span class="line">  markOop mark = obj-&gt;mark();</span><br><span class="line">  assert(!mark-&gt;has_bias_pattern(), <span class="string">"should not see bias pattern here"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mark-&gt;is_neutral()) &#123;</span><br><span class="line">    <span class="comment">// Anticipate successful CAS -- the ST of the displaced mark must</span></span><br><span class="line">    <span class="comment">// be visible &lt;= the ST performed by the CAS.</span></span><br><span class="line">    lock-&gt;set_displaced_header(mark);</span><br><span class="line">    <span class="keyword">if</span> (mark == (markOop) Atomic::cmpxchg_ptr(lock, obj()-&gt;mark_addr(), mark)) &#123;</span><br><span class="line">      TEVENT (slow_enter: release stacklock) ;</span><br><span class="line">      <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Fall through to inflate() ...</span></span><br><span class="line">  &#125; <span class="keyword">else</span></span><br><span class="line">  <span class="keyword">if</span> (mark-&gt;has_locker() &amp;&amp; THREAD-&gt;is_lock_owned((address)mark-&gt;locker())) &#123;</span><br><span class="line">    assert(lock != mark-&gt;locker(), <span class="string">"must not re-lock the same lock"</span>);</span><br><span class="line">    assert(lock != (BasicLock*)obj-&gt;mark(), <span class="string">"don't relock with same BasicLock"</span>);</span><br><span class="line">    lock-&gt;set_displaced_header(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">  <span class="comment">// The following optimization isn't particularly useful.</span></span><br><span class="line">  <span class="keyword">if</span> (mark-&gt;has_monitor() &amp;&amp; mark-&gt;monitor()-&gt;is_entered(THREAD)) &#123;</span><br><span class="line">    lock-&gt;set_displaced_header (<span class="literal">NULL</span>) ;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// The object header will never be displaced to this lock,</span></span><br><span class="line">  <span class="comment">// so it does not matter what the value is, except that it</span></span><br><span class="line">  <span class="comment">// must be non-zero to avoid looking like a re-entrant lock,</span></span><br><span class="line">  <span class="comment">// and must not look locked either.</span></span><br><span class="line">  lock-&gt;set_displaced_header(markOopDesc::unused_mark());</span><br><span class="line">  ObjectSynchronizer::inflate(THREAD, obj())-&gt;enter(THREAD);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>inflate方法：膨胀为重量级锁</p><h2 id="锁升级过程"><a href="#锁升级过程" class="headerlink" title="锁升级过程"></a>锁升级过程</h2><h3 id="JDK8-markword实现表："><a href="#JDK8-markword实现表：" class="headerlink" title="JDK8 markword实现表："></a>JDK8 markword实现表：</h3><img src="https://gitee.com/dongzl/article-images/raw/master/2020/20-Mashibing-Synchronized-Volatile-CAS/Mashibing-Synchronized-Volatile-CAS-01.png"><p>new - 偏向锁 - 轻量级锁 （无锁, 自旋锁，自适应自旋）- 重量级锁</p><p>synchronized优化的过程和markword息息相关</p><p>用markword中最低的三位代表锁状态 其中1位是偏向锁位 两位是普通锁位</p><ol><li><p>Object o = new Object()<br>锁 = 0 01 无锁态<br>注意：如果偏向锁打开，默认是匿名偏向状态</p></li><li><p>o.hashCode()<br>001 + hashcode</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000001</span> <span class="number">10101101</span> <span class="number">00110100</span> <span class="number">00110110</span></span><br><span class="line"><span class="number">01011001</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br></pre></td></tr></table></figure><p>little endian big endian </p><p>00000000 00000000 00000000 01011001 00110110 00110100 10101101 00000000</p></li><li><p>默认synchronized(o)<br>00 -&gt; 轻量级锁<br>默认情况 偏向锁有个时延，默认是4秒<br>why? 因为JVM虚拟机自己有一些默认启动的线程，里面有好多sync代码，这些sync代码启动时就知道肯定会有竞争，如果使用偏向锁，就会造成偏向锁不断的进行锁撤销和锁升级的操作，效率较低。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:BiasedLockingStartupDelay=0</span><br></pre></td></tr></table></figure></li><li><p>如果设定上述参数<br>new Object () - &gt; 101 偏向锁 -&gt;线程ID为0 -&gt; Anonymous BiasedLock<br>打开偏向锁，new出来的对象，默认就是一个可偏向匿名对象101</p></li><li><p>如果有线程上锁<br>上偏向锁，指的就是，把markword的线程ID改为自己线程ID的过程<br>偏向锁不可重偏向 批量偏向 批量撤销</p></li><li><p>如果有线程竞争<br>撤销偏向锁，升级轻量级锁<br>线程在自己的线程栈生成LockRecord ，用CAS操作将markword设置为指向自己这个线程的LR的指针，设置成功者得到锁</p></li><li><p>如果竞争加剧<br>竞争加剧：有线程超过10次自旋， -XX:PreBlockSpin， 或者自旋线程数超过CPU核数的一半， 1.6之后，加入自适应自旋 Adapative Self Spinning ， JVM自己控制<br>升级重量级锁：-&gt; 向操作系统申请资源，linux mutex , CPU从3级-0级系统调用，线程挂起，进入等待队列，等待操作系统的调度，然后再映射回用户空间</p></li></ol><p>(以上实验环境是JDK11，打开就是偏向锁，而JDK8默认对象头是无锁)</p><p>偏向锁默认是打开的，但是有一个时延，如果要观察到偏向锁，应该设定参数</p><p><strong>如果计算过对象的hashCode，则对象无法进入偏向状态！</strong></p><blockquote><p>轻量级锁重量级锁的hashCode存在与什么地方？</p><p>答案：线程栈中，轻量级锁的LR中，或是代表重量级锁的ObjectMonitor的成员中</p></blockquote><p>关于epoch: (不重要)</p><blockquote><p><strong>批量重偏向与批量撤销</strong>渊源：从偏向锁的加锁解锁过程中可看出，当只有一个线程反复进入同步块时，偏向锁带来的性能开销基本可以忽略，但是当有其他线程尝试获得锁时，就需要等到safe point时，再将偏向锁撤销为无锁状态或升级为轻量级，会消耗一定的性能，所以在多线程竞争频繁的情况下，偏向锁不仅不能提高性能，还会导致性能下降。于是，就有了批量重偏向与批量撤销的机制。</p><p><strong>原理</strong>以class为单位，为每个class维护<strong>解决场景</strong>批量重偏向（bulk rebias）机制是为了解决：一个线程创建了大量对象并执行了初始的同步操作，后来另一个线程也来将这些对象作为锁对象进行操作，这样会导致大量的偏向锁撤销操作。批量撤销（bulk revoke）机制是为了解决：在明显多线程竞争剧烈的场景下使用偏向锁是不合适的。</p><p>一个偏向锁撤销计数器，每一次该class的对象发生偏向撤销操作时，该计数器+1，当这个值达到重偏向阈值（默认20）时，JVM就认为该class的偏向锁有问题，因此会进行批量重偏向。每个class对象会有一个对应的epoch字段，每个处于偏向锁状态对象的Mark Word中也有该字段，其初始值为创建该对象时class中的epoch的值。每次发生批量重偏向时，就将该值+1，同时遍历JVM中所有线程的栈，找到该class所有正处于加锁状态的偏向锁，将其epoch字段改为新值。下次获得锁时，发现当前对象的epoch值和class的epoch不相等，那就算当前已经偏向了其他线程，也不会执行撤销操作，而是直接通过CAS操作将其Mark Word的Thread Id 改成当前线程Id。当达到重偏向阈值后，假设该class计数器继续增长，当其达到批量撤销的阈值后（默认40），JVM就认为该class的使用场景存在多线程竞争，会标记该class为不可偏向，之后，对于该class的锁，直接走轻量级锁的逻辑。</p></blockquote><p>没错，我就是厕所所长</p><p>加锁，指的是锁定对象</p><p>锁升级的过程</p><p>JDK较早的版本 OS的资源 互斥量 用户态 -&gt; 内核态的转换 重量级 效率比较低</p><p>现代版本进行了优化</p><p>无锁 - 偏向锁 -轻量级锁（自旋锁）-重量级锁</p><p>偏向锁 - markword 上记录当前线程指针，下次同一个线程加锁的时候，不需要争用，只需要判断线程指针是否同一个，所以，偏向锁，偏向加锁的第一个线程 。hashCode备份在线程栈上 线程销毁，锁降级为无锁</p><p>有争用 - 锁升级为轻量级锁 - 每个线程有自己的LockRecord在自己的线程栈上，用CAS去争用markword的LR的指针，指针指向哪个线程的LR，哪个线程就拥有锁</p><p>自旋超过10次，升级为重量级锁 - 如果太多线程自旋 CPU消耗过大，不如升级为重量级锁，进入等待队列（不消耗CPU）-XX:PreBlockSpin</p><p>自旋锁在 JDK1.4.2 中引入，使用 -XX:+UseSpinning 来开启。JDK 6 中变为默认开启，并且引入了自适应的自旋锁（适应性自旋锁）。</p><p>自适应自旋锁意味着自旋的时间（次数）不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。如果对于某个锁，自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源。</p><p>偏向锁由于有锁撤销的过程revoke，会消耗系统资源，所以，在锁争用特别激烈的时候，用偏向锁未必效率高。还不如直接使用轻量级锁。</p><h3 id="synchronized最底层实现"><a href="#synchronized最底层实现" class="headerlink" title="synchronized最底层实现"></a>synchronized最底层实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">n</span><span class="params">()</span> </span>&#123; i++; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">publics <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">1000_000</span>; j++) &#123;</span><br><span class="line">            m();</span><br><span class="line">            n();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>java -XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly T</p><p>C1 Compile Level 1 (一级优化)</p><p>C2 Compile Level 2 (二级优化)</p><p>找到m() n()方法的汇编码，会看到 lock comxchg …..指令</p><h3 id="synchronized-vs-Lock-CAS"><a href="#synchronized-vs-Lock-CAS" class="headerlink" title="synchronized vs Lock (CAS)"></a>synchronized vs Lock (CAS)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">在高争用 高耗时的环境下synchronized效率更高</span><br><span class="line">在低争用 低耗时的环境下CAS效率更高</span><br><span class="line">synchronized到重量级之后是等待队列（不消耗CPU）</span><br><span class="line">CAS（等待期间消耗CPU）</span><br><span class="line"></span><br><span class="line">一切以实测为准</span><br></pre></td></tr></table></figure><h2 id="锁消除-lock-eliminate"><a href="#锁消除-lock-eliminate" class="headerlink" title="锁消除 lock eliminate"></a>锁消除 lock eliminate</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String str1,String str2)</span></span>&#123;</span><br><span class="line">         StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">         sb.append(str1).append(str2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们都知道 StringBuffer 是线程安全的，因为它的关键方法都是被 synchronized 修饰过的，但我们看上面这段代码，我们会发现，sb 这个引用只会在 add 方法中使用，不可能被其它线程引用（因为是局部变量，栈私有），因此 sb 是不可能共享的资源，JVM 会自动消除 StringBuffer 对象内部的锁。</p><h2 id="锁粗化-lock-coarsening"><a href="#锁粗化-lock-coarsening" class="headerlink" title="锁粗化 lock coarsening"></a>锁粗化 lock coarsening</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">       </span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer():</span><br><span class="line">    <span class="keyword">while</span>(i &lt; <span class="number">100</span>)&#123;</span><br><span class="line">        sb.append(str);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString():</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JVM 会检测到这样一连串的操作都对同一个对象加锁（while 循环内 100 次执行 append，没有锁粗化的就要进行 100  次加锁/解锁），此时 JVM 就会将加锁的范围粗化到这一连串的操作的外部（比如 while 虚幻体外），使得这一连串操作只需要加一次锁即可。</p><h2 id="锁降级（不重要）"><a href="#锁降级（不重要）" class="headerlink" title="锁降级（不重要）"></a>锁降级（不重要）</h2><p><a href="https://www.zhihu.com/question/63859501" target="_blank" rel="noopener">https://www.zhihu.com/question/63859501</a></p><p>其实，只被VMThread访问，降级也就没啥意义了。所以可以简单认为锁降级不存在！</p><h2 id="超线程"><a href="#超线程" class="headerlink" title="超线程"></a>超线程</h2><p>一个ALU + 两组Registers + PC</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://openjdk.java.net/groups/hotspot/docs/HotSpotGlossary.html" target="_blank" rel="noopener">http://openjdk.java.net/groups/hotspot/docs/HotSpotGlossary.html</a></p><h2 id="volatile的用途"><a href="#volatile的用途" class="headerlink" title="volatile的用途"></a>volatile的用途</h2><h3 id="1-线程可见性"><a href="#1-线程可见性" class="headerlink" title="1.线程可见性"></a>1.线程可见性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mashibing.testvolatile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T01_ThreadVisibility</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">                <span class="comment">//do sth</span></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"end"</span>);</span><br><span class="line">        &#125;, <span class="string">"server"</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        flag = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-防止指令重排序"><a href="#2-防止指令重排序" class="headerlink" title="2.防止指令重排序"></a>2.防止指令重排序</h3><h4 id="问题：DCL单例需不需要加volatile？"><a href="#问题：DCL单例需不需要加volatile？" class="headerlink" title="问题：DCL单例需不需要加volatile？"></a>问题：DCL单例需不需要加volatile？</h4><h4 id="CPU的基础知识"><a href="#CPU的基础知识" class="headerlink" title="CPU的基础知识"></a>CPU的基础知识</h4><ul><li><p>缓存行对齐<br>缓存行64个字节是CPU同步的基本单位，缓存行隔离会比伪共享效率要高<br>Disruptor</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mashibing.juc.c_028_FalseSharing;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T02_CacheLinePadding</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Padding</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">long</span> p1, p2, p3, p4, p5, p6, p7; <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> <span class="keyword">extends</span> <span class="title">Padding</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">long</span> x = <span class="number">0L</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> T[] arr = <span class="keyword">new</span> T[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        arr[<span class="number">0</span>] = <span class="keyword">new</span> T();</span><br><span class="line">        arr[<span class="number">1</span>] = <span class="keyword">new</span> T();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; <span class="number">1000_0000L</span>; i++) &#123;</span><br><span class="line">                arr[<span class="number">0</span>].x = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; <span class="number">1000_0000L</span>; i++) &#123;</span><br><span class="line">                arr[<span class="number">1</span>].x = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println((System.nanoTime() - start)/<span class="number">100_0000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MESI</p></li><li><p>伪共享</p></li><li><p>合并写<br>CPU内部的4个字节的Buffer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mashibing.juc.c_029_WriteCombining;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteCombining</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ITERATIONS = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ITEMS = <span class="number">1</span> &lt;&lt; <span class="number">24</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MASK = ITEMS - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] arrayA = <span class="keyword">new</span> <span class="keyword">byte</span>[ITEMS];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] arrayB = <span class="keyword">new</span> <span class="keyword">byte</span>[ITEMS];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] arrayC = <span class="keyword">new</span> <span class="keyword">byte</span>[ITEMS];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] arrayD = <span class="keyword">new</span> <span class="keyword">byte</span>[ITEMS];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] arrayE = <span class="keyword">new</span> <span class="keyword">byte</span>[ITEMS];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] arrayF = <span class="keyword">new</span> <span class="keyword">byte</span>[ITEMS];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++) &#123;</span><br><span class="line">            System.out.println(i + <span class="string">" SingleLoop duration (ns) = "</span> + runCaseOne());</span><br><span class="line">            System.out.println(i + <span class="string">" SplitLoop  duration (ns) = "</span> + runCaseTwo());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">runCaseOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">        <span class="keyword">int</span> i = ITERATIONS;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (--i != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> slot = i &amp; MASK;</span><br><span class="line">            <span class="keyword">byte</span> b = (<span class="keyword">byte</span>) i;</span><br><span class="line">            arrayA[slot] = b;</span><br><span class="line">            arrayB[slot] = b;</span><br><span class="line">            arrayC[slot] = b;</span><br><span class="line">            arrayD[slot] = b;</span><br><span class="line">            arrayE[slot] = b;</span><br><span class="line">            arrayF[slot] = b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> System.nanoTime() - start;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">runCaseTwo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">        <span class="keyword">int</span> i = ITERATIONS;</span><br><span class="line">        <span class="keyword">while</span> (--i != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> slot = i &amp; MASK;</span><br><span class="line">            <span class="keyword">byte</span> b = (<span class="keyword">byte</span>) i;</span><br><span class="line">            arrayA[slot] = b;</span><br><span class="line">            arrayB[slot] = b;</span><br><span class="line">            arrayC[slot] = b;</span><br><span class="line">        &#125;</span><br><span class="line">        i = ITERATIONS;</span><br><span class="line">        <span class="keyword">while</span> (--i != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> slot = i &amp; MASK;</span><br><span class="line">            <span class="keyword">byte</span> b = (<span class="keyword">byte</span>) i;</span><br><span class="line">            arrayD[slot] = b;</span><br><span class="line">            arrayE[slot] = b;</span><br><span class="line">            arrayF[slot] = b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> System.nanoTime() - start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>指令重排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mashibing.jvm.c3_jmm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T04_Disorder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">0</span>, b =<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            x = <span class="number">0</span>; y = <span class="number">0</span>;</span><br><span class="line">            a = <span class="number">0</span>; b = <span class="number">0</span>;</span><br><span class="line">            Thread one = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="comment">//由于线程one先启动，下面这句话让它等一等线程two. 读着可根据自己电脑的实际性能适当调整等待时间.</span></span><br><span class="line">                    <span class="comment">//shortWait(100000);</span></span><br><span class="line">                    a = <span class="number">1</span>;</span><br><span class="line">                    x = b;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            Thread other = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    b = <span class="number">1</span>;</span><br><span class="line">                    y = a;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            one.start();other.start();</span><br><span class="line">            one.join();other.join();</span><br><span class="line">            String result = <span class="string">"第"</span> + i + <span class="string">"次 ("</span> + x + <span class="string">","</span> + y + <span class="string">"）"</span>;</span><br><span class="line">            <span class="keyword">if</span>(x == <span class="number">0</span> &amp;&amp; y == <span class="number">0</span>) &#123;</span><br><span class="line">                System.err.println(result);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//System.out.println(result);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shortWait</span><span class="params">(<span class="keyword">long</span> interval)</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">        <span class="keyword">long</span> end;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            end = System.nanoTime();</span><br><span class="line">        &#125;<span class="keyword">while</span>(start + interval &gt;= end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="系统底层如何实现数据一致性"><a href="#系统底层如何实现数据一致性" class="headerlink" title="系统底层如何实现数据一致性"></a>系统底层如何实现数据一致性</h3><ol><li>MESI如果能解决，就使用MESI</li><li>如果不能，就锁总线</li></ol><h3 id="系统底层如何保证有序性"><a href="#系统底层如何保证有序性" class="headerlink" title="系统底层如何保证有序性"></a>系统底层如何保证有序性</h3><ol><li>内存屏障sfence mfence lfence等系统原语</li><li>锁总线</li></ol><h3 id="volatile如何解决指令重排序"><a href="#volatile如何解决指令重排序" class="headerlink" title="volatile如何解决指令重排序"></a>volatile如何解决指令重排序</h3><p>1: volatile i</p><p>2: ACC_VOLATILE</p><p>3: JVM的内存屏障</p><p>​    屏障两边的指令不可以重排！保障有序！</p><p>4：hotspot实现</p><p>bytecodeinterpreter.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> field_offset = cache-&gt;f2_as_index();</span><br><span class="line"><span class="keyword">if</span> (cache-&gt;is_volatile()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (support_IRIW_for_not_multiple_copy_atomic_cpu) &#123;</span><br><span class="line">        OrderAccess::fence();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>orderaccess_linux_x86.inline.hpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> OrderAccess::fence() &#123;</span><br><span class="line">  <span class="keyword">if</span> (os::is_MP()) &#123;</span><br><span class="line">    <span class="comment">// always use locked addl since mfence is sometimes expensive</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> AMD64</span></span><br><span class="line">    __<span class="function">asm__ <span class="title">volatile</span> <span class="params">(<span class="string">"lock; addl $0,0(%%rsp)"</span> : : : <span class="string">"cc"</span>, <span class="string">"memory"</span>)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    __<span class="function">asm__ <span class="title">volatile</span> <span class="params">(<span class="string">"lock; addl $0,0(%%esp)"</span> : : : <span class="string">"cc"</span>, <span class="string">"memory"</span>)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;用户态与内核态&quot;&gt;&lt;a href=&quot;#用户态与内核态&quot; class=&quot;headerlink&quot; title=&quot;用户态与内核态&quot;&gt;&lt;/a&gt;用户态与内核态&lt;/h2&gt;&lt;p&gt;JDK1.0，synchronized 叫做重量级锁， 因为申请锁资源必须通过kernel, 系统调
      
    
    </summary>
    
    
      <category term="java开发" scheme="https://dongzl.github.io/categories/java%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="synchronized" scheme="https://dongzl.github.io/tags/synchronized/"/>
    
  </entry>
  
  <entry>
    <title>CountDownLatch 基于 AQS 共享锁模式实现原理分析</title>
    <link href="https://dongzl.github.io/2020/04/01/19-CountDownLatch-AQS-Share-Lock/"/>
    <id>https://dongzl.github.io/2020/04/01/19-CountDownLatch-AQS-Share-Lock/</id>
    <published>2020-04-01T13:34:19.000Z</published>
    <updated>2020-04-02T14:28:12.409Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景描述"><a href="#背景描述" class="headerlink" title="背景描述"></a>背景描述</h2><p><code>CountDownLatch</code> 是 <code>JDK</code> 中提供的一个非常有用的工具类，在实际的工作中也有很多应用场景，比如，在一段业务逻辑中可能要进行几个操作，这些操作彼此之间没有关联，这些操作在完成之后继续进行后续操作，如果采用串行的操作方式，业务逻辑执行时间也是累加关系；如果采用 <code>CountDownLatch</code> 工具类，可以开启多个线程并行执行这些操作，执行成功后调用 <code>countDown()</code> 减一，主线程调用 <code>await()</code> 进入等待状态，当子线程全部执行完毕，count 值减到 0 之后，唤醒主线程继续执行，这个时候代码执行时间就不是累加关系了，而是执行最慢操作执行时间，这就是 <code>CountDownLatch</code> 工具类的妙处。</p><blockquote><p>A synchronization aid that allows one or more threads to wait until a set of operations being performed in other threads completes.</p></blockquote><p>我们来看一下 JDK 注释中给出的 <code>CountDownLatch</code> 的使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Driver2</span> </span>&#123; <span class="comment">// ...</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        CountDownLatch doneSignal = <span class="keyword">new</span> CountDownLatch(N);</span><br><span class="line">        Executor e = ...</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;<span class="comment">// create and start threads</span></span><br><span class="line">            e.execute(<span class="keyword">new</span> WorkerRunnable(doneSignal, i));</span><br><span class="line">        &#125;</span><br><span class="line">        doneSignal.await();           <span class="comment">// wait for all to finish</span></span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WorkerRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch doneSignal;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> i;</span><br><span class="line">    WorkerRunnable(CountDownLatch doneSignal, <span class="keyword">int</span> i) &#123;</span><br><span class="line">        <span class="keyword">this</span>.doneSignal = doneSignal;</span><br><span class="line">        <span class="keyword">this</span>.i = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            doWork(i);</span><br><span class="line">            doneSignal.countDown();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;&#125; <span class="comment">// return;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们来分析一下 <code>CountDownLatch</code> 的实现原理，本文代码分析都是以 <code>JDK1.8</code> 源代码为基础进行分析。</p><h2 id="AQS-原理"><a href="#AQS-原理" class="headerlink" title="AQS 原理"></a>AQS 原理</h2><p><code>CountDownLatch</code> 的核心实现原理是基于 <code>AQS</code>，<code>AQS</code> 全称 <code>AbstractQueuedSynchronizer</code>，是 <code>java.util.concurrent</code> 中提供的一种高效且可扩展的同步机制；它是一种提供了原子式管理同步状态、阻塞和唤醒线程功能以及队列模型的简单框架。除了 <code>CountDownLatch</code> 工具类，JDK 当中的 <code>Semaphore</code>、<code>ReentrantLock</code> 等工具类都是基于 <code>AQS</code> 来实现的。下面我们用 <code>CountDownLatch</code> 来分析一下 <code>AQS</code> 的实现。</p><img src="https://gitee.com/dongzl/article-images/raw/master/2020/19-CountDownLatch-AQS-Share-Lock/CountDownLatch-AQS-Share-Lock-01.png"><img src="https://gitee.com/dongzl/article-images/raw/master/2020/19-CountDownLatch-AQS-Share-Lock/CountDownLatch-AQS-Share-Lock-02.png"><p>其实，如果我们阅读 <code>CountDownLatch</code> 的源码实现，发现其实它的代码实现非常简单，算上注释也才 300+ 行代码，如果去掉注释的话代码不到 100 行，大部分方法实现都是调用的 <code>Sync</code> 这个静态内部类的实现，而 <code>Sync</code> 就是继承自 <code>AbstractQueuedSynchronizer</code>。</p><p><code>Sync</code> 重写了 <code>AQS</code> 中的 <code>tryAcquireShared</code> 和 <code>tryReleaseShared</code> 两个方法。当调用 <code>CountDownLatch</code> 的 <code>awit()</code> 方法时，会调用内部类 <code>Sync</code> 的 <code>acquireSharedInterruptibly()</code> 方法，然后在这个方法中会调用 <code>tryAcquireShared</code> 方法，这个方法就是 <code>Sync</code> 重写的 <code>AQS</code> 中的方法；调用 <code>countDown()</code> 方法原理基本类似。</p><p>通过内部类继承的方式是我们使用 <code>AbstractQueuedSynchronizer</code> 的标准方式：</p><ul><li>内部持有继承自 <code>AbstractQueuedSynchronizer</code> 的对象 <code>Sync</code>；</li><li>在 <code>Sync</code> 内重写 <code>AbstractQueuedSynchronizer</code> 内部 <code>protected</code> 的部分或全部方法：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过需要重写的方法名称我们大致可以得知，<code>AQS</code> 中是分成两种模式的：独占模式和共享模式，其中 <code>CountDownLatch</code> 使用的是共享模式。</p><ul><li><p><code>tryAcquire</code> 和 <code>tryRelease</code> 是对应的，前者是独占模式获取，后者是独占模式释放；</p></li><li><p><code>tryAcquireShared</code> 和 <code>tryReleaseShared</code> 是对应的，前者是共享模式获取，后者是共享模式释放。</p></li></ul><h2 id="源码实现分析"><a href="#源码实现分析" class="headerlink" title="源码实现分析"></a>源码实现分析</h2><h3 id="构造方法实现"><a href="#构造方法实现" class="headerlink" title="构造方法实现"></a>构造方法实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CountDownLatch</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"count &lt; 0"</span>);</span><br><span class="line">    <span class="keyword">this</span>.sync = <span class="keyword">new</span> Sync(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CountDownLatch</code> 的构造方法中调用了 <code>Sync</code> 的构造方法，<code>Sync</code> 的构造方法调用了 <code>AQS</code> 类中的 <code>setState(count);</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Sync(<span class="keyword">int</span> count) &#123;</span><br><span class="line">    setState(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>state</code> 变量是 <code>AQS</code> 类中的一个 volatile 变量。在 <code>CountDownLatch</code> 中这个 <code>state</code> 值就是一个计数器，记录 <code>countDown</code> 是否已经减到 0。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The synchronization state.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br></pre></td></tr></table></figure><h3 id="await-方法实现"><a href="#await-方法实现" class="headerlink" title="await() 方法实现"></a>await() 方法实现</h3><p>在调用 <code>await()</code> 方法时，会直接调用 <code>AQS</code> 类的 <code>acquireSharedInterruptibly</code> 方法，在 <code>acquireSharedInterruptibly</code> 方法内部会继续调用 <code>Sync</code> 实现类中的 <code>tryAcquireShared</code> 方法，在 <code>tryAcquireShared</code> 方法中判断 <code>state</code> 变量值是否为 <code>0</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 <code>state</code> 值不等于 0，说明还有需要等待的线程在运行，则会执行 <code>doAcquireSharedInterruptibly()</code> 方法，执行该方法的第一个动作就是尝试加入等待队列，即调用 <code>addWaiter()</code> 方法，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Acquires in shared interruptible mode.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arg the acquire argument</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">//加入等待队列</span></span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//进入 CAS 循环</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">//当一个节点(关联一个线程)进入等待队列后， 获取此节点的 prev 节点 </span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">// 如果获取到的 prev 是 head，也就是队列中第一个等待线程</span></span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="comment">// 再次尝试申请 反应到 CountDownLatch 就是查看是否还有线程需要等待(state是否为0)</span></span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="comment">// 如果 r &gt;=0 说明 没有线程需要等待了 state==0</span></span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//尝试将第一个线程关联的节点设置为 head </span></span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//经过自旋tryAcquireShared后，state还不为0，就会到这里，第一次的时候，</span></span><br><span class="line">            <span class="comment">//waitStatus是0，那么node的waitStatus就会被置为SIGNAL，第二次再走到这里，</span></span><br><span class="line">            <span class="comment">//就会用LockSupport的park方法把当前线程阻塞住</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就是 <code>AQS</code> 的核心实现，<code>AQS</code> 用内部的一个 <code>Node</code> 类维护一个 <code>CHL Node FIFO</code> 队列。将当前线程加入等待队列，并通过 <code>parkAndCheckInterrupt()</code> 方法实现当前线程的阻塞。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">    <span class="comment">// 尝试快速入队操作，因为大多数时候尾节点不为 null</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果尾节点为空(也就是队列为空) 或者尝试CAS入队失败(由于并发原因)，进入enq方法</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>addWaiter()</code> 方法是向等待队列中添加等待者（waiter）。首先构造一个 <code>Node</code> 实体，参数为当前线程和一个 <code>Node</code> 对象（mode），这个 <code>mode</code> 有两种形式，一种是 <code>SHARED</code>，另一种是 <code>EXCLUSIVE</code>。接下来需要执行入队操作，<code>addWaiter()</code> 方法和 <code>enq()</code> 方法的 else 分支操作是一样的，这里的操作如果成功了，就不用再进到 <code>enq()</code> 方法的循环中去了，可以提高性能；如果没有成功，再调用 <code>enq()</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Inserts node into queue, initializing if necessary. See picture above.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node the node to insert</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> node's predecessor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 死循环 + CAS 保证所有节点都入队</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="comment">// 如果队列为空 设置一个空节点作为 head</span></span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 加入队尾</span></span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面操作就是 <code>AQS</code> 等待队列入队方法，操作在无限循环中进行，如果入队成功则返回新的队尾节点（<font color="red">enq 方法中返回的是 t，感觉不是新队尾节点呢，像是队尾的前一个节点呢，不过影响不大，在 addWaiter 方法中返回的 node 是新的队尾节点</font>），否则一直自旋，直到入队成功。假设入队的节点为 node ，上来直接进入循环，在循环中，先拿到尾节点。</p><ul><li><p>if 分支，如果尾节点为 null，说明现在队列中还没有等待线程，则尝试 CAS 操作将头节点初始化，然后将尾节点也设置为头节点，因为初始化的时候头尾是同一个，这和 AQS 的设计实现有关， AQS 默认要有一个虚拟节点。此时，尾节点不在为空，循环继续，进入 else 分支；</p></li><li><p>else 分支，如果尾节点不为 null，node.prev = t ，也就是将当前尾节点设置为待入队节点的前置节点。然后又是利用 CAS 操作，将待入队的节点设置为队列的尾节点，如果 CAS 返回 false，表示未设置成功，继续循环设置，直到设置成功，接着将之前的尾节点（也就是倒数第二个节点）的 next 属性设置为当前尾节点，对应 t.next = node 语句，然后返回当前尾节点，退出循环。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sets head of queue, and checks if successor may be waiting</span></span><br><span class="line"><span class="comment"> * in shared mode, if so propagating if either propagate &gt; 0 or</span></span><br><span class="line"><span class="comment"> * PROPAGATE status was set.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> propagate the return value from a tryAcquireShared</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 备份现在的 head</span></span><br><span class="line">    Node h = head; <span class="comment">// Record old head for check below</span></span><br><span class="line">    <span class="comment">// 抢到锁的线程被唤醒 将这个节点设置为head</span></span><br><span class="line">    setHead(node);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Try to signal next queued node if:</span></span><br><span class="line"><span class="comment">     *   Propagation was indicated by caller,</span></span><br><span class="line"><span class="comment">     *     or was recorded (as h.waitStatus either before</span></span><br><span class="line"><span class="comment">     *     or after setHead) by a previous operation</span></span><br><span class="line"><span class="comment">     *     (note: this uses sign-check of waitStatus because</span></span><br><span class="line"><span class="comment">     *      PROPAGATE status may transition to SIGNAL.)</span></span><br><span class="line"><span class="comment">     * and</span></span><br><span class="line"><span class="comment">     *   The next node is waiting in shared mode,</span></span><br><span class="line"><span class="comment">     *     or we don't know, because it appears null</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The conservatism in both of these checks may cause</span></span><br><span class="line"><span class="comment">     * unnecessary wake-ups, but only when there are multiple</span></span><br><span class="line"><span class="comment">     * racing acquires/releases, so most need signals now or soon</span></span><br><span class="line"><span class="comment">     * anyway.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// propagate 一般都会大于 0 或者存在可被唤醒的线程</span></span><br><span class="line">    <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">            (h = head) == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        Node s = node.next;</span><br><span class="line">        <span class="comment">// 只有一个节点 或者是共享模式，释放所有等待线程，各自尝试抢占锁</span></span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared())</span><br><span class="line">            doReleaseShared();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>setHeadAndPropagate</code> 方法负责将自旋等待或被 <code>LockSupport</code> 阻塞的线程唤醒。</p><p><code>Node</code> 对象中有一个属性是 <code>waitStatus</code>，它有四种状态，分别是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程已被 cancelled ，这种状态的节点将会被忽略，并移出队列</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 表示当前线程已被挂起，并且后继节点可以尝试抢占锁</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line"><span class="comment">//线程正在等待某些条件</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line"><span class="comment">//共享模式下 无条件所有等待线程尝试抢占锁</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br></pre></td></tr></table></figure><h3 id="countDown-方法"><a href="#countDown-方法" class="headerlink" title="countDown() 方法"></a>countDown() 方法</h3><p>当执行 <code>CountDownLatch</code> 的 <code>countDown()</code> 方法，将计数器减一，也就是将 <code>state</code> 值减一，当减到 0 的时候，等待队列中的线程被释放。是调用 <code>AQS</code> 的 <code>releaseShared()</code> 方法来实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CountDownLatch 类 countDown() 方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AQS 类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// arg 为固定值 1</span></span><br><span class="line">    <span class="comment">// 如果计数器state 为 0 返回true，前提是调用 countDown() 之前能已经为 0</span></span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        <span class="comment">// 唤醒等待队列的线程</span></span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CountDownLatch 类重写 AQS 方法</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Decrement count; signal when transition to zero</span></span><br><span class="line">    <span class="comment">// 依然是循环 + CAS 配合 实现计数器减 1</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> nextc = c-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">            <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AQS 类</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="comment">// 如果节点状态为 SIGNAL，则他的 next 节点也可以尝试被唤醒</span></span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将节点状态设置为 PROPAGATE，表示要向下传播，依次唤醒</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                        !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为这是共享型的，当计数器为 0 后，会唤醒等待队列里的所有线程，所有调用了 <code>await()</code> 方法的线程都被唤醒，并发执行。这种情况对应到的场景是，有多个线程需要等待一些动作完成，比如一个线程完成初始化动作，其他 5 个线程都需要用到初始化的结果，那么在初始化线程调用 <code>countDown()</code> 之前，其他 5 个线程都处在等待状态。一旦执行线程调用了 countDown 方法将计数器减到 0，等待的 5 个线程都被唤醒，开始执行。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p><code>AQS</code> 分为独占模式和共享模式，<code>CountDownLatch</code> 使用了它的共享模式；</p></li><li><p><code>AQS</code> 当第一个等待线程（被包装为 Node）要入队的时候，要保证存在一个 <code>head</code> 节点，这个 <code>head</code> 节点不关联线程，也就是一个虚节点；</p></li><li><p>当队列中的等待节点（关联线程的，非 <code>head</code> 节点）抢到锁，将这个节点设置为 <code>head</code> 节点；</p></li><li><p>第一次自旋抢锁失败后，<code>waitStatus</code> 会被设置为 -1（SIGNAL），第二次再失败，就会被 <code>LockSupport</code> 阻塞挂起；</p></li><li><p>如果一个节点的前置节点为 <code>SIGNAL</code> 状态，则这个节点可以尝试抢占锁。</p></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><p><a href="https://www.cnblogs.com/fengzheng/p/9153720.html" target="_blank" rel="noopener">Java多线程之—用 CountDownLatch 说明 AQS 的实现原理</a></p></li><li><p><a href="https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html" target="_blank" rel="noopener">从ReentrantLock的实现看AQS的原理及应用</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景描述&quot;&gt;&lt;a href=&quot;#背景描述&quot; class=&quot;headerlink&quot; title=&quot;背景描述&quot;&gt;&lt;/a&gt;背景描述&lt;/h2&gt;&lt;p&gt;&lt;code&gt;CountDownLatch&lt;/code&gt; 是 &lt;code&gt;JDK&lt;/code&gt; 中提供的一个非常有用的工具类，
      
    
    </summary>
    
    
      <category term="java开发" scheme="https://dongzl.github.io/categories/java%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="AQS" scheme="https://dongzl.github.io/tags/AQS/"/>
    
      <category term="CountDownLatch" scheme="https://dongzl.github.io/tags/CountDownLatch/"/>
    
  </entry>
  
  <entry>
    <title>Redis 面试常见问题知识点总结</title>
    <link href="https://dongzl.github.io/2020/03/22/18-Redis-Interview-knowledge/"/>
    <id>https://dongzl.github.io/2020/03/22/18-Redis-Interview-knowledge/</id>
    <published>2020-03-22T13:24:37.000Z</published>
    <updated>2020-03-23T07:10:36.084Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景描述"><a href="#背景描述" class="headerlink" title="背景描述"></a>背景描述</h2><p>在面试过程中，<code>缓存雪崩</code>、<code>缓存穿透</code>、<code>缓存击穿</code>、<code>分布式锁</code> 等问题是 Redis 的常见问题，本文根据 <a href="http://www.mashibing.com/" target="_blank" rel="noopener">马士兵教育</a> 公开课内容整理而成，主要总结了上述面试题一些回答思路。</p><h2 id="总结内容"><a href="#总结内容" class="headerlink" title="总结内容"></a>总结内容</h2><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>Redis 中的热点数据集中过期导致 MySQL 在某一时刻承受很大的压力，也有可能是因为 Redis 服务器宕机所致。</p><ul><li><p>数据集中过期：在数据过期时间后加上一个随机值，不要让数据同时过期；</p></li><li><p>Redis 宕机问题：a、设置多级缓存，b、搭建 Redis 集群，防止单点问题。</p></li></ul><img src="https://gitee.com/dongzl/article-images/raw/master/2020/18-Redis-Interview-knowledge/Redis-Interview-knowledge-01.jpg"><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>如果客户端发送的请求，查询的数据，在 Redis 中都查不到，那么缓存就失去意义了。这种情况多数是由恶意用户伪造请求参数，导致 Redis 缓存查不到数据而失效。</p><ul><li>BloomFilter（布隆过滤器）；</li><li>使用分布式锁解决缓存穿透，对于缓存中不存在的数据，在访问 MySQL 数据库时需要抢占分布式锁。</li></ul><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>Redis 中有一条热点数据，过期之后，MySQL 承接了大量的请求。</p><p>一般这种情况在实际工作中出现较少，很少会只有一条热点数据。</p><img src="https://gitee.com/dongzl/article-images/raw/master/2020/18-Redis-Interview-knowledge/Redis-Interview-knowledge-03.jpg"><h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><p>Redis 实现分布式锁的一些问题：</p><ul><li><p>死锁 –&gt; 有过期时间 –&gt; 乱入锁 –&gt; 增大有效期时间 –&gt; 效率低，吞吐量下降；</p></li><li><p>资源浪费。</p></li></ul><img src="https://gitee.com/dongzl/article-images/raw/master/2020/18-Redis-Interview-knowledge/Redis-Interview-knowledge-02.png">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景描述&quot;&gt;&lt;a href=&quot;#背景描述&quot; class=&quot;headerlink&quot; title=&quot;背景描述&quot;&gt;&lt;/a&gt;背景描述&lt;/h2&gt;&lt;p&gt;在面试过程中，&lt;code&gt;缓存雪崩&lt;/code&gt;、&lt;code&gt;缓存穿透&lt;/code&gt;、&lt;code&gt;缓存击穿&lt;/code&gt;、&lt;
      
    
    </summary>
    
    
      <category term="架构设计" scheme="https://dongzl.github.io/categories/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="Redis" scheme="https://dongzl.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>BloomFilter 实现原理及使用</title>
    <link href="https://dongzl.github.io/2020/03/21/17-Bloom-Filter-Summary/"/>
    <id>https://dongzl.github.io/2020/03/21/17-Bloom-Filter-Summary/</id>
    <published>2020-03-21T13:10:04.000Z</published>
    <updated>2020-03-23T07:11:00.914Z</updated>
    
    <content type="html"><![CDATA[<h2 id="布隆过滤器介绍"><a href="#布隆过滤器介绍" class="headerlink" title="布隆过滤器介绍"></a>布隆过滤器介绍</h2><p>布隆过滤器（Bloom Filter）由 <code>Burton Howard Bloom</code> 在 1970 年提出，是一种空间效率高的概率型数据结构。它专门用来检测集合中是否存在特定的元素。其实对于判断集合中是否存在某个元素，我们平时都会直接使用比较算法，例如：</p><ul><li>如果集合用线性表存储，查找的时间复杂度为 O(n)；</li><li>如果用平衡 BST（如 AVL树、红黑树）存储，时间复杂度为 O(logn)；</li><li>如果用哈希表存储，并用链地址法与平衡 BST 解决哈希冲突（参考 JDK8 的 HashMap 实现方法），时间复杂度也要有O[log(n/m)]，m 为哈希分桶数。</li></ul><img src="https://gitee.com/dongzl/article-images/raw/master/2020/17-Bloom-Filter-Summary/Bloom-Filter-Summary-01.png"><p>如果采用上面提到的一些方法，需要将实际数据都要存储到集合中，才能真正判断元素是否存在，会占用很大的内存空间，而且对于上面计算的时间复杂度，如果集合中元素非常多时，查找效率并不高。Bloom Filter 就是为了解决这些问题应运而生的。</p><h2 id="Bloom-Filter-设计思想"><a href="#Bloom-Filter-设计思想" class="headerlink" title="Bloom Filter 设计思想"></a>Bloom Filter 设计思想</h2><p>Bloom Filter 是由一个长度为 m 的比特位数组（bit array）与 k 个哈希函数（hash function）组成的数据结构。位数组均初始化为 0，所有哈希函数都可以分别把输入数据尽量均匀地散列。</p><p>当要插入一个元素时，将其数据分别输入 k 个哈希函数，产生 k 个哈希值。以哈希值作为位数组中的下标，将所有 k 个对应的比特置为 1。</p><p>当要查询（即判断是否存在）一个元素时，同样将其数据输入哈希函数，然后检查对应的 k 个比特。如果有任意一个比特为 0，表明该元素一定不在集合中。如果所有比特均为 1，表明该元素有（较大的）可能性在集合中。为什么不是一定在集合中呢？因为一个比特被置为 1 有可能会受到其他元素的影响，这就是所谓“假阳性”（false positive）。相对地，“假阴性”（false negative）在 Bloom Filter 中是绝不会出现的。</p><p>下图示出一个 m=18, k=3 的 Bloom Filter 示例。集合中的 x、y、z 三个元素通过 3 个不同的哈希函数散列到位数组中。当查询元素 w 时，因为有一个比特为0，因此 w 不在该集合中。</p><img src="https://gitee.com/dongzl/article-images/raw/master/2020/17-Bloom-Filter-Summary/Bloom-Filter-Summary-02.png"><h2 id="Bloom-Filter-的优缺点与用途"><a href="#Bloom-Filter-的优缺点与用途" class="headerlink" title="Bloom Filter 的优缺点与用途"></a>Bloom Filter 的优缺点与用途</h2><p><strong>优点：</strong></p><ul><li>不需要存储数据本身，只用比特表示，因此空间占用相对于传统方式有巨大的优势，并且能够保密数据；</li><li>时间效率也较高，插入和查询的时间复杂度均为O(k)；</li><li>哈希函数之间相互独立，可以在硬件指令层面并行计算。</li></ul><p><strong>缺点：</strong></p><ul><li>存在假阳性的概率，不适用于任何要求 100% 准确率的场景；</li><li>只能插入和查询元素，不能删除元素，这与产生假阳性的原因是相同的。我们可以简单地想到通过计数（即将一个比特扩展为计数值）来记录元素数，但仍然无法保证删除的元素一定在集合中。</li></ul><p>所以，Bloom Filter 在对查准度要求没有那么苛刻，而对时间、空间效率要求较高的场合非常合适，本文第一句话提到的用途即属于此类。另外，由于它不存在 <strong>假阴性</strong> 问题，所以用作“不存在”逻辑的处理时有奇效，比如可以用来作为 <strong>缓存系统（如Redis）的缓冲，防止缓存穿透</strong>。</p><h2 id="Google-Guava-中-Bloom-Filter-的使用"><a href="#Google-Guava-中-Bloom-Filter-的使用" class="headerlink" title="Google Guava 中 Bloom Filter 的使用"></a>Google Guava 中 Bloom Filter 的使用</h2><blockquote><p>A Bloom filter offers an approximate containment test with one-sided error: if it claims that an element is contained in it, this might be in error, but if it claims that an element is <i>not</i> contained in it, then this is definitely true.</p></blockquote><blockquote><p>Bloom filter 提供了一个单方面错误的近似包含测试：如果它声称某个元素包含在其中，则这可能是错误的（可能不包含在其中）；但是如果它声称某个元素不包含在其中，那这一定是正确的（一定不包含在其中）。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.common.hash.BloomFilter;</span><br><span class="line"><span class="keyword">import</span> com.google.common.hash.Funnels;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BloomFilterTest</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BloomFilter&lt;String&gt; filter = BloomFilter.create(Funnels.stringFunnel(Charset.forName(<span class="string">"utf-8"</span>)), <span class="number">1000</span>, <span class="number">0.000001</span>);</span><br><span class="line">        filter.put(<span class="string">"java"</span>);</span><br><span class="line">        filter.put(<span class="string">"c++"</span>);</span><br><span class="line">        filter.put(<span class="string">"python"</span>);</span><br><span class="line">        System.out.println(filter.mightContain(<span class="string">"php"</span>));</span><br><span class="line">        BloomFilter&lt;String&gt; filter2 = BloomFilter.create(Funnels.stringFunnel(Charset.forName(<span class="string">"utf-8"</span>)), <span class="number">1000</span>, <span class="number">0.000001</span>);</span><br><span class="line">        filter2.put(<span class="string">"go"</span>);</span><br><span class="line">        filter2.put(<span class="string">"rust"</span>);</span><br><span class="line">        filter2.put(<span class="string">"c"</span>);</span><br><span class="line">        filter2.putAll(filter);</span><br><span class="line">        System.out.println(filter2.mightContain(<span class="string">"java"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Redis-中-Bloom-Filter-的使用"><a href="#Redis-中-Bloom-Filter-的使用" class="headerlink" title="Redis 中 Bloom Filter 的使用"></a>Redis 中 Bloom Filter 的使用</h2><p>Redis 中使用 BloomFilter 需要安装 <a href="https://github.com/RedisBloom" target="_blank" rel="noopener">RedisBloom</a> 插件，下载源码编译后生成一个 <code>rebloom.so</code> 文件，然后需要在在 Redis 的配置文件 <code>redis.conf</code> 中加入该模块即可:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loadmodule /$&#123;path&#125;/rebloom.so</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bf.add test 1</span><br><span class="line">bf.add test 2</span><br><span class="line">bf.exists test 2</span><br><span class="line">bf.exists test 3</span><br></pre></td></tr></table></figure><p>关于 <code>RedisBloom</code> 的详细说明可以参考文档：<a href="https://oss.redislabs.com/redisbloom/" target="_blank" rel="noopener">RedisBloom - Probabilistic Datatypes Module for Redis</a></p><p>Redis BloomFilter 在 java 中的应用，可以使用 <code>jrebloom-${version}.jar</code> jar 包中提供的功能：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.redislabs<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jrebloom<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.rebloom.client.Client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisBloomFilterTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Client client = <span class="keyword">new</span> Client(<span class="string">"192.168.202.121"</span>, <span class="number">6395</span>);</span><br><span class="line">        client.add(<span class="string">"test"</span>, <span class="string">"1"</span>);</span><br><span class="line">        client.add(<span class="string">"test"</span>, <span class="string">"2"</span>);</span><br><span class="line">        System.out.println(client.exists(<span class="string">"test"</span>, <span class="string">"2"</span>));</span><br><span class="line">        System.out.println(client.exists(<span class="string">"test"</span>, <span class="string">"3"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="row">    <embed src="https://gitee.com/dongzl/article-images/raw/master/2020/17-Bloom-Filter-Summary/Bloom-Filter-Summary-03.pdf" width="100%" height="550" type="application/pdf"></div><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://llimllib.github.io/bloomfilter-tutorial/" target="_blank" rel="noopener">Bloom Filters by Example</a></li><li><a href="https://www.jianshu.com/p/bef2ec1c361f" target="_blank" rel="noopener">布隆过滤器（Bloom Filter）原理及 Guava 中的具体实现</a></li><li><a href="https://oss.redislabs.com/redisbloom/" target="_blank" rel="noopener">RedisBloom - Probabilistic Datatypes Module for Redis</a></li><li><a href="https://www.cnblogs.com/heihaozi/p/12174478.html" target="_blank" rel="noopener">详细解析Redis中的布隆过滤器及其应用</a></li><li><a href="https://baijiahao.baidu.com/s?id=1655304940308056733&wfr=spider&for=pc" target="_blank" rel="noopener">帮你解读什么是Redis缓存穿透和缓存雪崩（包含解决方案）</a></li><li><a href="https://blog.csdn.net/ChenMMo/article/details/93615438" target="_blank" rel="noopener">Redis安装布隆过滤器插件 bloomfilter</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;布隆过滤器介绍&quot;&gt;&lt;a href=&quot;#布隆过滤器介绍&quot; class=&quot;headerlink&quot; title=&quot;布隆过滤器介绍&quot;&gt;&lt;/a&gt;布隆过滤器介绍&lt;/h2&gt;&lt;p&gt;布隆过滤器（Bloom Filter）由 &lt;code&gt;Burton Howard Bloom&lt;/co
      
    
    </summary>
    
    
      <category term="架构设计" scheme="https://dongzl.github.io/categories/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="BloomFilter" scheme="https://dongzl.github.io/tags/BloomFilter/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 数据库 Lock 知识总结</title>
    <link href="https://dongzl.github.io/2020/03/19/16-MySQL-Lock-Summary/"/>
    <id>https://dongzl.github.io/2020/03/19/16-MySQL-Lock-Summary/</id>
    <published>2020-03-19T14:13:22.000Z</published>
    <updated>2020-03-23T07:05:37.804Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MySQL-中锁的基本知识"><a href="#MySQL-中锁的基本知识" class="headerlink" title="MySQL 中锁的基本知识"></a>MySQL 中锁的基本知识</h2><p><strong>锁是计算机协调多个进程或线程并发访问某一资源的机制。</strong> 在数据库中，除传统的计算资源（如 CPU、RAM、I/O 等）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。</p><p>​相对其他数据库而言，MySQL 的锁机制比较简单，其最显著的特点是不同的 <strong>存储引擎</strong> 支持不同的锁机制。比如，MyISAM 和 MEMORY 存储引擎采用的是表级锁（table-level locking）；InnoDB 存储引擎既支持行级锁（row-level locking），也支持表级锁，但默认情况下是采用行级锁。</p><ul><li><p><strong>表级锁</strong>：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低； </p></li><li><p><strong>行级锁</strong>：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。  </p></li></ul><p>​从上述特点可见，很难笼统地说哪种锁更好，只能就具体应用的特点来说哪种锁更合适。仅从锁的角度来说：<strong>表级锁</strong>更适合于以查询为主，只有少量按索引条件更新数据的应用，如Web应用；而<strong>行级锁</strong>则更适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用，如一些在线事务处理（OLTP）系统。 </p><h2 id="MySQL-中锁的分类"><a href="#MySQL-中锁的分类" class="headerlink" title="MySQL 中锁的分类"></a>MySQL 中锁的分类</h2><ul><li><p>共享锁：Shared Locks（简称 S 锁，属于行锁）</p></li><li><p>排他锁：Exclusive Locks（简称 X 锁，属于行锁）</p></li><li><p>意向共享锁：Intention Shared Locks（简称 IS 锁，属于表锁）</p></li><li><p>意向排他锁：Intention Exclusive Locks（简称 IX 锁，属于表锁）</p></li><li><p>自增锁 AUTO-INC Locks</p></li></ul><h3 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h3><p>共享锁就是多个事务对于同一数据可以共享一把锁，都能访问到数据库，但是只能读不能修改；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#事务A：</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span> <span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share</span> <span class="keyword">mode</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#事务B:</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span>; <span class="comment">--(读取数据没问题)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#事务B:</span></span><br><span class="line"><span class="keyword">update</span> student <span class="keyword">set</span> <span class="keyword">name</span>=<span class="string">'hehe'</span> <span class="keyword">where</span> <span class="keyword">id</span>  =<span class="number">1</span>;</span><br><span class="line"><span class="comment">--注意：无法修改会卡死，当事务A提交事务之后，会立刻修改成功</span></span><br></pre></td></tr></table></figure><h3 id="排他锁"><a href="#排他锁" class="headerlink" title="排他锁"></a>排他锁</h3><p>排它锁不能与其他锁并存，如一个事务获取了一个数据行的排它锁，其他事务就不能再获取改行的锁，只有当前获取了排它锁的事务可以对数据进行读取和修改。<code>delete、update、insert</code> 默认是排他锁：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#事务A:</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#事务B:</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span> <span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share</span> <span class="keyword">mode</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 注意：事务B操作的时候回卡死，提交事务立马成功。</span></span><br></pre></td></tr></table></figure><h3 id="意向共享锁和意向排他锁"><a href="#意向共享锁和意向排他锁" class="headerlink" title="意向共享锁和意向排他锁"></a>意向共享锁和意向排他锁</h3><ul><li><p>意向共享锁：表示事务准备给数据行加入共享锁，也就是说一个数据行在加共享锁之前必须先取得该表的 IS 锁;</p></li><li><p>意向排他锁：表示事务准备给数据行加入排它锁，也就是说一个数据行加排它锁之前必须先取得该表的 IX 锁。</p></li></ul><p><strong>PS. 意向锁是InnoDB数据操作之前自动加的，不需要用户干预。</strong></p><h3 id="自增锁"><a href="#自增锁" class="headerlink" title="自增锁"></a>自增锁</h3><p>针对自增列自增长的一个特殊的表级别锁</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">VARIABLES</span> <span class="keyword">LIKE</span> <span class="string">'innodb_autoinc_lock_mode'</span>;</span><br><span class="line"><span class="comment">--默认值1 代表连续，事务未提交则id永久丢失</span></span><br></pre></td></tr></table></figure><h2 id="MyISAM-表锁"><a href="#MyISAM-表锁" class="headerlink" title="MyISAM 表锁"></a>MyISAM 表锁</h2><p>MySQL 的表级锁有两种模式：<strong>表共享读锁（Table Read Lock）</strong>和<strong>表独占写锁（Table Write Lock）</strong>。  </p><p>对 MyISAM 表的读操作，不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写请求；对 MyISAM 表的写操作，则会阻塞其他用户对同一表的读和写操作；MyISAM 表的读操作与写操作之间，以及写操作之间是串行的！ </p><p>建表语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`mylock`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`NAME`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=MyISAM <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`mylock`</span> (<span class="string">`id`</span>, <span class="string">`NAME`</span>) <span class="keyword">VALUES</span> (<span class="string">'1'</span>, <span class="string">'a'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`mylock`</span> (<span class="string">`id`</span>, <span class="string">`NAME`</span>) <span class="keyword">VALUES</span> (<span class="string">'2'</span>, <span class="string">'b'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`mylock`</span> (<span class="string">`id`</span>, <span class="string">`NAME`</span>) <span class="keyword">VALUES</span> (<span class="string">'3'</span>, <span class="string">'c'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`mylock`</span> (<span class="string">`id`</span>, <span class="string">`NAME`</span>) <span class="keyword">VALUES</span> (<span class="string">'4'</span>, <span class="string">'d'</span>);</span><br></pre></td></tr></table></figure><p><strong>MyISAM写锁阻塞读的案例：</strong></p><p>​当一个线程获得对一个表的写锁之后，只有持有锁的线程可以对表进行更新操作。其他线程的读写操作都会等待，直到锁释放为止。</p><table><thead><tr><th align="center">session1</th><th align="center">session2</th></tr></thead><tbody><tr><td align="center">获取表的write锁定<br>lock table mylock write;</td><td align="center"></td></tr><tr><td align="center">当前session对表的查询，插入，更新操作都可以执行<br>select * from mylock;<br>insert into mylock values(5,’e’);</td><td align="center">当前session对表的查询会被阻塞<br>select * from mylock；</td></tr><tr><td align="center">释放锁：<br>unlock tables；</td><td align="center">当前session能够立刻执行，并返回对应结果</td></tr></tbody></table><p><strong>MyISAM读阻塞写的案例：</strong></p><p>一个 session 使用 <code>lock table</code> 给表加读锁，这个 session 可以锁定表中的记录，但更新和访问其他表都会提示错误，同时，另一个 session 可以查询表中的记录，但更新就会出现锁等待。</p><table><thead><tr><th align="center">session1</th><th align="center">session2</th></tr></thead><tbody><tr><td align="center">获得表的read锁定<br>lock table mylock read;</td><td align="center"></td></tr><tr><td align="center">当前session可以查询该表记录：<br>select * from mylock;</td><td align="center">当前session可以查询该表记录：<br>select * from mylock;</td></tr><tr><td align="center">当前session不能查询没有锁定的表<br>select * from person<br>Table ‘person’ was not locked with LOCK TABLES</td><td align="center">当前session可以查询或者更新未锁定的表<br>select * from person<br>insert into person values(1,’zhangsan’);</td></tr><tr><td align="center">当前session插入或者更新表会提示错误<br>insert into mylock values(6,’f’)<br>Table ‘mylock’ was locked with a READ lock and can’t be updated<br>update mylock set name=’aa’ where id = 1;<br>Table ‘mylock’ was locked with a READ lock and can’t be updated</td><td align="center">当前session插入数据会等待获得锁<br>insert into mylock values(6,’f’);</td></tr><tr><td align="center">释放锁<br>unlock tables;</td><td align="center">获得锁，更新成功</td></tr></tbody></table><p><strong>注意：MyISAM 在执行查询语句之前，会自动给涉及的所有表加读锁，在执行更新操作前，会自动给涉及的表加写锁，这个过程并不需要用户干预，因此用户一般不需要使用命令来显式加锁，上例中的加锁时为了演示效果。</strong></p><p><strong>MyISAM 的并发插入问题：</strong></p><p>MyISAM 表的读和写是串行的，这是就总体而言的，在一定条件下，MyISAM 也支持查询和插入操作的并发执行</p><table><thead><tr><th align="center">session1</th><th align="center">session2</th></tr></thead><tbody><tr><td align="center">获取表的read local锁定<br>lock table mylock read local</td><td align="center"></td></tr><tr><td align="center">当前session不能对表进行更新或者插入操作<br>insert into mylock values(6,’f’)<br>Table ‘mylock’ was locked with a READ lock and can’t be updated<br>update mylock set name=’aa’ where id = 1;<br>Table ‘mylock’ was locked with a READ lock and can’t be updated</td><td align="center">其他session可以查询该表的记录<br>select* from mylock</td></tr><tr><td align="center">当前session不能查询没有锁定的表<br>select * from person<br>Table ‘person’ was not locked with LOCK TABLES</td><td align="center">其他session可以进行<font color="red">插入</font>操作，但是<font color="red">更新</font>会阻塞<br>update mylock set name = ‘aa’ where id = 1;</td></tr><tr><td align="center">当前session不能访问其他session插入的记录；</td><td align="center"></td></tr><tr><td align="center">释放锁资源：unlock tables</td><td align="center">当前session获取锁，更新操作完成</td></tr><tr><td align="center">当前session可以查看其他session插入的记录</td><td align="center"></td></tr></tbody></table><p> 可以通过检查 <code>table_locks_waited</code> 和 <code>table_locks_immediate</code>状态变量来分析系统上的表锁定争夺：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show status like 'table%';</span><br><span class="line">+<span class="comment">-----------------------+-------+</span></span><br><span class="line">| Variable_name         | Value |</span><br><span class="line">+<span class="comment">-----------------------+-------+</span></span><br><span class="line">| Table_locks_immediate | 352   |</span><br><span class="line">| Table_locks_waited    | 2     |</span><br><span class="line">+<span class="comment">-----------------------+-------+</span></span><br><span class="line"><span class="comment">--如果 Table_locks_waited 的值比较高，则说明存在着较严重的表级锁争用情况。</span></span><br></pre></td></tr></table></figure><h2 id="InnoDB锁"><a href="#InnoDB锁" class="headerlink" title="InnoDB锁"></a>InnoDB锁</h2><p>可以通过检查 <code>Innodb_row_lock</code> 状态变量来分析系统上的行锁的争夺情况：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show status like 'innodb_row_lock%';</span><br><span class="line">+<span class="comment">-------------------------------+-------+</span></span><br><span class="line">| Variable_name                 | Value |</span><br><span class="line">+<span class="comment">-------------------------------+-------+</span></span><br><span class="line">| Innodb_row_lock_current_waits | 0     |</span><br><span class="line">| Innodb_row_lock_time          | 18702 |</span><br><span class="line">| Innodb_row_lock_time_avg      | 18702 |</span><br><span class="line">| Innodb_row_lock_time_max      | 18702 |</span><br><span class="line">| Innodb_row_lock_waits         | 1     |</span><br><span class="line">+<span class="comment">-------------------------------+-------+</span></span><br><span class="line"><span class="comment">--如果发现锁争用比较严重，如InnoDB_row_lock_waits和InnoDB_row_lock_time_avg的值比较高</span></span><br></pre></td></tr></table></figure><p><strong>InnoDB的行锁模式及加锁方法</strong>：</p><ul><li><strong>共享锁（s）</strong>：又称读锁。允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。若事务 T 对数据对象 A 加上 S 锁，则事务 T 可以读 A 但不能修改 A，其他事务只能再对 A 加 S 锁，而不能加 X 锁，直到 T 释放 A 上的 S 锁，这保证了其他事务可以读 A，但在 T 释放 A 上的 S 锁之前不能对 A 做任何修改；<br>​</li><li><strong>排他锁（x）</strong>：又称写锁。允许获取排他锁的事务更新数据，阻止其他事务取得相同的数据集共享读锁和排他写锁。若事务 T 对数据对象 A 加上 X 锁，事务 T 可以读 A 也可以修改 A，其他事务不能再对 A 加任何锁，直到 T 释放 A 上的锁。</li></ul><p>​MySQL InnoDB引 擎默认的修改数据语句：<strong>update, delete, insert都会自动给涉及到的数据加上排他锁，select 语句默认不会加任何锁类型</strong>，如果加排他锁可以使用 <code>select …for update</code> 语句，加共享锁可以使用 <code>select … lock in share mode</code> 语句。<strong>所以加过排他锁的数据行在其他事务种是不能修改数据的，也不能通过for update和lock in share mode锁的方式查询数据，但可以直接通过select …from…查询数据，因为普通查询没有任何锁机制。</strong> </p><p><strong>InnoDB行锁实现方式</strong>：</p><p>InnoDB 行锁是通过给<strong>索引</strong>上的索引项加锁来实现的，这一点 MySQL 与 Oracle 不同，后者是通过在数据块中对相应数据行加锁来实现的。InnoDB 这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB 才使用行级锁，<strong>否则，InnoDB将使用表锁！</strong>  </p><ul><li>在不通过索引条件查询的时候，InnoDB 使用的是表锁而不是行锁</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tab_no_index(<span class="keyword">id</span> <span class="built_in">int</span>,<span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">10</span>)) <span class="keyword">engine</span>=<span class="keyword">innodb</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tab_no_index <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'1'</span>),(<span class="number">2</span>,<span class="string">'2'</span>),(<span class="number">3</span>,<span class="string">'3'</span>),(<span class="number">4</span>,<span class="string">'4'</span>);</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">session1</th><th align="center">session2</th></tr></thead><tbody><tr><td align="center">set autocommit=0<br>select * from tab_no_index where id = 1;</td><td align="center">set autocommit=0<br>select * from tab_no_index where id =2</td></tr><tr><td align="center">select * from tab_no_index where id = 1 for update</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">select * from tab_no_index where id = 2 for update;</td></tr></tbody></table><p>session1 只给一行加了排他锁，但是 session2 在请求其他行的排他锁的时候，会出现锁等待。原因是在没有索引的情况下，InnoDB 只能使用表锁。</p><ul><li>创建带索引的表进行条件查询，InnoDB 使用的是行锁</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tab_with_index(<span class="keyword">id</span> <span class="built_in">int</span>,<span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">10</span>)) <span class="keyword">engine</span>=<span class="keyword">innodb</span>;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tab_with_index <span class="keyword">add</span> <span class="keyword">index</span> <span class="keyword">id</span>(<span class="keyword">id</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tab_with_index <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'1'</span>),(<span class="number">2</span>,<span class="string">'2'</span>),(<span class="number">3</span>,<span class="string">'3'</span>),(<span class="number">4</span>,<span class="string">'4'</span>);</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">session1</th><th align="center">session2</th></tr></thead><tbody><tr><td align="center">set autocommit=0<br>select * from tab_with_indexwhere id = 1;</td><td align="center">set autocommit=0<br>select * from tab_with_indexwhere id =2</td></tr><tr><td align="center">select * from tab_with_indexwhere id = 1 for update</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">select * from tab_with_indexwhere id = 2 for update;</td></tr></tbody></table><ul><li>由于 MySQL 的行锁是针对索引加的锁，不是针对记录加的锁，所以虽然是访问不同行的记录，但是依然无法访问到具体的数据</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tab_with_index <span class="keyword">drop</span> <span class="keyword">index</span> <span class="keyword">id</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tab_with_index  <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'4'</span>);</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">session1</th><th align="center">session2</th></tr></thead><tbody><tr><td align="center">set autocommit=0</td><td align="center">set autocommit=0</td></tr><tr><td align="center">select * from tab_with_index where id = 1 and name=’1’ for update</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">select * from tab_with_index where id = 1 and name=’4’ for update<br>虽然 session2 访问的是和 session1 不同的记录，但是锁的是具体的表，所以需要等待锁</td></tr></tbody></table><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>对于MyISAM的表锁，主要讨论了以下几点：</strong> </p><ul><li><p>共享读锁（S）之间是兼容的，但共享读锁（S）与排他写锁（X）之间，以及排他写锁（X）之间是互斥的，也就是说读和写是串行的；  </p></li><li><p>在一定条件下，MyISAM 允许查询和插入并发执行，我们可以利用这一点来解决应用中对同一表查询和插入的锁争用问题；</p></li><li><p>MyISAM 默认的锁调度机制是写优先，这并不一定适合所有应用，用户可以通过设置 <code>LOW_PRIORITY_UPDATES</code> 参数，或在 <code>INSERT、UPDATE、DELETE</code> 语句中指定 <code>LOW_PRIORITY</code> 选项来调节读写锁的争用。 </p></li><li><p>由于表锁的锁定粒度大，读写之间又是串行的，因此，如果更新操作较多，MyISAM 表可能会出现严重的锁等待，可以考虑采用 InnoDB 引擎来减少锁冲突。</p></li></ul><p><strong>对于InnoDB表，本文主要讨论了以下几项内容：</strong> </p><ul><li>InnoDB 的行锁是基于索引实现的，如果不通过索引访问数据，InnoDB 会使用表锁；</li><li>在不同的隔离级别下，InnoDB 的锁机制和一致性读策略不同；</li></ul><p>在了解 InnoDB 锁特性后，用户可以通过设计和 SQL 调整等措施减少锁冲突和死锁，包括：</p><ul><li><p>尽量使用较低的隔离级别；精心设计索引，并尽量使用索引访问数据，使加锁更精确，从而减少锁冲突的机会；</p></li><li><p>选择合理的事务大小，小事务发生锁冲突的几率也更小；</p></li><li><p>给记录集显式加锁时，最好一次性请求足够级别的锁。比如要修改数据的话，最好直接申请排他锁，而不是先申请共享锁，修改时再请求排他锁，这样容易产生死锁；</p></li><li><p>不同的程序访问一组表时，应尽量约定以相同的顺序访问各表，对一个表而言，尽可能以固定的顺序存取表中的行。这样可以大大减少死锁的机会；</p></li><li><p>尽量用相等条件访问数据，这样可以避免间隙锁对并发插入的影响；不要申请超过实际需要的锁级别；除非必须，查询时不要显示加锁；</p></li><li><p>对于一些特定的事务，可以使用表锁来提高处理速度或减少死锁的可能。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;MySQL-中锁的基本知识&quot;&gt;&lt;a href=&quot;#MySQL-中锁的基本知识&quot; class=&quot;headerlink&quot; title=&quot;MySQL 中锁的基本知识&quot;&gt;&lt;/a&gt;MySQL 中锁的基本知识&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;锁是计算机协调多个进程或线程并发访问
      
    
    </summary>
    
    
      <category term="数据库" scheme="https://dongzl.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MySQL" scheme="https://dongzl.github.io/tags/MySQL/"/>
    
      <category term="Lock" scheme="https://dongzl.github.io/tags/Lock/"/>
    
  </entry>
  
  <entry>
    <title>JDK ThreadPoolExecutor 源码解析</title>
    <link href="https://dongzl.github.io/2020/03/18/15-ThreadPoolExecutor-Source-Code/"/>
    <id>https://dongzl.github.io/2020/03/18/15-ThreadPoolExecutor-Source-Code/</id>
    <published>2020-03-18T14:02:59.000Z</published>
    <updated>2020-03-23T07:11:15.294Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>学习 Java 的多线程知识就绕不开线程池，提起线程池那就必然要说到 ThreadPoolExecutor 类，自从 <code>阿里巴巴编码规范</code> 问世以来，ThreadPoolExecutor 可能也跟着火了一把，现在随便问个 Java 开发的基本都能背出来<code>线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险</code>。</p><p>笔者所参与的项目中很多地方都使用了线程池的 ThreadPoolExecutor 类去自定义线程池的一些参数。当然凡事没有绝对，使用 Executors 去创建线程池也是有的，如果只是开启数量可控的很少的线程去执行任务，也没必要大动干戈。</p><p><strong>为什么需要线程池</strong>：<br>在实际使用中，线程是很占用系统资源的，如果对线程管理不善，很容易导致系统问题。因此，在大多数并发框架中都会使用线程池来管理线程，使用线程池管理线程主要有如下好处:</p><ul><li>使用线程池可以重复利用已有的线程继续执行任务，避免线程在创建和销毁时造成的消耗；</li><li>由于没有线程创建和销毁时的消耗，可以提高系统响应速度；</li><li>通过线程可以对线程进行合理的管理，根据系统的承受能力调整可运行<br>线程数量的大小等。</li></ul><h2 id="线程池工作原理"><a href="#线程池工作原理" class="headerlink" title="线程池工作原理"></a>线程池工作原理</h2><img src="https://gitee.com/dongzl/article-images/raw/master/2020/15-ThreadPoolExecutor-Source-Code/ThreadPoolExecutor-Source-Code-04.png"><p>线程池执行所提交的任务过程: </p><ul><li>先判断线程池中核心线程池所有的线程是否都在执行任务。如果不是，则新创建一个线程执行刚提交的任务，否则，核心线程池中所有的线程都在执行任务，则进入第2步;</li><li>判断当前阻塞队列是否已满，如果未满，则将提交的任务放置在阻塞队列中；否则，则进入第3步；</li><li>判断线程池中所有的线程是否都在执行任务，如果没有，则创建一个新的线程来执行任务，否则，则交给饱和策略进行处理。</li></ul><img src="https://gitee.com/dongzl/article-images/raw/master/2020/15-ThreadPoolExecutor-Source-Code/ThreadPoolExecutor-Source-Code-05.png"><h2 id="JDK-自带线程池实现"><a href="#JDK-自带线程池实现" class="headerlink" title="JDK 自带线程池实现"></a>JDK 自带线程池实现</h2><img src="https://gitee.com/dongzl/article-images/raw/master/2020/15-ThreadPoolExecutor-Source-Code/ThreadPoolExecutor-Source-Code-01.png"><table><thead><tr><th>线程池</th><th>corePoolSize</th><th>maximumPoolSize</th><th>keepAliveTime</th><th>unit</th><th>workQueue</th><th>threadFactory</th><th>handler</th></tr></thead><tbody><tr><td>newCachedThreadPool</td><td>0</td><td>Integer.MAX_VALUE</td><td>60</td><td>TimeUnit.SECONDS</td><td>SynchronousQueue</td><td>DefaultThreadFactory</td><td>AbortPolicy</td></tr><tr><td>newFixedThreadPool</td><td>nThreads</td><td>nThreads</td><td>0</td><td>TimeUnit.MILLISECONDS</td><td>LinkedBlockingQueue</td><td>DefaultThreadFactory</td><td>AbortPolicy</td></tr><tr><td>newSingleThreadExecutor</td><td>1</td><td>1</td><td>0</td><td>TimeUnit.MILLISECONDS</td><td>LinkedBlockingQueue</td><td>DefaultThreadFactory</td><td>AbortPolicy</td></tr><tr><td>newSingleThreadScheduledExecutor</td><td>1</td><td>Integer.MAX_VALUE</td><td>0</td><td>TimeUnit.NANOSECONDS</td><td>DelayedWorkQueue</td><td>DefaultThreadFactory</td><td>AbortPolicy</td></tr><tr><td>newSingleThreadScheduledExecutor</td><td>corePoolSize</td><td>Integer.MAX_VALUE</td><td>0</td><td>TimeUnit.NANOSECONDS</td><td>DelayedWorkQueue</td><td>DefaultThreadFactory</td><td>AbortPolicy</td></tr><tr><td>newWorkStealingPool</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr></tbody></table><p>补充： </p><ul><li><p>各种线程池实现中 threadFactory 参数可以自定义，也可以使用使用 JDK 默认 <code>DefaultThreadFactory</code> 实现类。</p></li><li><p><code>newWorkStealingPool</code> 属于 <code>ForkJoinPool</code> 线程池框架内容，实现上比较特殊。</p></li></ul><p>参数说明</p><ul><li>corePoolSize:核心线程池的大小。</li><li>maximumPoolSize:线程池能创建线程的最大个数</li><li>keepAliveTime:空闲线程存活时间</li><li>unit: 时间单位，为keepAlive Time指定时间单位</li><li>workQueue:阻塞队列，用于保存任务的阻塞队列</li><li>threadFactory: 创建线程的工程类</li><li>handler:饱和策略(拒绝策略)</li></ul><h2 id="JDK-自带阻塞队列实现"><a href="#JDK-自带阻塞队列实现" class="headerlink" title="JDK 自带阻塞队列实现"></a>JDK 自带阻塞队列实现</h2><img src="https://gitee.com/dongzl/article-images/raw/master/2020/15-ThreadPoolExecutor-Source-Code/ThreadPoolExecutor-Source-Code-02.png"><h2 id="线程池的生命周期"><a href="#线程池的生命周期" class="headerlink" title="线程池的生命周期"></a>线程池的生命周期</h2><img src="https://gitee.com/dongzl/article-images/raw/master/2020/15-ThreadPoolExecutor-Source-Code/ThreadPoolExecutor-Source-Code-03.png"><ul><li><p>RUNNING：能接受新提交的任务，并且也能处理阻塞队列中的任务；</p></li><li><p>SHUTDOWN：关闭状态，不再接受新提交的任务，但却可以继续处理阻<br>塞队列中已保存的任务；</p></li><li><p>STOP：不能接受新任务，也不处理队列中的任务，会中断正在处理任务的<br>线程；</p></li><li><p>TIDYING：如果所有的任务都已终止了，workerCount(有效线程数)为0，线程池进入该状态后会调用terminated()方法进入TERMINATED状态；</p></li><li><p>TERMINATED：在 terminated (方法执行完后进入该状态，默认<br>terminated()方法中什么也没有做。</p></li></ul><h2 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h2><ul><li><code>ThreadPoolExecutor.AbortPolicy</code>：丢弃任务并抛出 <code>RejectedExecutionException</code> 异常；</li><li><code>ThreadPoolExecutor.DiscardPolicy</code>：也是丢弃任务，但是不抛<br>出异常；</li><li><code>ThreadPoolExecutor.DiscardOldestPolicy</code>：丢弃队列最前面的<br>任务，然后重新尝试执行任务(重复此过程)；</li><li><code>ThreadPoolExecutor.CallerRunsPolicy</code>：由调用线程处理该任务。</li></ul><h2 id="ThreadPoolExecutor-源码解析"><a href="#ThreadPoolExecutor-源码解析" class="headerlink" title="ThreadPoolExecutor 源码解析"></a>ThreadPoolExecutor 源码解析</h2><h3 id="常用变量的解释"><a href="#常用变量的解释" class="headerlink" title="常用变量的解释"></a>常用变量的解释</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. `ctl`，可以看做一个int类型的数字，高3位表示线程池状态，低29位表示worker数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"><span class="comment">// 2. `COUNT_BITS`，`Integer.SIZE`为32，所以`COUNT_BITS`为29</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"><span class="comment">// 3. `CAPACITY`，线程池允许的最大线程数。1左移29位，然后减1，即为 2^29 - 1</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// runState is stored in the high-order bits</span></span><br><span class="line"><span class="comment">// 4. 线程池有5种状态，按大小排序如下：RUNNING &lt; SHUTDOWN &lt; STOP &lt; TIDYING &lt; TERMINATED</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Packing and unpacking ctl</span></span><br><span class="line"><span class="comment">// 5. `runStateOf()`，获取线程池状态，通过按位与操作，低29位将全部变成0</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span>     </span>&#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125;</span><br><span class="line"><span class="comment">// 6. `workerCountOf()`，获取线程池worker数量，通过按位与操作，高3位将全部变成0</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span>  </span>&#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;</span><br><span class="line"><span class="comment">// 7. `ctlOf()`，根据线程池状态和线程池worker数量，生成ctl值</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>&#123; <span class="keyword">return</span> rs | wc; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Bit field accessors that don't require unpacking ctl.</span></span><br><span class="line"><span class="comment"> * These depend on the bit layout and on workerCount being never negative.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 8. `runStateLessThan()`，线程池状态小于xx</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">runStateLessThan</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c &lt; s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 9. `runStateAtLeast()`，线程池状态大于等于xx</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">runStateAtLeast</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c &gt;= s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 基本类型参数校验</span></span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="comment">// 空指针校验</span></span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="comment">// 根据传入参数`unit`和`keepAliveTime`，将存活时间转换为纳秒存到变量`keepAliveTime `中</span></span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="提交执行-task-的过程"><a href="#提交执行-task-的过程" class="headerlink" title="提交执行 task 的过程"></a>提交执行 task 的过程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Proceed in 3 steps:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 1. If fewer than corePoolSize threads are running, try to</span></span><br><span class="line"><span class="comment">     * start a new thread with the given command as its first</span></span><br><span class="line"><span class="comment">     * task.  The call to addWorker atomically checks runState and</span></span><br><span class="line"><span class="comment">     * workerCount, and so prevents false alarms that would add</span></span><br><span class="line"><span class="comment">     * threads when it shouldn't, by returning false.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 2. If a task can be successfully queued, then we still need</span></span><br><span class="line"><span class="comment">     * to double-check whether we should have added a thread</span></span><br><span class="line"><span class="comment">     * (because existing ones died since last checking) or that</span></span><br><span class="line"><span class="comment">     * the pool shut down since entry into this method. So we</span></span><br><span class="line"><span class="comment">     * recheck state and if necessary roll back the enqueuing if</span></span><br><span class="line"><span class="comment">     * stopped, or start a new thread if there are none.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 3. If we cannot queue task, then we try to add a new</span></span><br><span class="line"><span class="comment">     * thread.  If it fails, we know we are shut down or saturated</span></span><br><span class="line"><span class="comment">     * and so reject the task.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="comment">// worker数量比核心线程数小，直接创建worker执行任务</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// worker数量超过核心线程数，任务直接进入队列</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="comment">// 线程池状态不是RUNNING状态，说明执行过shutdown命令，需要对新加入的任务执行reject()操作。</span></span><br><span class="line">        <span class="comment">// 这儿为什么需要recheck，是因为任务入队列前后，线程池的状态可能会发生变化。</span></span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="comment">// 这儿为什么需要判断0值，主要是在线程池构造方法中，核心线程数允许为0</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果线程池不是运行状态，或者任务进入队列失败，则尝试创建worker执行任务。</span></span><br><span class="line">    <span class="comment">// 这儿有3点需要注意：</span></span><br><span class="line">    <span class="comment">// 1. 线程池不是运行状态时，addWorker内部会判断线程池状态</span></span><br><span class="line">    <span class="comment">// 2. addWorker第2个参数表示是否创建核心线程</span></span><br><span class="line">    <span class="comment">// 3. addWorker返回false，则说明任务执行失败，需要执行reject操作</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="addworker-源码解析"><a href="#addworker-源码解析" class="headerlink" title="addworker 源码解析"></a>addworker 源码解析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">    retry:</span><br><span class="line">    <span class="comment">// 外层自旋</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这个条件写得比较难懂，我对其进行了调整，和下面的条件等价</span></span><br><span class="line">        <span class="comment">// (rs &gt; SHUTDOWN) || </span></span><br><span class="line">        <span class="comment">// (rs == SHUTDOWN &amp;&amp; firstTask != null) || </span></span><br><span class="line">        <span class="comment">// (rs == SHUTDOWN &amp;&amp; workQueue.isEmpty())</span></span><br><span class="line">        <span class="comment">// 1. 线程池状态大于SHUTDOWN时，直接返回false</span></span><br><span class="line">        <span class="comment">// 2. 线程池状态等于SHUTDOWN，且firstTask不为null，直接返回false</span></span><br><span class="line">        <span class="comment">// 3. 线程池状态等于SHUTDOWN，且队列为空，直接返回false</span></span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">               firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">               ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 内层自旋</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">            <span class="comment">// worker数量超过容量，直接返回false</span></span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// 使用CAS的方式增加worker数量。</span></span><br><span class="line">            <span class="comment">// 若增加成功，则直接跳出外层循环进入到第二部分</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">            c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">            <span class="comment">// 线程池状态发生变化，对外层循环进行自旋</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">            <span class="comment">// 其他情况，直接内层循环进行自旋即可</span></span><br><span class="line">            <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">    Worker w = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">        <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">            <span class="comment">// worker的添加必须是串行的，因此需要加锁</span></span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// Recheck while holding lock.</span></span><br><span class="line">                <span class="comment">// Back out on ThreadFactory failure or if</span></span><br><span class="line">                <span class="comment">// shut down before lock acquired.</span></span><br><span class="line">                <span class="comment">// 这儿需要重新检查线程池状态</span></span><br><span class="line">                <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    <span class="comment">// worker已经调用过了start()方法，则不再创建worker</span></span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                    <span class="comment">// worker创建并添加到workers成功</span></span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    <span class="comment">// 更新`largestPoolSize`变量</span></span><br><span class="line">                    <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 启动worker线程</span></span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// worker线程启动失败，说明线程池状态发生了变化（关闭操作被执行），需要进行shutdown相关操作</span></span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程池-worker-任务单元"><a href="#线程池-worker-任务单元" class="headerlink" title="线程池 worker 任务单元"></a>线程池 worker 任务单元</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This class will never be serialized, but we provide a</span></span><br><span class="line"><span class="comment">     * serialVersionUID to suppress a javac warning.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6138294804551838833L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Thread this worker is running in.  Null if factory fails. */</span></span><br><span class="line">    <span class="keyword">final</span> Thread thread;</span><br><span class="line">    <span class="comment">/** Initial task to run.  Possibly null. */</span></span><br><span class="line">    Runnable firstTask;</span><br><span class="line">    <span class="comment">/** Per-thread task counter */</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> completedTasks;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates with given first task and thread from ThreadFactory.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> firstTask the first task (null if none)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Worker(Runnable firstTask) &#123;</span><br><span class="line">        setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker</span></span><br><span class="line">        <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">        <span class="comment">// 这儿是Worker的关键所在，使用了线程工厂创建了一个线程。传入的参数为当前worker</span></span><br><span class="line">        <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Delegates main run loop to outer runWorker  */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        runWorker(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="核心线程执行逻辑-runWorker"><a href="#核心线程执行逻辑-runWorker" class="headerlink" title="核心线程执行逻辑-runWorker"></a>核心线程执行逻辑-runWorker</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    Thread wt = Thread.currentThread();</span><br><span class="line">    Runnable task = w.firstTask;</span><br><span class="line">    w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 调用unlock()是为了让外部可以中断</span></span><br><span class="line">    w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">    <span class="comment">// 这个变量用于判断是否进入过自旋（while循环）</span></span><br><span class="line">    <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 这儿是自旋</span></span><br><span class="line">        <span class="comment">// 1. 如果firstTask不为null，则执行firstTask；</span></span><br><span class="line">        <span class="comment">// 2. 如果firstTask为null，则调用getTask()从队列获取任务。</span></span><br><span class="line">        <span class="comment">// 3. 阻塞队列的特性就是：当队列为空时，当前线程会被阻塞等待</span></span><br><span class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 这儿对worker进行加锁，是为了达到下面的目的</span></span><br><span class="line">            <span class="comment">// 1. 降低锁范围，提升性能</span></span><br><span class="line">            <span class="comment">// 2. 保证每个worker执行的任务是串行的</span></span><br><span class="line">            w.lock();</span><br><span class="line">            <span class="comment">// If pool is stopping, ensure thread is interrupted;</span></span><br><span class="line">            <span class="comment">// if not, ensure thread is not interrupted.  This</span></span><br><span class="line">            <span class="comment">// requires a recheck in second case to deal with</span></span><br><span class="line">            <span class="comment">// shutdownNow race while clearing interrupt</span></span><br><span class="line">            <span class="comment">// 如果线程池正在停止，则对当前线程进行中断操作</span></span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                 (Thread.interrupted() &amp;&amp;</span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            <span class="comment">// 执行任务，且在执行前后通过`beforeExecute()`和`afterExecute()`来扩展其功能。</span></span><br><span class="line">            <span class="comment">// 这两个方法在当前类里面为空实现。</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 帮助gc</span></span><br><span class="line">                task = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 已完成任务数加一 </span></span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 自旋操作被退出，说明线程池正在结束</span></span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://mp.weixin.qq.com/s/ahHKn8qs96bTHURQlcvuNA" target="_blank" rel="noopener">Java 线程池 ThreadPoolExecutor 八种拒绝策略浅析</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;学习 Java 的多线程知识就绕不开线程池，提起线程池那就必然要说到 ThreadPoolExecutor 类，自从 &lt;code&gt;阿里巴巴编
      
    
    </summary>
    
    
      <category term="java开发" scheme="https://dongzl.github.io/categories/java%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="ThreadPoolExecutor" scheme="https://dongzl.github.io/tags/ThreadPoolExecutor/"/>
    
      <category term="线程池" scheme="https://dongzl.github.io/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>Redis 高可用之主从复制</title>
    <link href="https://dongzl.github.io/2020/03/17/14-Redis-HA-Master-Salve/"/>
    <id>https://dongzl.github.io/2020/03/17/14-Redis-HA-Master-Salve/</id>
    <published>2020-03-17T10:39:21.000Z</published>
    <updated>2020-03-22T15:07:59.112Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景描述"><a href="#背景描述" class="headerlink" title="背景描述"></a>背景描述</h2><p>单机的 Redis，能够承载的 QPS 大概就在十万左右。对于缓存来说，一般都是用来支撑读高并发的，做成 <code>master-slave</code> 架构，一主多从，<code>master</code> 节点负责写，并且将数据复制到其它的 <code>slave</code> 节点，<code>slave</code> 节点负责读，所有的读请求全部走 <code>slave</code> 节点，这样也可以很轻松实现水平扩容，支撑读高并发。</p><h2 id="Redis-replication-的核心机制"><a href="#Redis-replication-的核心机制" class="headerlink" title="Redis replication 的核心机制"></a>Redis replication 的核心机制</h2><ul><li>Redis 采用异步方式复制数据到 slave 节点，不过 Redis2.8 开始，slave node 会周期性地确认自己每次复制的数据量；</li><li>一个 master node 是可以配置多个 slave node 的；</li><li>slave node 也可以连接其他的 slave node；</li><li>slave node 做复制的时候，不会阻塞 master node 的正常读写；</li><li>slave node 在做复制的时候，也不会阻塞对自己的读操作，它会用旧的数据集来提供服务；但是复制完成的时候，需要删除旧数据集，加载新数据集，这个时候会暂停服务；</li><li>slave node 主要用来进行横向扩容，做读写分离，扩容的 slave node 可以提高读的吞吐量。</li></ul><p>PS. 如果采用了主从架构，那么建议必须开启 master node 的持久化，不建议用 slave node 作为 master node 的数据热备，因为如果关掉了 master 的持久化，可能在 master 宕机重启后数据是空的，这个时候 slave node 做数据同步，slave node 的数据也丢了。</p><p>另外，master node 也需要进行各种备份。一旦本地的所有文件丢失了，从备份中挑选一份 RDB 文件去恢复 master 数据，这样才能确保启动的时候，是有数据的，防止数据全部丢失。</p><h2 id="Redis-主从复制的核心原理"><a href="#Redis-主从复制的核心原理" class="headerlink" title="Redis 主从复制的核心原理"></a>Redis 主从复制的核心原理</h2><p>当启动一个 slave node 的时候，它会发送一个 <code>PSYNC</code> 命令给 master node。如果这是 slave node 初次连接到 master node，那么会触发一次 <code>full resynchronization</code> 全量复制。此时 master 会启动一个后台线程，开始生成一份 RDB 快照文件，同时还会将客户端 client 新收到的所有写命令缓存在内存中。RDB 文件生成完毕后， master 会将这个 RDB 文件发送给 slave，slave 会先写入本地磁盘，然后再从本地磁盘加载到内存中，接着 master 会将内存中缓存的写命令发送到 slave，slave 也会同步这些数据。slave node 如果跟 master node 有网络故障，断开了连接，会自动重连，连接之后 master node 仅会复制给 slave 部分缺少的数据。</p><img src="https://gitee.com/dongzl/article-images/raw/master/2020/14-Redis-HA-Master-Salve/Redis-HA-Master-Salve-01.png"><h3 id="主从复制的断点续传"><a href="#主从复制的断点续传" class="headerlink" title="主从复制的断点续传"></a>主从复制的断点续传</h3><p>从 Redis2.8 开始，就支持主从复制的断点续传，如果主从复制过程中，网络连接断掉了，那么可以接着上次复制的地方，继续复制下去，而不是从头开始复制一份。</p><p>master node 会在内存中维护一个 <code>backlog</code>，master 和 slave 都会保存一个 <code>replica offset</code> 还有一个 <code>master run id</code>，<code>offset</code> 就是保存在 <code>backlog</code> 中的。如果 master 和 slave 网络连接断掉了，slave 会让 master 从上次 <code>replica offset</code> 开始继续复制，如果没有找到对应的 <code>offset</code>，那么就会执行一次 <code>resynchronization</code>。</p><blockquote><p>如果根据 host + ip 定位 master node，是不靠谱的，如果 master node 重启或者数据发生了变化，那么 slave node 应该根据不同的 run id 区分。</p></blockquote><h3 id="无磁盘化复制"><a href="#无磁盘化复制" class="headerlink" title="无磁盘化复制"></a>无磁盘化复制</h3><p>master 在内存中直接创建 <code>RDB</code>，然后发送给 slave，不会在自己本地落地磁盘了。只需要在配置文件中开启 <code>repl-diskless-sync yes</code> 即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">repl-diskless-sync yes</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 等待 5s 后再开始复制，因为要等更多 slave 重新连接过来</span></span><br><span class="line">repl-diskless-sync-delay 5</span><br></pre></td></tr></table></figure><h3 id="slave-对过期-key-处理"><a href="#slave-对过期-key-处理" class="headerlink" title="slave 对过期 key 处理"></a>slave 对过期 key 处理</h3><p>slave 不会处理过期 key，只会等待 master 过期 key。如果 master 过期了一个 key，或者通过 LRU 淘汰了一个 key，那么会模拟一条 del 命令发送给 slave。</p><h2 id="复制的完整流程"><a href="#复制的完整流程" class="headerlink" title="复制的完整流程"></a>复制的完整流程</h2><p>slave node 启动时，会在自己本地保存 master node 的信息，包括 master node 的 <code>host</code> 和 <code>ip</code>，但是复制流程没开始。</p><p>slave node 内部有个定时任务，每秒检查是否有新的 master node 要连接和复制，如果发现，就跟 master node 建立 <code>socket</code> 网络连接。然后 slave node 发送 <code>ping</code> 命令给 master node。如果 master 设置了 <code>requirepass</code>，那么 slave node 必须发送 <code>masterauth</code> 的口令过去进行认证。master node 第一次执行全量复制，将所有数据发给 slave node。而在后续，master node 持续将写命令，异步复制给 slave node。</p><img src="https://gitee.com/dongzl/article-images/raw/master/2020/14-Redis-HA-Master-Salve/Redis-HA-Master-Salve-02.png"><h3 id="全量复制"><a href="#全量复制" class="headerlink" title="全量复制"></a>全量复制</h3><ul><li><p>master 执行 <code>bgsave</code>，在本地生成一份 <code>RDB</code> 快照文件；</p></li><li><p>master node 将 RDB 快照文件发送给 slave node，如果 RDB 复制时间超过 <code>60</code> 秒（<code>repl-timeout</code>），那么 slave node 就会认为复制失败，所以需要根据实际情况适当调大这个参数；</p></li><li><p>master node 在生成 RDB 文件时，会将所有新的写命令缓存在内存中，在 slave node 保存了 RDB 之后，再将新的写命令复制给 slave node。</p></li><li><p>如果在复制期间，内存缓冲区持续消耗超过 <code>64MB</code>，或者一次性超过 <code>256MB</code>，那么将会停止复制，复制失败；</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client-output-buffer-limit slave 256MB 64MB 60</span><br></pre></td></tr></table></figure><ul><li><p>slave node 接收到 <code>RDB</code> 之后，清空自己的旧数据，然后重新加载 <code>RDB</code> 到自己的内存中，同时基于旧的数据版本对外提供服务；</p></li><li><p>如果 slave node 开启了 <code>AOF</code>，那么会立即执行 <code>BGREWRITEAOF</code>，重写 <code>AOF</code>。</p></li></ul><img src="https://gitee.com/dongzl/article-images/raw/master/2020/14-Redis-HA-Master-Salve/Redis-HA-Master-Salve-03.png"><img src="https://gitee.com/dongzl/article-images/raw/master/2020/14-Redis-HA-Master-Salve/Redis-HA-Master-Salve-04.png"><h3 id="增量复制"><a href="#增量复制" class="headerlink" title="增量复制"></a>增量复制</h3><ul><li><p>如果全量复制过程中，master-slave 网络连接断掉，那么 slave 重新连接 master 时，会触发增量复制；</p></li><li><p>master 直接从自己的 <code>backlog</code> 中获取部分丢失的数据，发送给 slave node，默认 <code>backlog</code> 就是 <code>1MB</code>。</p></li><li><p>master 就是根据 slave 发送的 <code>psync</code> 中的 <code>offset</code> 来从 <code>backlog</code> 中获取数据的。</p></li></ul><h3 id="heartbeat"><a href="#heartbeat" class="headerlink" title="heartbeat"></a>heartbeat</h3><p>主从节点互相都会发送 <code>heartbeat</code> 信息。</p><p>master 默认每隔 <code>10秒</code> 发送一次 <code>heartbeat</code>，slave node 每隔 <code>1秒</code> 发送一个 <code>heartbeat</code>。</p><h3 id="异步复制"><a href="#异步复制" class="headerlink" title="异步复制"></a>异步复制</h3><p>master 每次接收到写命令之后，先在内部写入数据，然后异步发送给 slave node。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><p><a href="https://blog.csdn.net/juded/article/details/90245371" target="_blank" rel="noopener">Redis：解决异步复制丢失、脑裂数据丢失状况</a></p></li><li><p><a href="https://github.com/antirez/redis-doc/blob/master/topics/replication.md" target="_blank" rel="noopener">Replication</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/91770135" target="_blank" rel="noopener">如何保障mysql和redis之间的数据一致性？</a></p></li><li><p><a href="https://blog.51cto.com/14257804/2376731" target="_blank" rel="noopener">深入Redis 主从复制原理</a></p></li><li><p><a href="https://www.cnblogs.com/leeSmall/p/8398401.html" target="_blank" rel="noopener">Redis系列八：redis主从复制和哨兵</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景描述&quot;&gt;&lt;a href=&quot;#背景描述&quot; class=&quot;headerlink&quot; title=&quot;背景描述&quot;&gt;&lt;/a&gt;背景描述&lt;/h2&gt;&lt;p&gt;单机的 Redis，能够承载的 QPS 大概就在十万左右。对于缓存来说，一般都是用来支撑读高并发的，做成 &lt;code&gt;mas
      
    
    </summary>
    
    
      <category term="架构设计" scheme="https://dongzl.github.io/categories/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="Redis" scheme="https://dongzl.github.io/tags/Redis/"/>
    
      <category term="主从复制" scheme="https://dongzl.github.io/tags/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>Kafka 是如何解决使用 MQ 中容易出现的一些问题</title>
    <link href="https://dongzl.github.io/2020/03/16/13-Solve-MQ-Problem-With-Kafka/"/>
    <id>https://dongzl.github.io/2020/03/16/13-Solve-MQ-Problem-With-Kafka/</id>
    <published>2020-03-16T12:58:08.000Z</published>
    <updated>2020-03-23T07:04:00.933Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景描述"><a href="#背景描述" class="headerlink" title="背景描述"></a>背景描述</h2><p>目前，很多的业务系统都会或多或少的使用各种 MQ 消息队列框架，例如：<code>RabbitMQ</code>、<code>Kafka</code>、<code>RocketMQ</code> 等等，使用 MQ 消息队列，可以满足业务系统 <code>解耦</code>、<code>异步</code>、<code>削峰填谷</code> 场景的需要，但是使用 MQ 中也不得不面临一些问题，这些问题总结如下：</p><blockquote><p>1、如何保证消息队列的高可用？<br>2、如何保证消息不被重复消费？（如何保证消息消费的幂等性）<br>3、如何保证消息的可靠传输？（如何处理消息丢失的问题）<br>4、如何保证消息的顺序性？</p></blockquote><p>其实这些问题也是在面试中 MQ 经常被问到的问题，下面我们就总结分析一下，Kafka 中是如何解决上述问题的。</p><h2 id="Kafka-如何保证高可用"><a href="#Kafka-如何保证高可用" class="headerlink" title="Kafka 如何保证高可用"></a>Kafka 如何保证高可用</h2><p>Kafka 的基本架构组成是：由多个 broker 组成一个集群，每个 broker 是一个节点；当创建一个 topic 时，这个 topic 会被划分为多个 partition，每个 partition 可以存在于不同的 broker 上，每个 partition 只存放一部分数据。</p><p>这就是<strong>天然的分布式消息队列</strong>，就是说一个 topic 的数据，是<strong>分散放在多个机器上的，每个机器就放一部分数据</strong>。</p><p>在 Kafka 0.8 版本之前，是没有 HA 机制的，当任何一个 broker 所在节点宕机了，这个 broker 上的 partition 就无法提供读写服务，所以这个版本之前，Kafka 没有什么高可用性可言。</p><p>在 Kafka 0.8 以后，提供了 HA 机制，就是 replica 副本机制。每个 partition 上的数据都会同步到其它机器，形成自己的多个 replica 副本。所有 replica 会选举一个 leader 出来，消息的生产者和消费者都跟这个 leader 打交道，其他 replica 作为 follower。写的时候，leader 会负责把数据同步到所有 follower 上去，读的时候就直接读 leader 上的数据即可。Kafka 负责均匀的将一个 partition 的所有 replica 分布在不同的机器上，这样才可以提高容错性。</p><p>&lt;插入图片&gt; @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</p><p>拥有了 replica 副本机制，如果某个 broker 宕机了，这个 broker 上的 partition 在其他机器上还存在副本。如果这个宕机的 broker 上面有某个 partition 的 leader，那么此时会从其 follower 中重新选举一个新的 leader 出来，这个新的 leader 会继续提供读写服务，这就有达到了所谓的高可用性。</p><p>写数据的时候，生产者只将数据写入 leader 节点，leader 会将数据写入本地磁盘，接着其他 follower 会主动从 leader 来拉取数据，follower 同步好数据了，就会发送 ack 给 leader，leader 收到所有 follower 的 ack 之后，就会返回写成功的消息给生产者。</p><p>消费数据的时候，消费者只会从 leader 节点去读取消息，但是只有当一个消息已经被所有 follower 都同步成功返回 ack 的时候，这个消息才会被消费者读到。</p><p>&lt;插入图片&gt; @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</p><h2 id="使用-Kafka，如何保证消息不被重复消费"><a href="#使用-Kafka，如何保证消息不被重复消费" class="headerlink" title="使用 Kafka，如何保证消息不被重复消费"></a>使用 Kafka，如何保证消息不被重复消费</h2><h3 id="Kafka-在什么场景下会导致消费者消费到重复数据"><a href="#Kafka-在什么场景下会导致消费者消费到重复数据" class="headerlink" title="Kafka 在什么场景下会导致消费者消费到重复数据"></a>Kafka 在什么场景下会导致消费者消费到重复数据</h3><p>Kafka 实际上有个 offset 的概念，就是每个消息写到 partition 里，都会有一个 offset，代表消息的序号，在 consumer 消费了数据之后，<strong>每隔一段时间（定时定期）</strong>，consumer 会把自己消费过的消息的 offset 提交一下，表示<strong>这些消息已经消费过了，如果发生异常，下次我将从上次消费到的 offset 来继续消费</strong>。</p><p>但是这个过程还是会有意外出现，比如 consumer 机器突然宕机，这会导致 consumer 有些消息已经处理了，但是没来得及提交 offset，这个时候重启之后，就会有少数宕机之前会来得及提交 offset 的消息会被再消费一次。</p><h3 id="如何解决消费到重复数据问题"><a href="#如何解决消费到重复数据问题" class="headerlink" title="如何解决消费到重复数据问题"></a>如何解决消费到重复数据问题</h3><p>对于重复消费的问题，我理解对于任何 MQ 消息队列都是无法避免的，所以就需要我们在业务系统进行<strong>重复消费的幂等性</strong>验证，当然也要考虑业务场景需要，比如一个日志采集系统，每天上千万的数据，某条重复数据的影响几乎可以忽略不计，这个时候也是不需要考虑；如果是其他场景，需要保证幂等性，可以从如下几方面考虑：</p><ul><li>如果是写数据库，可以将消息中的某个字段做为数据库唯一约束，在数据处理之前，先根据唯一约束查询一下，判断是否已经消费过；</li><li>如果是写入 Redis，可以直接调用 set 方法，天然具备幂等性；</li><li>在生产者发送每消息的时候，在消息里面加一个全局唯一的 id，类似订单 id 之类的数据，当消费到这个数据之后，先根据这个全局 id 去比如 Redis 里查一下，如果不存在，说明没有消费过，就继续处理，然后这个 id 写 Redis；如果存在，说明已经消费过，消息直接丢弃。</li></ul><h2 id="使用-Kafka，如何保证消息的可靠传输"><a href="#使用-Kafka，如何保证消息的可靠传输" class="headerlink" title="使用 Kafka，如何保证消息的可靠传输"></a>使用 Kafka，如何保证消息的可靠传输</h2><p>对于保证消息的可靠传输，其实就是如何解决消息丢失的问题；那么我们首先需要弄明白消息为什么会丢失，对于一个消息队列，会有 <code>生产者</code>、<code>MQ</code>、<code>消费者</code> 这三个角色，在这三个角色数据处理和传输过程中，都有可能会出现消息丢失，</p><p>&lt;插入图片&gt; @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</p><p>下面我们就结合 Kafka 来分析一下消息丢失的原因以及解决办法：</p><h3 id="消费者异常导致的消息丢失"><a href="#消费者异常导致的消息丢失" class="headerlink" title="消费者异常导致的消息丢失"></a>消费者异常导致的消息丢失</h3><p>消费者可能导致数据丢失的情况是：消费者获取到了这条消息后，还未处理，Kafka 就自动提交了 offset，这时 Kafka 就认为消费者已经处理完这条消息，其实消费者才刚准备处理这条消息，这时如果消费者宕机，那这条消息就丢失了。</p><p>消费者引起消息丢失的主要原因就是消息还未处理完 Kafka 会自动提交了 offset，那么只要关闭自动提交 offset，消费者在处理完之后手动提交 offset，就可以保证消息不会丢失。但是此时需要注意重复消费问题，比如消费者刚处理完，还没提交 offset，这时自己宕机了，此时这条消息肯定会被重复消费一次，这就需要消费者根据实际情况保证幂等性。</p><h3 id="Kafka-导致的消息丢失"><a href="#Kafka-导致的消息丢失" class="headerlink" title="Kafka 导致的消息丢失"></a>Kafka 导致的消息丢失</h3><p>Kafka 导致的数据丢失一个常见的场景就是 Kafka 某个 broker 宕机，，而这个节点正好是某个 partition 的 leader 节点，这时需要重新重新选举该 partition 的 leader。如果该 partition 的 leader 在宕机时刚好还有些数据没有同步到 follower，此时 leader 挂了，在选举某个 follower 成 leader 之后，就会丢失一部分数据。</p><p>对于这个问题，Kafka 可以设置如下 4 个参数，来尽量避免消息丢失：</p><ul><li>给 topic 设置 replication.factor 参数：这个值必须大于 1，要求每个 partition 必须有至少 2 个副本；</li><li>在 Kafka 服务端设置 min.insync.replicas 参数：这个值必须大于 1，这个参数的含义是一个 leader 至少感知到有至少一个 follower 还跟自己保持联系，没掉队，这样才能确保 leader 挂了还有一个 follower 节点。</li><li>在 producer 端设置 acks=all：这个是要求每条数据，必须是写入所有 replica 之后，才能认为是写成功了；</li><li>在 producer 端设置 retries=MAX（很大很大很大的一个值，无限次重试的意思）：这个参数的含义是一旦写入失败，就无限重试，卡在这里了。</li></ul><h3 id="生产者数据传输导致的消息丢失"><a href="#生产者数据传输导致的消息丢失" class="headerlink" title="生产者数据传输导致的消息丢失"></a>生产者数据传输导致的消息丢失</h3><p>对于生产者数据传输导致的数据丢失主常见情况是生产者发送消息给 Kafka，由于网络等原因导致消息丢失，对于这种情况也是通过在 <strong>producer</strong> 端设置 <strong>acks=all</strong> 来处理，这个参数是要求 leader 接收到消息后，需要等到所有的 follower 都同步到了消息之后，才认为本次写成功了。如果没满足这个条件，生产者会自动不断的重试。</p><p><a href="https://mp.weixin.qq.com/s/qttczGROYoqSulzi8FLXww" target="_blank" rel="noopener">面试官问我如何保证Kafka不丢失消息?我哭了！</a></p><h2 id="Kafka-如何保证消息的顺序性"><a href="#Kafka-如何保证消息的顺序性" class="headerlink" title="Kafka 如何保证消息的顺序性"></a>Kafka 如何保证消息的顺序性</h2><p>在某些业务场景下，我们需要保证对于有逻辑关联的多条MQ消息被按顺序处理，比如对于某一条数据，正常处理顺序是<code>新增-更新-删除</code>，最终结果是数据被删除；如果消息没有按序消费，处理顺序可能是<code>删除-新增-更新</code>，最终数据没有被删掉，可能会产生一些逻辑错误。对于如何保证消息的顺序性，主要需要考虑如下两点：</p><ul><li>如何保证消息在 MQ 中顺序性；</li><li>如何保证消费者处理消费的顺序性。</li></ul><h3 id="如何保证消息在-MQ-中顺序性"><a href="#如何保证消息在-MQ-中顺序性" class="headerlink" title="如何保证消息在 MQ 中顺序性"></a>如何保证消息在 MQ 中顺序性</h3><p>对于 Kafka，如果我们创建了一个 topic，默认有三个 partition。生产者在写数据的时候，可以指定一个 key，比如在订单 topic 中我们可以指定订单 id 作为 key，那么相同订单 id 的数据，一定会被分发到同一个 partition 中去，而且这个 partition 中的数据一定是有顺序的。消费者从 partition 中取出来数据的时候，也一定是有顺序的。通过制定 key 的方式首先可以保证在 kafka 内部消息是有序的。</p><h3 id="如何保证消费者处理消费的顺序性"><a href="#如何保证消费者处理消费的顺序性" class="headerlink" title="如何保证消费者处理消费的顺序性"></a>如何保证消费者处理消费的顺序性</h3><p>对于某个 topic 的一个 partition，只能被同组内部的一个 consumer 消费，如果这个 consumer 内部还是单线程处理，那么其实只要保证消息在 MQ 内部是有顺序的就可以保证消费也是有顺序的。但是单线程吞吐量太低，在处理大量 MQ 消息时，我们一般会开启多线程消费机制，那么如何保证消息在多个线程之间是被顺序处理的呢？对于多线程消费我们可以预先设置 N 个内存 Queue，具有相同 key 的数据都放到同一个内存 Queue 中；然后开启 N 个线程，每个线程分别消费一个内存 Queue 的数据即可，这样就能保证顺序性。当然，消息放到内存 Queue 中，有可能还未被处理，consumer 发生宕机，内存 Queue 中的数据会全部丢失，这就转变为上面提到的<strong>如何保证消息的可靠传输</strong>的问题了。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.cnblogs.com/qingyunzong/p/9004703.html" target="_blank" rel="noopener">Kafka学习之路 （三）Kafka的高可用</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景描述&quot;&gt;&lt;a href=&quot;#背景描述&quot; class=&quot;headerlink&quot; title=&quot;背景描述&quot;&gt;&lt;/a&gt;背景描述&lt;/h2&gt;&lt;p&gt;目前，很多的业务系统都会或多或少的使用各种 MQ 消息队列框架，例如：&lt;code&gt;RabbitMQ&lt;/code&gt;、&lt;code
      
    
    </summary>
    
    
      <category term="架构" scheme="https://dongzl.github.io/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="Kafka" scheme="https://dongzl.github.io/tags/Kafka/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 主从复制原理及配置</title>
    <link href="https://dongzl.github.io/2020/03/15/12-MySQL-Master-Slave-Replication/"/>
    <id>https://dongzl.github.io/2020/03/15/12-MySQL-Master-Slave-Replication/</id>
    <published>2020-03-15T03:04:01.000Z</published>
    <updated>2020-03-15T11:52:19.478Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MySQL-主从复制原理"><a href="#MySQL-主从复制原理" class="headerlink" title="MySQL 主从复制原理"></a>MySQL 主从复制原理</h2><h3 id="什么是-MySQL-的主从复制"><a href="#什么是-MySQL-的主从复制" class="headerlink" title="什么是 MySQL 的主从复制"></a>什么是 MySQL 的主从复制</h3><p>MySQL 主从复制是指数据可以从一个 MySQL 数据库服务器主节点复制到一个或多个从节点。MySQL 默认采用异步复制方式，这样从节点不用一直访问主服务器来更新自己的数据，数据的更新可以在远程连接上进行，从节点可以复制主数据库中的所有数据库或者特定的数据库，或者特定的表。</p><h3 id="为什么需要主从复制"><a href="#为什么需要主从复制" class="headerlink" title="为什么需要主从复制"></a>为什么需要主从复制</h3><ul><li>提高数据库读写性能，提升系统吞吐量</li></ul><p>在业务复杂的系统中，如果有一条 SQL 语句的执行需要锁表，导致 MySQL 暂时不能提供读的服务，那么就很影响运行中的业务，使用主从复制，让主库负责写，从库负责读，这样即使主库出现了锁表的情景，通过读从库也可以保证业务的正常运作。</p><ul><li><p>做数据库热备</p></li><li><p>架构扩展需要</p></li></ul><p>业务量越来越大，I/O 访问频率过高，单机无法满足，此时做多库的存储，降低磁盘I/O 访问的频率，提升整个数据库性能。</p><h3 id="MySQL-的复制原理"><a href="#MySQL-的复制原理" class="headerlink" title="MySQL 的复制原理"></a>MySQL 的复制原理</h3><p><strong>原理</strong>：</p><ul><li><p>master 服务器将数据的改变记录二进制 binlog 日志，当 master 上的数据发生改变时，则将其改变写入二进制日志中；</p></li><li><p>slave 服务器会在一定时间间隔内对 master 二进制日志进行探测其是否发生改变，如果发生改变，则开始一个 I/OThread 请求 master 二进制事件；</p></li><li><p>同时主节点为每个 I/O 线程启动一个 dump 线程，用于向其发送二进制事件，并保存至从节点本地的中继日志中，从节点将启动 SQL 线程从中继日志中读取二进制日志，在本地重放，使得其数据和主节点的保持一致，最后 I/OThread 和 SQLThread 将进入睡眠状态，等待下一次被唤醒。</p></li></ul><p><strong>也就是</strong>：</p><ul><li><p>从库会生成两个线程,一个 I/O 线程,一个 SQL 线程；</p></li><li><p>I/O 线程会去请求主库的 binlog，并将得到的 binlog 写到本地的 relay-log（中继日志）文件中；主库会生成一个 log dump 线程,用来给从库 I/O 线程传 binlog；</p></li><li><p>SQL 线程，会读取 relay log 文件中的日志，并解析成sql语句逐一执行。</p></li></ul><p><strong>注意</strong>：</p><ul><li><p>master 将操作语句记录到 binlog 日志中，然后授予 slave 远程连接的权限（master 一定要开启 binlog 二进制日志功能；通常为了数据安全考虑，slave 也开启binlog功能）；</p></li><li><p>slave 开启两个线程：IO 线程和 SQL 线程。其中：IO 线程负责读取 master 的 binlog 内容到中继日志 relay log 里；SQL 线程负责从 relay log 日志里读出 binlog 内容，并更新到 slave 的数据库里，这样就能保证 slave 数据和 master 数据保持一致了；</p></li><li><p>MySQL 复制至少需要两个 MySQL 的服务，当然 MySQL 服务可以分布在不同的服务器上，也可以在一台服务器上启动多个服务；</p></li><li><p>MySQL复制最好确保 master 和 slave 服务器上的 MySQL 版本相同（如果不能满足版本一致，那么要保证 master 主节点的版本低于 slave 从节点的版本）；</p></li><li><p>master 和 slave 两节点间时间需同步。</p></li></ul><img src="https://gitee.com/dongzl/article-images/raw/master/2020/12-MySQL-Master-Slave-Replication/MySQL-Master-Slave-Replication-01.jpeg"><p><strong>具体步骤</strong>：</p><ul><li><p>从库通过手工执行 change master to 语句连接主库，提供了连接的用户一切条件（user 、password、port、ip），并且让从库知道，二进制日志的起点位置（file名 position 号）start slave；</p></li><li><p>从库的 IO 线程和主库的 dump 线程建立连接；</p></li><li><p>从库根据 change master to 语句提供的 file 名和 position 号，IO 线程向主库发起 binlog 的请求；</p></li><li><p>主库 dump 线程根据从库的请求，将本地 binlog 以 events 的方式发给从库IO 线程；</p></li><li><p>从库 IO 线程接收 binlog events，并存放到本地 relay-log 中，传送过来的信息，会记录到 <code>master.info</code> 中；</p></li><li><p>从库 SQL 线程应用 relay-log，并且把应用过的记录到 <code>relay-log.info</code> 中，默认情况下，已经应用过的 relay 会自动被清理 purge。</p></li></ul><h3 id="MySQL-主从复制的形式"><a href="#MySQL-主从复制的形式" class="headerlink" title="MySQL 主从复制的形式"></a>MySQL 主从复制的形式</h3><ul><li><p>一主一从</p></li><li><p>主主复制</p></li><li><p>一主多从</p></li><li><p>多主一从</p></li><li><p>级联复制</p></li></ul><img src="https://gitee.com/dongzl/article-images/raw/master/2020/12-MySQL-Master-Slave-Replication/MySQL-Master-Slave-Replication-02.png"><h3 id="MySQL-主从复制延时分析"><a href="#MySQL-主从复制延时分析" class="headerlink" title="MySQL 主从复制延时分析"></a>MySQL 主从复制延时分析</h3><p>MySQL 的主从复制都是单线程的操作，主库对所有 DDL 和 DML 产生的日志写进 binlog，由于 binlog 是顺序写，所以效率很高，slave 的 SQL thread 线程将主库的 DDL 和 DML 操作事件在 slave 中重放。DML 和 DDL 的 IO 操作是随机的，不是顺序，所以成本要高很多，另一方面，由于 SQL thread 也是单线程的，当主库的并发较高时，产生的 DML 数量超过 slave 的 SQL thread 所能处理的速度，或者当 slave 中有大型 query 语句产生了锁等待，那么延时就产生了。</p><p><strong>解决方案</strong>：</p><ul><li>业务的持久层实现采用分库架构，mysql 服务可以水平扩展，分散压力；</li><li>单个库读写分离，一主多从，主写从读，分散压力；这样从库压力可能会比主库高，保护主库。</li><li>服务的基础架构在业务系统和mysql之间加入memcache或者redis 的cache层，降低mysql读压力。</li><li>不同业务的mysql物理上放在不同的机器，分散压力。</li><li>使用比主库更好的硬件设备作为slave，mysql压力小，延迟自然会变小。</li><li>使用更加强劲的硬件设备。</li></ul><h2 id="MySQL-主从复制安装配置"><a href="#MySQL-主从复制安装配置" class="headerlink" title="MySQL 主从复制安装配置"></a>MySQL 主从复制安装配置</h2><h3 id="基础设置准备"><a href="#基础设置准备" class="headerlink" title="基础设置准备"></a>基础设置准备</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">操作系统：</span></span><br><span class="line">centos6.5</span><br><span class="line"><span class="meta">#</span><span class="bash">mysql版本：</span></span><br><span class="line">5.7</span><br><span class="line"><span class="meta">#</span><span class="bash">两台虚拟机：</span></span><br><span class="line">node1:192.168.85.111（主）</span><br><span class="line">node2:192.168.85.112（从）</span><br></pre></td></tr></table></figure><h3 id="安装-MySQL-数据库"><a href="#安装-MySQL-数据库" class="headerlink" title="安装 MySQL 数据库"></a>安装 MySQL 数据库</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">## 在两台数据库中分别创建数据库</span></span></span><br><span class="line"></span><br><span class="line">```sql</span><br><span class="line">--注意两台必须全部执行</span><br><span class="line">create database test;</span><br></pre></td></tr></table></figure><h3 id="在主（node1）服务器进行如下配置："><a href="#在主（node1）服务器进行如下配置：" class="headerlink" title="在主（node1）服务器进行如下配置："></a>在主（node1）服务器进行如下配置：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">修改配置文件，执行以下命令打开mysql配置文件</span></span><br><span class="line">vi /etc/my.cnf</span><br><span class="line"><span class="meta">#</span><span class="bash">在mysqld模块中添加如下配置信息</span></span><br><span class="line">log-bin=master-bin #二进制文件名称</span><br><span class="line">binlog-format=ROW  #二进制日志格式，有row、statement、mixed三种格式，row指的是把改变的内容复制过去，而不是把命令在从服务器上执行一遍，statement指的是在主服务器上执行的SQL语句，在从服务器上执行同样的语句。MySQL默认采用基于语句的复制，效率比较高。mixed指的是默认采用基于语句的复制，一旦发现基于语句的无法精确的复制时，就会采用基于行的复制。</span><br><span class="line">server-id=1   #要求各个服务器的id必须不一样</span><br><span class="line">binlog-do-db=test   #同步的数据库名称</span><br></pre></td></tr></table></figure><h3 id="配置从服务器登录主服务器的账号授权"><a href="#配置从服务器登录主服务器的账号授权" class="headerlink" title="配置从服务器登录主服务器的账号授权"></a>配置从服务器登录主服务器的账号授权</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--授权操作</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> validate_password_policy=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> validate_password_length=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">replication</span> <span class="keyword">slave</span> <span class="keyword">on</span> *.* <span class="keyword">to</span> <span class="string">'root'</span>@<span class="string">'%'</span> <span class="keyword">identified</span> <span class="keyword">by</span> <span class="string">'123456'</span>;</span><br><span class="line"><span class="comment">--刷新权限</span></span><br><span class="line"><span class="keyword">flush</span> <span class="keyword">privileges</span>;</span><br></pre></td></tr></table></figure><h3 id="从服务器的配置"><a href="#从服务器的配置" class="headerlink" title="从服务器的配置"></a>从服务器的配置</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">修改配置文件，执行以下命令打开mysql配置文件</span></span><br><span class="line">vi /etc/my.cnf</span><br><span class="line"><span class="meta">#</span><span class="bash">在mysqld模块中添加如下配置信息</span></span><br><span class="line">log-bin=master-bin#二进制文件的名称</span><br><span class="line">binlog-format=ROW#二进制文件的格式</span><br><span class="line">server-id=2#服务器的id</span><br></pre></td></tr></table></figure><h3 id="重启主服务器的mysqld服务"><a href="#重启主服务器的mysqld服务" class="headerlink" title="重启主服务器的mysqld服务"></a>重启主服务器的mysqld服务</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">重启mysql服务</span></span><br><span class="line">service mysqld restart</span><br><span class="line"><span class="meta">#</span><span class="bash">登录mysql数据库</span></span><br><span class="line">mysql -uroot -p</span><br><span class="line"><span class="meta">#</span><span class="bash">查看master的状态</span></span><br><span class="line">show master status；</span><br></pre></td></tr></table></figure><h3 id="重启从服务器并进行相关配置"><a href="#重启从服务器并进行相关配置" class="headerlink" title="重启从服务器并进行相关配置"></a>重启从服务器并进行相关配置</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">重启mysql服务</span></span><br><span class="line">service mysqld restart</span><br><span class="line"><span class="meta">#</span><span class="bash">登录mysql</span></span><br><span class="line">mysql -uroot -p</span><br><span class="line"><span class="meta">#</span><span class="bash">连接主服务器</span></span><br><span class="line">change master to master_host='192.168.85.11',master_user='root',master_password='123456',master_port=3306,master_log_file='master-bin.000001',master_log_pos=154;</span><br><span class="line"><span class="meta">#</span><span class="bash">启动slave</span></span><br><span class="line">start slave</span><br><span class="line"><span class="meta">#</span><span class="bash">查看slave的状态</span></span><br><span class="line">show slave status\G(注意没有分号)</span><br></pre></td></tr></table></figure><blockquote><p>内容来源：<a href="http://www.mashibing.com/" target="_blank" rel="noopener">马士兵教育</a> 公开课内容知识整理</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;MySQL-主从复制原理&quot;&gt;&lt;a href=&quot;#MySQL-主从复制原理&quot; class=&quot;headerlink&quot; title=&quot;MySQL 主从复制原理&quot;&gt;&lt;/a&gt;MySQL 主从复制原理&lt;/h2&gt;&lt;h3 id=&quot;什么是-MySQL-的主从复制&quot;&gt;&lt;a href=
      
    
    </summary>
    
    
      <category term="数据库" scheme="https://dongzl.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="主从复制" scheme="https://dongzl.github.io/tags/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
    
      <category term="MySQL" scheme="https://dongzl.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 数据库优化知识总结</title>
    <link href="https://dongzl.github.io/2020/03/14/11-MySQL-Optimization-Knowledge-Summary/"/>
    <id>https://dongzl.github.io/2020/03/14/11-MySQL-Optimization-Knowledge-Summary/</id>
    <published>2020-03-14T14:06:18.000Z</published>
    <updated>2020-03-15T02:56:38.528Z</updated>
    
    <content type="html"><![CDATA[<h2 id="性能监控"><a href="#性能监控" class="headerlink" title="性能监控"></a>性能监控</h2><h3 id="show-profile-查询剖析工具"><a href="#show-profile-查询剖析工具" class="headerlink" title="show profile 查询剖析工具"></a>show profile 查询剖析工具</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">## https://dev.mysql.com/doc/refman/5.7/en/show-profile.html</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">profiles</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">## 开启 show profile 监控</span></span><br><span class="line"><span class="keyword">set</span> profiling=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">## 根据 Type 查询</span></span><br><span class="line"><span class="keyword">show</span> profile cpu <span class="keyword">for</span> <span class="keyword">query</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">show</span> profile <span class="keyword">all</span> <span class="keyword">for</span> <span class="keyword">query</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">## 未来有可能被移除，推荐使用 Performance Schema</span></span><br><span class="line">Note: </span><br><span class="line">The <span class="keyword">SHOW</span> PROFILE <span class="keyword">and</span> <span class="keyword">SHOW</span> <span class="keyword">PROFILES</span> statements <span class="keyword">are</span> deprecated <span class="keyword">and</span> will be removed <span class="keyword">in</span> a future MySQL release. </span><br><span class="line"><span class="keyword">Use</span> the <span class="keyword">Performance</span> <span class="keyword">Schema</span> instead; see Section 25.19.1, “Query Profiling Using Performance Schema”.</span><br><span class="line"></span><br><span class="line"><span class="comment">## 查看MySQL支持存储引擎类型</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">engines</span>;</span><br></pre></td></tr></table></figure><h3 id="Performance-Schema-库"><a href="#Performance-Schema-库" class="headerlink" title="Performance Schema 库"></a>Performance Schema 库</h3><p>5.7 新提供自带监控数据库，有 87 张数据表。</p><p><a href="https://dev.mysql.com/doc/refman/5.7/en/performance-schema.html" target="_blank" rel="noopener">MySQL Performance Schema</a></p><h3 id="使用-show-processlist-查看连接"><a href="#使用-show-processlist-查看连接" class="headerlink" title="使用 show processlist 查看连接"></a>使用 show processlist 查看连接</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">processlist</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'%max_connection%'</span>;</span><br></pre></td></tr></table></figure><h2 id="schema-与数据类型优化"><a href="#schema-与数据类型优化" class="headerlink" title="schema 与数据类型优化"></a>schema 与数据类型优化</h2><h3 id="数据类型优化"><a href="#数据类型优化" class="headerlink" title="数据类型优化"></a>数据类型优化</h3><ul><li>更小的通常更好</li><li>简单就好<ul><li>整型比字符类型代价更低</li><li>使用MySQL自带类型而不是字符串类型还存储日期和时间</li><li>用整型存储IP地址</li></ul></li></ul><ul><li>尽量避免 null</li><li>实际细则</li></ul><h3 id="索引优化细节"><a href="#索引优化细节" class="headerlink" title="索引优化细节"></a>索引优化细节</h3><ul><li><p>当使用索引列进行查询的时候尽量不要使用表达式，把计算放到业务层而不是数据层（表达式会导致索引失效）；</p></li><li><p>尽量使用主键查询，而不是其它索引，因为主键查询不会触发回表查询，减少 IO 次数；</p></li><li><p>使用前缀索引，前缀索引可以减少空间占用；</p></li><li><p>使用索引扫描来排序；</p></li><li><p>union all，in，or 都能够使用索引，但是推荐使用 in；</p></li><li><p>范围列可以用到索引；</p></li><li><p>强制类型转换会导致全表扫描，即索引失效；</p></li><li><p>更新十分频繁，数据区分度不高的字段上不宜建立索引；</p></li><li><p>创建索引的列，不允许为 null，可能会得到不符合预期的结果（null != null）；</p></li><li><p>当需要进行表连接的时候，最好不要超过三张表，因为需要 join 的字段，数据类型必须一致；</p></li><li><p>能使用 limit 的时候尽量使用 limit，减少后续查询操作（limit 1）；</p></li><li><p>单表索引建议控制在 5 个以内；</p></li><li><p>单索引字段数不允许超过 5 个（组合索引字段个数）；</p></li><li><p>创建索引的时候需要避免的错误概念：1、索引越多越好；2、过早优化，在不了解系统的情况下进行优化。</p></li></ul><h2 id="MySQL-执行计划"><a href="#MySQL-执行计划" class="headerlink" title="MySQL 执行计划"></a>MySQL 执行计划</h2><p>​在企业的应用场景中，为了知道优化SQL语句的执行，需要查看SQL语句的具体执行过程，以加快SQL语句的执行效率。</p><p>可以使用 explain + SQL 语句来模拟优化器执行 SQL 查询语句，从而知道 MySQL 是如何处理 SQL 语句的。</p><p>​<a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html" target="_blank" rel="noopener">EXPLAIN Output Format</a></p><h3 id="执行计划中包含的信息"><a href="#执行计划中包含的信息" class="headerlink" title="执行计划中包含的信息"></a>执行计划中包含的信息</h3><table><thead><tr><th align="center">Column</th><th align="center">Meaning</th></tr></thead><tbody><tr><td align="center">id</td><td align="center">The <code>SELECT</code> identifier</td></tr><tr><td align="center">select_type</td><td align="center">The <code>SELECT</code> type</td></tr><tr><td align="center">table</td><td align="center">The table for the output row</td></tr><tr><td align="center">partitions</td><td align="center">The matching partitions</td></tr><tr><td align="center">type</td><td align="center">The join type</td></tr><tr><td align="center">possible_keys</td><td align="center">The possible indexes to choose</td></tr><tr><td align="center">key</td><td align="center">The index actually chosen</td></tr><tr><td align="center">key_len</td><td align="center">The length of the chosen key</td></tr><tr><td align="center">ref</td><td align="center">The columns compared to the index</td></tr><tr><td align="center">rows</td><td align="center">Estimate of rows to be examined</td></tr><tr><td align="center">filtered</td><td align="center">Percentage of rows filtered by table condition</td></tr><tr><td align="center">extra</td><td align="center">Additional information</td></tr></tbody></table><p><strong>id</strong></p><p>select 查询的序列号，包含一组数字，表示查询中执行 select 子句或者操作表的顺序</p><p>id 号分为三种情况：</p><p>​1、如果 id 相同，那么执行顺序从上到下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp e <span class="keyword">join</span> dept d <span class="keyword">on</span> e.deptno = d.deptno <span class="keyword">join</span> salgrade sg <span class="keyword">on</span> e.sal <span class="keyword">between</span> sg.losal <span class="keyword">and</span> sg.hisal;</span><br></pre></td></tr></table></figure><p>​2、如果 id 不同，如果是子查询，id 的序号会递增，id 值越大优先级越高，越先被执行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp e <span class="keyword">where</span> e.deptno <span class="keyword">in</span> (<span class="keyword">select</span> d.deptno <span class="keyword">from</span> dept d <span class="keyword">where</span> d.dname = <span class="string">'SALES'</span>);</span><br></pre></td></tr></table></figure><p>3、id 相同和不同的，同时存在：相同的可以认为是一组，从上往下顺序执行，在所有组中，id 值越大，优先级越高，越先执行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp e <span class="keyword">join</span> dept d <span class="keyword">on</span> e.deptno = d.deptno <span class="keyword">join</span> salgrade sg <span class="keyword">on</span> e.sal <span class="keyword">between</span> sg.losal <span class="keyword">and</span> sg.hisal <span class="keyword">where</span> e.deptno <span class="keyword">in</span> (<span class="keyword">select</span> d.deptno <span class="keyword">from</span> dept d <span class="keyword">where</span> d.dname = <span class="string">'SALES'</span>);</span><br></pre></td></tr></table></figure><p><strong>select_type</strong></p><p>主要用来分辨查询的类型，是普通查询还是联合查询还是子查询</p><table><thead><tr><th align="center"><code>select_type</code> Value</th><th align="center">Meaning</th></tr></thead><tbody><tr><td align="center">SIMPLE</td><td align="center">Simple SELECT (not using UNION or subqueries)</td></tr><tr><td align="center">PRIMARY</td><td align="center">Outermost SELECT</td></tr><tr><td align="center">UNION</td><td align="center">Second or later SELECT statement in a UNION</td></tr><tr><td align="center">DEPENDENT UNION</td><td align="center">Second or later SELECT statement in a UNION, dependent on outer query</td></tr><tr><td align="center">UNION RESULT</td><td align="center">Result of a UNION.</td></tr><tr><td align="center">SUBQUERY</td><td align="center">First SELECT in subquery</td></tr><tr><td align="center">DEPENDENT SUBQUERY</td><td align="center">First SELECT in subquery, dependent on outer query</td></tr><tr><td align="center">DERIVED</td><td align="center">Derived table</td></tr><tr><td align="center">UNCACHEABLE SUBQUERY</td><td align="center">A subquery for which the result cannot be cached and must be re-evaluated for each row of the outer query</td></tr><tr><td align="center">UNCACHEABLE UNION</td><td align="center">The second or later select in a UNION that belongs to an uncacheable subquery (see UNCACHEABLE SUBQUERY)</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--sample:简单的查询，不包含子查询和union</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp;</span><br><span class="line"></span><br><span class="line"><span class="comment">--primary:查询中若包含任何复杂的子查询，最外层查询则被标记为Primary</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> staname,ename supname <span class="keyword">from</span> (<span class="keyword">select</span> ename staname,mgr <span class="keyword">from</span> emp) t <span class="keyword">join</span> emp <span class="keyword">on</span> t.mgr=emp.empno ;</span><br><span class="line"></span><br><span class="line"><span class="comment">--union:若第二个select出现在union之后，则被标记为union</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> deptno = <span class="number">10</span> <span class="keyword">union</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> sal &gt;<span class="number">2000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--dependent union:跟union类似，此处的depentent表示union或union all联合而成的结果会受外部表影响</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp e <span class="keyword">where</span> e.empno  <span class="keyword">in</span> ( <span class="keyword">select</span> empno <span class="keyword">from</span> emp <span class="keyword">where</span> deptno = <span class="number">10</span> <span class="keyword">union</span> <span class="keyword">select</span> empno <span class="keyword">from</span> emp <span class="keyword">where</span> sal &gt;<span class="number">2000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">--union result:从union表获取结果的select</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> deptno = <span class="number">10</span> <span class="keyword">union</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> sal &gt;<span class="number">2000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--subquery:在select或者where列表中包含子查询</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> sal &gt; (<span class="keyword">select</span> <span class="keyword">avg</span>(sal) <span class="keyword">from</span> emp) ;</span><br><span class="line"></span><br><span class="line"><span class="comment">--dependent subquery:subquery的子查询要受到外部表查询的影响</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp e <span class="keyword">where</span> e.deptno <span class="keyword">in</span> (<span class="keyword">select</span> <span class="keyword">distinct</span> deptno <span class="keyword">from</span> dept);</span><br><span class="line"></span><br><span class="line"><span class="comment">--DERIVED: from子句中出现的子查询，也叫做派生类，</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> staname,ename supname <span class="keyword">from</span> (<span class="keyword">select</span> ename staname,mgr <span class="keyword">from</span> emp) t <span class="keyword">join</span> emp <span class="keyword">on</span> t.mgr=emp.empno ;</span><br><span class="line"></span><br><span class="line"><span class="comment">--UNCACHEABLE SUBQUERY：表示使用子查询的结果不能被缓存</span></span><br><span class="line"> <span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> empno = (<span class="keyword">select</span> empno <span class="keyword">from</span> emp <span class="keyword">where</span> deptno=@@sort_buffer_size);</span><br><span class="line"> </span><br><span class="line"><span class="comment">--uncacheable union:表示union的查询结果不能被缓存：sql语句未验证</span></span><br></pre></td></tr></table></figure><p><strong>table</strong></p><p>对应行正在访问哪一个表，表名或者别名，可能是临时表或者 union 合并结果集</p><p>1、如果是具体的表名，则表明从实际的物理表中获取数据，当然也可以是表的别名</p><p>2、表名是 derivedN 的形式，表示使用了 id 为 N 的查询产生的衍生表</p><p>3、当有 union result 的时候，表名是 union n1,n2 等的形式，n1,n2 表示参与 union 的 id</p><p><strong>type</strong></p><p>type 显示的是访问类型，访问类型表示我是以何种方式去访问我们的数据，最容易想的是全表扫描，直接暴力的遍历一张表去寻找需要的数据，效率非常低下，访问的类型有很多，效率从最好到最坏依次是：</p><p>system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL </p><p>一般情况下，得保证查询至少达到 range 级别，最好能达到 ref</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--all:全表扫描，一般情况下出现这样的sql语句而且数据量比较大的话那么就需要进行优化。</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp;</span><br><span class="line"></span><br><span class="line"><span class="comment">--index：全索引扫描这个比all的效率要好，主要有两种情况，一种是当前的查询时覆盖索引，即我们需要的数据在索引中就可以索取，或者是使用了索引进行排序，这样就避免数据的重排序</span></span><br><span class="line"><span class="keyword">explain</span>  <span class="keyword">select</span> empno <span class="keyword">from</span> emp;</span><br><span class="line"></span><br><span class="line"><span class="comment">--range：表示利用索引查询的时候限制了范围，在指定范围内进行查询，这样避免了index的全索引扫描，适用的操作符： =, &lt;&gt;, &gt;, &gt;=, &lt;, &lt;=, IS NULL, BETWEEN, LIKE, or IN() </span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> empno <span class="keyword">between</span> <span class="number">7000</span> <span class="keyword">and</span> <span class="number">7500</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--index_subquery：利用索引来关联子查询，不再扫描全表</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> emp.job <span class="keyword">in</span> (<span class="keyword">select</span> job <span class="keyword">from</span> t_job);</span><br><span class="line"></span><br><span class="line"><span class="comment">--unique_subquery:该连接类型类似与index_subquery,使用的是唯一索引</span></span><br><span class="line"> <span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp e <span class="keyword">where</span> e.deptno <span class="keyword">in</span> (<span class="keyword">select</span> <span class="keyword">distinct</span> deptno <span class="keyword">from</span> dept);</span><br><span class="line"> </span><br><span class="line"><span class="comment">--index_merge：在查询过程中需要多个索引组合使用，没有模拟出来</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--ref_or_null：对于某个字段即需要关联条件，也需要null值的情况下，查询优化器会选择这种访问方式</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp e <span class="keyword">where</span>  e.mgr <span class="keyword">is</span> <span class="literal">null</span> <span class="keyword">or</span> e.mgr=<span class="number">7369</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--ref：使用了非唯一性索引进行数据的查找</span></span><br><span class="line"> <span class="keyword">create</span> <span class="keyword">index</span> idx_3 <span class="keyword">on</span> emp(deptno);</span><br><span class="line"> <span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp e,dept d <span class="keyword">where</span> e.deptno =d.deptno;</span><br><span class="line"></span><br><span class="line"><span class="comment">--eq_ref ：使用唯一性索引进行数据查找</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp,emp2 <span class="keyword">where</span> emp.empno = emp2.empno;</span><br><span class="line"></span><br><span class="line"><span class="comment">--const：这个表至多有一个匹配行，</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> empno = <span class="number">7369</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">--system：表只有一行记录（等于系统表），这是const类型的特例，平时不会出现</span></span><br></pre></td></tr></table></figure><p> <strong>possible_keys</strong> </p><p>显示可能应用在这张表中的索引，一个或多个，查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询实际使用</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp,dept <span class="keyword">where</span> emp.deptno = dept.deptno <span class="keyword">and</span> emp.deptno = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p><strong>key</strong></p><p>实际使用的索引，如果为 null，则没有使用索引，查询中若使用了覆盖索引，则该索引和查询的 select 字段重叠。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp,dept <span class="keyword">where</span> emp.deptno = dept.deptno <span class="keyword">and</span> emp.deptno = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p><strong>key_len</strong></p><p>表示索引中使用的字节数，可以通过 key_len 计算查询中使用的索引长度，在不损失精度的情况下长度越短越好。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp,dept <span class="keyword">where</span> emp.deptno = dept.deptno <span class="keyword">and</span> emp.deptno = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p><strong>ref</strong></p><p>显示索引的哪一列被使用了，如果可能的话，是一个常数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp,dept <span class="keyword">where</span> emp.deptno = dept.deptno <span class="keyword">and</span> emp.deptno = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p><strong>rows</strong></p><p>根据表的统计信息及索引使用情况，大致估算出找出所需记录需要读取的行数，此参数很重要，直接反应的 SQL 找了多少数据，在完成目的的情况下越少越好</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp;</span><br></pre></td></tr></table></figure><p><strong>extra</strong></p><p>包含额外的信息。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--using filesort:说明mysql无法利用索引进行排序，只能利用排序算法进行排序，会消耗额外的位置</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">order</span> <span class="keyword">by</span> sal;</span><br><span class="line"></span><br><span class="line"><span class="comment">--using temporary:建立临时表来保存中间结果，查询完成之后把临时表删除</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> ename,<span class="keyword">count</span>(*) <span class="keyword">from</span> emp <span class="keyword">where</span> deptno = <span class="number">10</span> <span class="keyword">group</span> <span class="keyword">by</span> ename;</span><br><span class="line"></span><br><span class="line"><span class="comment">--using index:这个表示当前的查询时覆盖索引的，直接从索引中读取数据，而不用访问数据表。如果同时出现using where 表名索引被用来执行索引键值的查找，如果没有，表面索引被用来读取数据，而不是真的查找</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> deptno,<span class="keyword">count</span>(*) <span class="keyword">from</span> emp <span class="keyword">group</span> <span class="keyword">by</span> deptno <span class="keyword">limit</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--using where:使用where进行条件过滤</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> t_user <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--using join buffer:使用连接缓存，情况没有模拟出来</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--impossible where：where语句的结果总是false</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> empno = <span class="number">7469</span>;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://zhenganwen.top/posts/433a3305/" target="_blank" rel="noopener">MySQL优化面试</a></li><li><a href="http://tigcms.jd.com/details/HkO5QrfPQ.html" target="_blank" rel="noopener">MySQL explain详解</a></li><li><a href="http://tigcms.jd.com/details/ryG-r2dM7.html" target="_blank" rel="noopener">MySQL数据库开发规范</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;性能监控&quot;&gt;&lt;a href=&quot;#性能监控&quot; class=&quot;headerlink&quot; title=&quot;性能监控&quot;&gt;&lt;/a&gt;性能监控&lt;/h2&gt;&lt;h3 id=&quot;show-profile-查询剖析工具&quot;&gt;&lt;a href=&quot;#show-profile-查询剖析工具&quot; class
      
    
    </summary>
    
    
      <category term="数据库" scheme="https://dongzl.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MySQL" scheme="https://dongzl.github.io/tags/MySQL/"/>
    
      <category term="优化" scheme="https://dongzl.github.io/tags/%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 数据库索引的实现原理</title>
    <link href="https://dongzl.github.io/2020/03/14/10-The-Implementation-Principles-Of-MySQL-Index/"/>
    <id>https://dongzl.github.io/2020/03/14/10-The-Implementation-Principles-Of-MySQL-Index/</id>
    <published>2020-03-14T05:52:04.000Z</published>
    <updated>2020-03-16T03:00:59.576Z</updated>
    
    <content type="html"><![CDATA[<h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><blockquote><p>1、MySQL 数据库索引分类。<br>2、MySQL 数据库 InnoDB 存储引擎的底层数据结构。<br>3、为什么底层使用 B+ 树而不用 B 树</p></blockquote><h2 id="MySQL-架构"><a href="#MySQL-架构" class="headerlink" title="MySQL 架构"></a>MySQL 架构</h2><img src="https://gitee.com/dongzl/article-images/raw/master/2020/10-The-Implementation-Principles-Of-MySQL-Index/The-Implementation-Principles-Of-MySQL-Index-03.png"><h2 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h2><p>MySQL 索引分五种类型：主键索引、唯一索引、普通索引和全文索引、组合索引。通过给字段添加索引可以提高数据的读取速度，提高项目的并发能力和抗压能力。</p><ul><li><p>主键索引：主键是一种唯一性索引，但它必须指定为 PRIMARY KEY，每个表只能有一个主键；</p></li><li><p>唯一索引：索引列的所有值都只能出现一次，即必须唯一，但是值可以为空；</p></li><li><p>普通索引：基本的索引类型，值可以为空，没有唯一性的限制；</p></li><li><p>全文索引：全文索引的索引类型为 FULLTEXT，全文索引可以在 varchar、char、text 类型的列上创建；（使用较少，一般都使用专门的搜索框架，例如 ElasticSearch）</p></li><li><p>组合索引：多列值组成一个索引，专门用于组合搜索。</p></li></ul><h2 id="MySQL-索引实现原理分析"><a href="#MySQL-索引实现原理分析" class="headerlink" title="MySQL 索引实现原理分析"></a>MySQL 索引实现原理分析</h2><p><strong>为什么没有使用 Hash 表的索引格式</strong></p><p>使用类似于 JDK 中 HashMap 的数据结构来存储索引数据，有如下特点：</p><ul><li><p>优点：查询速度快，Hash 数据结构查询时间复杂度为 O(1);</p></li><li><p>缺点：</p><ul><li>1、需要将数据文件 load 到内存，比较耗费内存空间；</li><li>2、Hash 快速查询只适合等值查询，对于范围查询效率低下，在实际工作中范围查询的场景比较多。</li></ul></li></ul><p><strong>为什么没有使用二叉树和红黑树索引格式</strong></p><p>无论是二叉树还是红黑树，都会因为树的深度过深而造成 IO 次数变多，影响数据读取效率。</p><p><strong>为什么没有使用 B 树索引格式</strong></p><p>B 树特点：</p><p>1、所有键值分布在整棵树中；<br>2、搜索有可能在非叶子节点结束，在关键字全集内做一次查找，性能逼近二分查找；<br>3、每个节点最多拥有 m 个子树；<br>4、根节点至少有 2 个子树；<br>5、分支节点至少拥有 m / 2 棵子树（除根节点和叶子节点外都是分支节点）；<br>6、所有叶子节点都在同一层、每个节点最多可以有 m - 1 个 key，并且以升序排列。</p><p>B 树缺点：</p><ul><li><p>每个节点都有 key，同时也包含 data，而每个页存储空间是有限的，如果 data 比较大的话会导致每个节点存储的 key 数量变小；</p></li><li><p>当存储的数据量很大的时候会导致深度较大，增大查询时磁盘 IO 次数，进而影响查询性能。</p></li></ul><img src="https://gitee.com/dongzl/article-images/raw/master/2020/10-The-Implementation-Principles-Of-MySQL-Index/The-Implementation-Principles-Of-MySQL-Index-01.png"><p><strong>MySQL B+ 树索引格式实现原理</strong></p><p>B+ 树是在 B 树的基础上做的一种优化，优化如下：</p><ul><li><p>B+ 树每个节点可以包含更多的节点（非叶子节点不在存储数据），这样做的原因有两个，第一是为了降低树的高度，第二个原因是将数据范围变为多个区间，区间越多，数据检索越快；</p></li><li><p>非叶子节点存储 key ，叶子节点存储 key 和数据；</p></li><li><p>叶子节点两两指针互相连接（符合磁盘的预读特性），顺序查询性能更高。</p></li></ul><p><strong>MySQL InnoDB–B+ 树，叶子节点直接存储数据</strong></p><ul><li><p>InnoDB 是通过 B+ 树结构对主键创建索引，在叶子节点中存储记录数据，如果没有主键，就选择唯一键，如果没有唯一键，那么会生成一个 6 位的 row_id 来作为主键；</p></li><li><p>如果创建索引的键是其他字段，那么在叶子节点中存储的是该记录的主键，然后在通过主键索引找到对应的记录，这个过程叫做回表。</p></li></ul><p><strong>MySQL MyISAM–B+ 树，叶子节点存储表中数据的地址</strong></p><img src="https://gitee.com/dongzl/article-images/raw/master/2020/10-The-Implementation-Principles-Of-MySQL-Index/The-Implementation-Principles-Of-MySQL-Index-02.png"><h2 id="MySQL-索引的一些其他内容"><a href="#MySQL-索引的一些其他内容" class="headerlink" title="MySQL 索引的一些其他内容"></a>MySQL 索引的一些其他内容</h2><h3 id="回表"><a href="#回表" class="headerlink" title="回表"></a>回表</h3><p>如果 MySQL 中的索引不是主键索引，在使用这个索引进行数据查询时，需要现在这个索引的 B+ 树中找到叶子节点存储的主键 ID，然后根据主键 ID 到主键索引的 B+ 树中查找到最终记录，这个过程就叫做回表。</p><h3 id="最左匹配原则"><a href="#最左匹配原则" class="headerlink" title="最左匹配原则"></a>最左匹配原则</h3><p>在创建联合索引时，如果在查询条件中包含索引的最左列，那么这个索引可以匹配到，如果不包含最左列，这个索引无法匹配，这个称做最左原则。</p><p>比如某个表有联合索引，索引字段为 (column1, column2)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a、<span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> column1 = <span class="string">'c1'</span> <span class="keyword">and</span> column2 = <span class="string">'c2'</span>;</span><br><span class="line"></span><br><span class="line">b、<span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> column2 = <span class="string">'c2'</span> <span class="keyword">and</span> column1 = <span class="string">'c1'</span>;</span><br><span class="line"></span><br><span class="line">c、<span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> column1 = <span class="string">'c1'</span>;</span><br><span class="line"></span><br><span class="line">d、<span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> column2 = <span class="string">'c2'</span>;</span><br></pre></td></tr></table></figure><p>上述 a、b、c 三个查询可以使用该索引，查询 d 无法使用该索引。</p><p>知识补充，如果上述四条SQL语句都希望走索引，需要创建两个索引：</p><p>组合索引: (column1, column2), 和 column2 单列索引；</p><p>或者是组合索引: (column2, column1), 和 column1 单列索引；</p><p>具体选择哪种方案，需要对比 column1、column2 字段类型，在满足查询优化情况尽量减少磁盘空间占用。</p><p>PS.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 范围查询只能用到 column2 列上索引，column2 上用不到</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> column1 &gt; <span class="string">'c1'</span> <span class="keyword">and</span> column2 = <span class="string">'c2'</span>;</span><br></pre></td></tr></table></figure><h3 id="索引覆盖"><a href="#索引覆盖" class="headerlink" title="索引覆盖"></a>索引覆盖</h3><p>如果索引中包含查询结果需要的全部字段，那么将不需要在回表查询该记录的所有数据，这个过程就是索引覆盖，覆盖索引在查询计划中表现为：<code>using index</code>。</p><h3 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h3><p>例如有 user_table 表，表上有 (user_name, age) 联合索引<br>如果现在有一个需求，查出名称中以“张”开头且年龄小于等于 10 的用户信息：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> user_table <span class="keyword">where</span> user_name <span class="keyword">like</span> <span class="string">'张%'</span> <span class="keyword">and</span> age &gt; <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>这条查询语句有两种执行可能：</p><ul><li><p>根据 (user_name, age) 联合索引查询所有满足名称以“张”开头的索引，然后回表查询出相应的全行数据，然后再筛选出满足年龄小于等于10的用户数据。</p></li><li><p>根据 (user_name, age) 联合索引查询所有满足名称以“张”开头的索引，然后直接再筛选出年龄小于等于10的索引，之后再回表查询全行数据。</p></li></ul><p>很明显，后一种方式需要回表查询的全行数据比较少，这就是 MySQL 的索引下推。</p><h3 id="聚簇索引与非聚簇索引"><a href="#聚簇索引与非聚簇索引" class="headerlink" title="聚簇索引与非聚簇索引"></a>聚簇索引与非聚簇索引</h3><p>聚簇索引并不是一种索引类型，而是一种数据存储方式，指的是数据行跟相邻的键值紧凑的存储在一起。费聚簇索引是指数据文件和索引文件分开存放。</p><p>MySQL 数据库中 InnoDB 存储引擎，B+ 树索引可以分为聚簇索引（也称聚集索引，clustered index）和辅助索引（有时也称非聚簇索引或二级索引，secondary index，non-clustered index）。这两种索引内部都是B+树，聚集索引的叶子节点存放着一整行的数据。</p><p>InnoDB 中的主键索引是一种聚簇索引，非聚簇索引都是辅助索引，像复合索引、前缀索引、唯一索引。</p><p>InnoDB 使用的是聚簇索引，MyISAM 使用的是非聚簇索引。</p><p><strong>聚簇索引的优缺点</strong>：</p><p>优点：</p><ul><li><p>数据访问更快，因为聚簇索引将索引和数据保存在同一个B+树中，因此从聚簇索引中获取数据比非聚簇索引更快；</p></li><li><p>聚簇索引对于主键的排序查找和范围查找速度非常快。</p></li></ul><p>缺点：</p><ul><li><p>插入速度严重依赖于插入顺序，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个自增的ID列为主键</p></li><li><p>更新主键的代价很高，因为将会导致被更新的行移动。因此，对于 InnoDB 表，我们一般定义主键为不可更新。</p></li><li><p>二级索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据。</p></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.jianshu.com/p/bdc9e57ccf8b" target="_blank" rel="noopener">MySQL 索引篇之覆盖索引、联合索引、索引下推</a></li><li><a href="https://blog.csdn.net/mccand1234/article/details/95799942" target="_blank" rel="noopener">索引下推（5.6版本+）</a></li><li><a href="https://zhenganwen.top/posts/433a3305/" target="_blank" rel="noopener">MySQL优化面试</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;面试题&quot;&gt;&lt;a href=&quot;#面试题&quot; class=&quot;headerlink&quot; title=&quot;面试题&quot;&gt;&lt;/a&gt;面试题&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;1、MySQL 数据库索引分类。&lt;br&gt;2、MySQL 数据库 InnoDB 存储引擎的底层数据结构。&lt;b
      
    
    </summary>
    
    
      <category term="数据库" scheme="https://dongzl.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MySQL" scheme="https://dongzl.github.io/tags/MySQL/"/>
    
      <category term="索引" scheme="https://dongzl.github.io/tags/%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 数据库事务 ACID 的实现原理</title>
    <link href="https://dongzl.github.io/2020/03/13/09-The-Implementation-Principles-Of-MySQL-ACID/"/>
    <id>https://dongzl.github.io/2020/03/13/09-The-Implementation-Principles-Of-MySQL-ACID/</id>
    <published>2020-03-13T13:39:26.000Z</published>
    <updated>2020-03-14T11:44:27.951Z</updated>
    
    <content type="html"><![CDATA[<h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><blockquote><p>MySQL 数据库的原子性和持久性怎么保证？</p></blockquote><blockquote><p>技术关键点：通过 undo log 保证原子性；通过 redo log 保证持久性。</p></blockquote><h2 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h2><p>首先介绍一下 MySQL 事务的 ACID 特性：</p><ul><li><p>原子性（Atomicity）：事务中所有操作作为一个整体像原子一样不可分割，要么全部成功，要么全部失败；</p></li><li><p>一致性（Consistency）：事务的执行结果必须使数据从一个一致性状态到另一个一致性状态。一致性状态是指：a. 系统的状态满足数据的完整性约束；b. 系统的状态反映数据库本应描述现实世界的真实状态，比如转账前后两个账户的金额总和应该保持不变；</p></li><li><p>隔离性（Isolation）：并发执行的事务不会互相影响，其对数据库的影响和他们串行执行时一样。比如多个用户同时往一个账户转账，最后账户的结果应该和他们按先后次序转账的结果一样；</p></li><li><p>持久性（Durability）：事务一旦提交，其对数据库的更新就是持久的。任何事务或系统故障都不会导致数据丢失。</p></li></ul><h3 id="事务的特点"><a href="#事务的特点" class="headerlink" title="事务的特点"></a>事务的特点</h3><p>事务的根本追求：数据一致性</p><p>可能会对事务一致性造成破坏的原因：</p><ul><li><p>事务的并发执行</p></li><li><p>事务故障或系统故障</p></li></ul><p>避免事务一致性被破坏的技术手段：</p><ul><li><p>并发控制技术（保证事务隔离性，防止事务并发执行破坏数据的一致性）</p></li><li><p>日志恢复技术（保证事务的原子性和持久性，防止事务故障或系统故障破坏数据一致性）</p></li></ul><img src="https://gitee.com/dongzl/article-images/raw/master/2020/09-The-Implementation-Principles-Of-MySQL-ACID/The-Implementation-Principles-Of-MySQL-ACID_01.png"><h3 id="事务的实现原理"><a href="#事务的实现原理" class="headerlink" title="事务的实现原理"></a>事务的实现原理</h3><ul><li><p>原子性：通过 undo log 来实现</p></li><li><p>持久性：通过 redo log 来实现</p></li><li><p>隔离性：读写锁 + MVCC 来实现</p></li><li><p>一致性：通过 原子性 + 隔离性 + 持久性 来实现</p></li></ul><p><strong>undo log 作用以及实现原理</strong></p><p>作用：保证事务原子性；实现多版本并发控制（MVCC）</p><p>原理：在操作任何数据之前，先将数据备份到 undo log，然后进行数据的修改，如果出现了错误或者 ROLLBACK 回滚事务，可以利用 undo log 中的备份将数据回复到事务开始之前的状态，undo log 是逻辑日志，可以理解为：</p><ul><li>当 delete 一条记录时，undo log 中会记录一条对应的 insert 记录；</li><li>当 insert 一条记录时，undo log 中会记录一条对应的 delete 记录；</li><li>当 update 一条记录时，它记录一条对应相反的 update 记录。</li></ul><p><strong>redo log 作用以及实现原理</strong></p><p>作用：保证事务的持久性</p><p>原理：redo log 记录的是新数据的备份。在事务提交前，只要将 redo log 持久化即可，不需要立即将数据持久化（预写式日志：WAL）。当系统崩溃时，虽然数据没有持久化，但是 redo log 已经持久化。系统可以根据 redo log 的内容，将所有的数据恢复到最新的状态。</p><p><strong>事务的隔离性</strong></p><p>事务具有隔离性，理论上来说事务之间的执行不应该互相影响，其对数据库的影响应该和串行执行时一样。</p><p>然而完全的隔离级别会导致系统并发性能很低，降低对资源的利用率，因此对事务的隔离性要求会放宽，这也会一定程度上造成对数据库一致性要求降低。</p><p>SQL 标准定义的事务的隔离级别：</p><ul><li><p>读未提交（READ UNCOMMITTED）：对事务处理没有任何限制，不推荐</p></li><li><p>读已提交（READ COMMITTED）：Oracle 数据库默认的隔离级别</p></li><li><p>可重复读（REPEATABLE READ）：MySQL 数据库默认隔离级别</p></li><li><p>串行化（SERIALIZABLE）：并发性能最低，不推荐</p></li></ul><p>不同的隔离级别可能导致的并发异常：</p><table><thead><tr><th>事务的隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>读未提交（READ UNCOMMITTED）</td><td>YES</td><td>YES</td><td>YES</td></tr><tr><td>读已提交（READ COMMITTED）</td><td></td><td>YES</td><td>YES</td></tr><tr><td>可重复读（REPEATABLE READ）</td><td></td><td></td><td>YES</td></tr><tr><td>串行化（SERIALIZABLE）</td><td></td><td></td><td></td></tr></tbody></table><p>设置事务的隔离级别操作：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 查看 MySQL 事务是否自动提交</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">session</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'autocommit'</span>;</span><br><span class="line"><span class="keyword">select</span> @@autocommit;</span><br><span class="line"></span><br><span class="line">// MySQL 关闭事务自动提交</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">session</span> autocommit=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">// 查看 MySQL 当前事务隔离级别</span><br><span class="line"><span class="keyword">SELECT</span> @@tx_isolation;</span><br><span class="line"></span><br><span class="line">// 修改 MySQL 事务隔离级别</span><br><span class="line">// 设置read uncommitted级别：</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">session</span> <span class="keyword">transaction</span> <span class="keyword">isolation</span> <span class="keyword">level</span> <span class="keyword">read</span> uncommitted;</span><br><span class="line"></span><br><span class="line">// 设置read committed级别：</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">session</span> <span class="keyword">transaction</span> <span class="keyword">isolation</span> <span class="keyword">level</span> <span class="keyword">read</span> committed;</span><br><span class="line"></span><br><span class="line">// 设置repeatable read级别：</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">session</span> <span class="keyword">transaction</span> <span class="keyword">isolation</span> <span class="keyword">level</span> repeatable <span class="keyword">read</span>;</span><br><span class="line"></span><br><span class="line">// 设置serializable级别：</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">session</span> <span class="keyword">transaction</span> <span class="keyword">isolation</span> <span class="keyword">level</span> <span class="keyword">serializable</span>;</span><br></pre></td></tr></table></figure><p><strong>事务的隔离性实现原理：锁</strong></p><p>MySQL 锁分类：</p><ul><li><p>共享锁（读锁）：数据只能读取，不能更新；</p></li><li><p>排他锁（写锁）：执行写入操作时，其他事务不能读取。</p></li></ul><p>锁粒度：锁定对象的大小就是锁的粒度：记录 / 表。</p><p>基于锁的并发流程控制：</p><ul><li><p>事务根据自己对数据项进行的操作类型申请相应的锁（读申请共享锁，写申请排他锁）</p></li><li><p>申请锁的请求被发送给锁管理器。锁管理器根据当前数据项是否已经有锁以及申请的和持有的锁是否冲突决定是否为该请求授予锁；</p></li><li><p>若锁被授予，则申请锁的事务可以继续执行；若被拒绝，则申请锁的事务将进行等待，知道锁被其他事务释放。</p></li></ul><h2 id="面试题-1"><a href="#面试题-1" class="headerlink" title="面试题"></a>面试题</h2><blockquote><p>MySQL 中 InnoDB 存储引擎和 MyISAM 存储引擎的区别？</p></blockquote><p><a href="https://www.zhihu.com/question/20596402?sort=created" target="_blank" rel="noopener">Mysql 中 MyISAM 和 InnoDB 的区别有哪些？</a></p><table><thead><tr><th>特征</th><th>MyISAM</th><th>InnoDB</th></tr></thead><tbody><tr><td>索引类型</td><td>非聚簇索引</td><td>聚簇索引</td></tr><tr><td>支持事务</td><td>否</td><td>是</td></tr><tr><td>支持表锁</td><td>是</td><td>是</td></tr><tr><td>支持行锁</td><td>否</td><td>是</td></tr><tr><td>支持外键</td><td>否</td><td>是</td></tr><tr><td>支持全文索引</td><td>是</td><td>是（5.6版本后支持）</td></tr><tr><td>适合操作类型</td><td>大量select</td><td>大量 inset/delete/update</td></tr><tr><td>文件组织形式</td><td>.frm / .ibd</td><td>.MYD / .MYI / .frm</td></tr></tbody></table><p><strong>其他区别内容：</strong></p><ul><li><p>MyISAM：.frm文件存储表定义；数据文件的扩展名为.MYD(MYData)；索引文件的扩展名是.MYI (MYIndex)。</p></li><li><p>InnoDB：.frm文件存储表定义；.ibd 文件和 .ibdata 文件：这两种文件都是存放InnoDB 数据的文件，之所以用两种文件来存放 文件：这两种文件都是存放InnoDB 的数据，是因为 文件：这两种文件都是存放InnoDB 的数据存储方式能够通过配置来决定是使用共享表空间存放存储数据，还是用独享表空间存放存储数据。独享表空间存储方式使用 .ibd 文件，并且每个表一个 .ibd 文件；共享表空间存储方式使用 .ibdata 文件，所有表共同使用一个 .ibdata 文件。</p></li><li><p>MyISAM：允许没有任何索引和主键的表存在，索引都是保存行的地址。</p></li><li><p>InnoDB：如果没有设定主键或者非空唯一索引，就会自动生成一个6字节的主键(用户不可见)，数据是主索引的一部分，附加索引保存的是主索引的值。</p></li><li><p>MyISAM： 保存有表的总行数，如果 select count() from table; 会直接取出出该值。</p></li><li><p>InnoDB： 没有保存表的总行数，如果使用 select count(*) from table; 就会遍历整个表，消耗相当大，但是在加了 wehre 条件后，MyISAM 和 InnoDB 处理的方式都一样。</p></li></ul><div class="row">    <embed src="https://gitee.com/dongzl/article-images/raw/master/pdf/这几道mysql题你搞懂了，金三银四涨薪稳了.pdf" width="100%" height="550" type="application/pdf"></div><ul><li><p>参考资料</p></li><li><p><a href="https://www.cnblogs.com/f-ck-need-u/archive/2018/05/08/9010872.html" target="_blank" rel="noopener">详细分析MySQL事务日志(redo log和undo log)</a></p></li><li><p><a href="https://www.zhihu.com/question/20596402?sort=created" target="_blank" rel="noopener">Mysql 中 MyISAM 和 InnoDB 的区别有哪些？</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;面试题&quot;&gt;&lt;a href=&quot;#面试题&quot; class=&quot;headerlink&quot; title=&quot;面试题&quot;&gt;&lt;/a&gt;面试题&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;MySQL 数据库的原子性和持久性怎么保证？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
      
    
    </summary>
    
    
      <category term="数据库" scheme="https://dongzl.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MySQL" scheme="https://dongzl.github.io/tags/MySQL/"/>
    
      <category term="ACID" scheme="https://dongzl.github.io/tags/ACID/"/>
    
      <category term="Redo log" scheme="https://dongzl.github.io/tags/Redo-log/"/>
    
      <category term="Undo log" scheme="https://dongzl.github.io/tags/Undo-log/"/>
    
  </entry>
  
  <entry>
    <title>论“茴”字的四种写法：一道面试题总结线程间通信的几种方式</title>
    <link href="https://dongzl.github.io/2020/03/07/07-Several-Methods-Of-Communication-Between-Thread/"/>
    <id>https://dongzl.github.io/2020/03/07/07-Several-Methods-Of-Communication-Between-Thread/</id>
    <published>2020-03-07T13:35:58.000Z</published>
    <updated>2020-03-09T13:32:28.199Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景描述"><a href="#背景描述" class="headerlink" title="背景描述"></a>背景描述</h2><blockquote><p>用两个线程，一个输出字母，一个输出数字，交替输出：1A2B3C4D5E…26Z。</p></blockquote><img src="https://gitee.com/dongzl/article-images/raw/master/2020/07-Several-Methods-Of-Communication-Between-Thread/Several-Methods-Of-Communication-Between-Thread.png"><p>这是一道典型的线程间通信的面试题，两个线程交替<strong>运行-暂停</strong>，并且当一个线程运行后需要暂停，同时要通知另外一个线程运行；另外一个线程得到通知后开始运行，运行后暂停并通知对方线程运行，彼此交替运行，直至打印完整结果。对于这个问题有很多中解法，下面我们就一一分析这些方法。</p><a id="more"></a><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="LockSupport-类实现"><a href="#LockSupport-类实现" class="headerlink" title="LockSupport 类实现"></a>LockSupport 类实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.LockSupport;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockSupportDemo</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Thread t1, t2;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] digit = <span class="keyword">new</span> String[]&#123;<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"5"</span>, <span class="string">"6"</span>, <span class="string">"7"</span>, <span class="string">"8"</span>, <span class="string">"9"</span>, <span class="string">"10"</span>&#125;;</span><br><span class="line">        String[] alphabet = <span class="keyword">new</span> String[]&#123;<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>, <span class="string">"E"</span>, <span class="string">"F"</span>, <span class="string">"G"</span>, <span class="string">"H"</span>, <span class="string">"I"</span>, <span class="string">"J"</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (String d : digit) &#123;</span><br><span class="line">                    System.out.println(d);</span><br><span class="line">                    LockSupport.unpark(t2);</span><br><span class="line">                    LockSupport.park(t1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t1"</span>);</span><br><span class="line">        </span><br><span class="line">        t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (String a : alphabet) &#123;</span><br><span class="line">                    LockSupport.park(t2);</span><br><span class="line">                    System.out.println(a);</span><br><span class="line">                    LockSupport.unpark(t1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t2"</span>);</span><br><span class="line">        </span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>LockSupport</code> 中的 <code>park</code> 和 <code>unpark</code> 可以实现线程的阻塞与唤醒。</p><ul><li><p><code>park</code>: Disables the current thread for thread scheduling purposes unless the permit is available.</p></li><li><p><code>unpark</code>: Makes available the permit for the given thread, if it was not already available.</p></li></ul><h3 id="while-循环-volatile-变量实现"><a href="#while-循环-volatile-变量实现" class="headerlink" title="while 循环 + volatile 变量实现"></a>while 循环 + volatile 变量实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WhileCycleDemo</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">enum</span> RunThreadEnum &#123;T1, T2&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> RunThreadEnum run = RunThreadEnum.T1;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] digit = <span class="keyword">new</span> String[]&#123;<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"5"</span>, <span class="string">"6"</span>, <span class="string">"7"</span>, <span class="string">"8"</span>, <span class="string">"9"</span>, <span class="string">"10"</span>&#125;;</span><br><span class="line">        String[] alphabet = <span class="keyword">new</span> String[]&#123;<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>, <span class="string">"E"</span>, <span class="string">"F"</span>, <span class="string">"G"</span>, <span class="string">"H"</span>, <span class="string">"I"</span>, <span class="string">"J"</span>&#125;;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (String d : digit) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (run != RunThreadEnum.T1) &#123;&#125;</span><br><span class="line">                    System.out.println(d);</span><br><span class="line">                    run = RunThreadEnum.T2;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t1"</span>).start();</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (String a : alphabet) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (run != RunThreadEnum.T2) &#123;&#125;</span><br><span class="line">                    System.out.println(a);</span><br><span class="line">                    run = RunThreadEnum.T1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 <code>while 循环 + volatile 变量</code> 这种实现方案，程序并不难理解，通过交替设置某个变量值的方式实现效果，不过这种方式实现需要注意一点就是 <code>run</code> 变量一定要使用 <code>volatile</code> 关键字修饰，保证变量的内存可见性。</p><h3 id="AtomicBoolean-类实现"><a href="#AtomicBoolean-类实现" class="headerlink" title="AtomicBoolean 类实现"></a>AtomicBoolean 类实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicBoolean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicBooleanDemo</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> AtomicBoolean run = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] digit = <span class="keyword">new</span> String[]&#123;<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"5"</span>, <span class="string">"6"</span>, <span class="string">"7"</span>, <span class="string">"8"</span>, <span class="string">"9"</span>, <span class="string">"10"</span>&#125;;</span><br><span class="line">        String[] alphabet = <span class="keyword">new</span> String[]&#123;<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>, <span class="string">"E"</span>, <span class="string">"F"</span>, <span class="string">"G"</span>, <span class="string">"H"</span>, <span class="string">"I"</span>, <span class="string">"J"</span>&#125;;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (String d : digit) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (run.get()) &#123;&#125;</span><br><span class="line">                    System.out.println(d);</span><br><span class="line">                    run.set(<span class="keyword">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t1"</span>).start();</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (String a : alphabet) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (!run.get()) &#123;&#125;</span><br><span class="line">                    System.out.println(a);</span><br><span class="line">                    run.set(<span class="keyword">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>AtomicBoolean</code> 类实现也比较好理解，主要是借助内部API实现来保证变量在线程之间的可见性。</p><h3 id="BlockingQueue-阻塞队列实现"><a href="#BlockingQueue-阻塞队列实现" class="headerlink" title="BlockingQueue 阻塞队列实现"></a>BlockingQueue 阻塞队列实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockingQueueDemo</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> BlockingQueue&lt;String&gt; queue1 = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">static</span> BlockingQueue&lt;String&gt; queue2 = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] digit = <span class="keyword">new</span> String[]&#123;<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"5"</span>, <span class="string">"6"</span>, <span class="string">"7"</span>, <span class="string">"8"</span>, <span class="string">"9"</span>, <span class="string">"10"</span>&#125;;</span><br><span class="line">        String[] alphabet = <span class="keyword">new</span> String[]&#123;<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>, <span class="string">"E"</span>, <span class="string">"F"</span>, <span class="string">"G"</span>, <span class="string">"H"</span>, <span class="string">"I"</span>, <span class="string">"J"</span>&#125;;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (String d : digit) &#123;</span><br><span class="line">                    System.out.println(d);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        queue1.put(<span class="string">"ok"</span>);</span><br><span class="line">                        queue2.take();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t1"</span>).start();</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (String a : alphabet) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        queue1.take();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(a);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        queue2.put(<span class="string">"ok"</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>借助 <code>BlockingQueue</code> 类实现，主要是借助阻塞队列的阻塞特性，当队列为空时，调用阻塞队列的 <code>take</code> 方法，会阻塞当前线程的执行，直到队列不为空后唤醒当前线程继续执行。</p><h3 id="PipedInputStream-amp-PipedOutputStream-实现"><a href="#PipedInputStream-amp-PipedOutputStream-实现" class="headerlink" title="PipedInputStream &amp; PipedOutputStream 实现"></a>PipedInputStream &amp; PipedOutputStream 实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PipedInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.PipedOutputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PipedStreamDemo</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String[] digit = <span class="keyword">new</span> String[]&#123;<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"5"</span>, <span class="string">"6"</span>, <span class="string">"7"</span>, <span class="string">"8"</span>, <span class="string">"9"</span>, <span class="string">"10"</span>&#125;;</span><br><span class="line">        String[] alphabet = <span class="keyword">new</span> String[]&#123;<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>, <span class="string">"E"</span>, <span class="string">"F"</span>, <span class="string">"G"</span>, <span class="string">"H"</span>, <span class="string">"I"</span>, <span class="string">"J"</span>&#125;;</span><br><span class="line">    </span><br><span class="line">        PipedInputStream input1 = <span class="keyword">new</span> PipedInputStream();</span><br><span class="line">        PipedInputStream input2 = <span class="keyword">new</span> PipedInputStream();</span><br><span class="line">        PipedOutputStream output1 = <span class="keyword">new</span> PipedOutputStream();</span><br><span class="line">        PipedOutputStream output2 = <span class="keyword">new</span> PipedOutputStream();</span><br><span class="line">        </span><br><span class="line">        input1.connect(output2);</span><br><span class="line">        input2.connect(output1);</span><br><span class="line">        </span><br><span class="line">        String msg = <span class="string">"exchange"</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">8</span>];</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (String d : digit) &#123;</span><br><span class="line">                        System.out.println(d);</span><br><span class="line">                        output1.write(msg.getBytes());</span><br><span class="line">                        input1.read(buffer);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t1"</span>).start();</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">8</span>];</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (String a : alphabet) &#123;</span><br><span class="line">                        input2.read(buffer);</span><br><span class="line">                        System.out.println(a);</span><br><span class="line">                        output2.write(msg.getBytes());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种事借助了 <code>java.io</code> 包中的 <code>PipedInputStream &amp; PipedOutputStream</code> 来实现，这两个类在实际中真是没有使用过，而且从程序运行效果来看，上述代码执行效率非常之低，其实这种实现方案只是一个凑数，开脑洞的方案。</p><h3 id="synchronized-wait-notifyAll-实现"><a href="#synchronized-wait-notifyAll-实现" class="headerlink" title="synchronized + wait() + notifyAll() 实现"></a>synchronized + wait() + notifyAll() 实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitNotifyDemo</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        Object o = <span class="keyword">new</span> Object();</span><br><span class="line">        </span><br><span class="line">        String[] digit = <span class="keyword">new</span> String[]&#123;<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"5"</span>, <span class="string">"6"</span>, <span class="string">"7"</span>, <span class="string">"8"</span>, <span class="string">"9"</span>, <span class="string">"10"</span>&#125;;</span><br><span class="line">        String[] alphabet = <span class="keyword">new</span> String[]&#123;<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>, <span class="string">"E"</span>, <span class="string">"F"</span>, <span class="string">"G"</span>, <span class="string">"H"</span>, <span class="string">"I"</span>, <span class="string">"J"</span>&#125;;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (o) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (String d : digit) &#123;</span><br><span class="line">                        System.out.println(d);</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            o.notifyAll();</span><br><span class="line">                            o.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    o.notifyAll(); <span class="comment">//一定再调用一次，否则程序无法退出执行</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t1"</span>).start();</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (o) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (String a : alphabet) &#123;</span><br><span class="line">                        System.out.println(a);</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            o.notifyAll();</span><br><span class="line">                            o.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    o.notifyAll();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 <code>Object</code> 类中 <code>wait()</code> &amp; <code>notifyAll()</code> 方法使用，也可以达到交替打印的效果。其中 <code>wait()</code> 方法作用是使当前线程阻塞，释放资源对象 o，<code>notifyAll()</code> 方法作用是唤醒正在等待资源对象 o 的线程，使其继续向下执行。这里需要注意一点是在循环打印输出之后，一定要再次调用<code>notifyAll()</code> 方法，因为两个线程交替<strong>执行-等待</strong>，最后一定会有一个线程处于等待状态，如果不最后再调用一次<code>notifyAll()</code> 方法，那么一定会有一个线程无法退出执行，程序也就无法终止。</p><p>PS. 这里还有一点需要注意就是上述程序无法控制<strong>数字和字母输出先后顺序，也行是数字先输出，也许是字母先输出</strong>，因为线程两断代码完全一致，执行先后顺序无法确定，这个问题我们可以借助 <code>CountDownLatch</code> 工具类或者通过一个标志变量来处理，程序如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitNotifyDemo</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        Object o = <span class="keyword">new</span> Object();</span><br><span class="line">    </span><br><span class="line">        CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        String[] digit = <span class="keyword">new</span> String[]&#123;<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"5"</span>, <span class="string">"6"</span>, <span class="string">"7"</span>, <span class="string">"8"</span>, <span class="string">"9"</span>, <span class="string">"10"</span>&#125;;</span><br><span class="line">        String[] alphabet = <span class="keyword">new</span> String[]&#123;<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>, <span class="string">"E"</span>, <span class="string">"F"</span>, <span class="string">"G"</span>, <span class="string">"H"</span>, <span class="string">"I"</span>, <span class="string">"J"</span>&#125;;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">//latch.await(); //借助 CountDownLatch 工具解决先后顺序问题(需要处理异常)</span></span><br><span class="line">                <span class="keyword">synchronized</span> (o) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (!flag) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            o.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">for</span> (String d : digit) &#123;</span><br><span class="line">                        System.out.println(d);</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            o.notifyAll();</span><br><span class="line">                            o.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    o.notifyAll(); <span class="comment">//一定再调用一次，否则程序无法退出执行</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t1"</span>).start();</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (o) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (String a : alphabet) &#123;</span><br><span class="line">                        System.out.println(a);</span><br><span class="line">                        <span class="comment">//latch.countDown();</span></span><br><span class="line">                        flag = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            o.notifyAll();</span><br><span class="line">                            o.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    o.notifyAll();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Lock-Condition-实现"><a href="#Lock-Condition-实现" class="headerlink" title="Lock + Condition 实现"></a>Lock + Condition 实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockConditionDemo</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        String[] digit = <span class="keyword">new</span> String[]&#123;<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"5"</span>, <span class="string">"6"</span>, <span class="string">"7"</span>, <span class="string">"8"</span>, <span class="string">"9"</span>, <span class="string">"10"</span>&#125;;</span><br><span class="line">        String[] alphabet = <span class="keyword">new</span> String[]&#123;<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>, <span class="string">"E"</span>, <span class="string">"F"</span>, <span class="string">"G"</span>, <span class="string">"H"</span>, <span class="string">"I"</span>, <span class="string">"J"</span>&#125;;</span><br><span class="line">    </span><br><span class="line">        Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        Condition condition1 = lock.newCondition();</span><br><span class="line">        Condition condition2 = lock.newCondition();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    lock.lock();</span><br><span class="line">                    <span class="keyword">for</span> (String d : digit) &#123;</span><br><span class="line">                        System.out.println(d);</span><br><span class="line">                        condition2.signalAll();</span><br><span class="line">                        condition1.await();</span><br><span class="line">                    &#125;</span><br><span class="line">                    condition2.signalAll(); <span class="comment">// 需要调用一次，否则程序无法终止</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t1"</span>).start();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    lock.lock();</span><br><span class="line">                    <span class="keyword">for</span> (String a : alphabet) &#123;</span><br><span class="line">                        System.out.println(a);</span><br><span class="line">                        condition1.signalAll();</span><br><span class="line">                        condition2.await();</span><br><span class="line">                    &#125;</span><br><span class="line">                    condition1.signalAll();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Lock + Condition</code> 实现方案与 <code>synchronized + wait() + notifyAll()</code>实现方案非常类似，包括使用的API都存在相似的对应关系：</p><ul><li>synchronized 关键字 VS Lock 类</li><li>Condition.await() VS Object.wait()</li><li>Condition.signalAll() VS Object.notifyAll()</li></ul><p>包括需要注意的问题，在使用 <code>Lock + Condition</code> 时我们也需要在循环执行最后在调用一次 <code>signalAll()</code> 方法，否则程序无法终止运行。</p><h2 id="最后总结"><a href="#最后总结" class="headerlink" title="最后总结"></a>最后总结</h2><p>对于这道面试题，主要还是考察线程之间通信问题，主要的考点应该是在<code>synchronized + wait() + notifyAll()</code> 的使用上，当然对于其他实现方案，比较好的是：</p><ul><li>Lock + Condition 实现</li><li>LockSupport 类实现</li></ul><p>对于其它的方案，有的是使用了一些编程技巧，有的是利用 JDK 中现有类的一些实现，并不是重点考察方向，像 <code>PipedInputStream &amp; PipedOutputStream</code> 的实现方案，虽然可以达到效果，其实有些充数的嫌疑，如果有面试官硬扣这种实现，就有点像鲁迅笔下的孔乙己先生在和你讨论“茴”字有几种写法的味道了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景描述&quot;&gt;&lt;a href=&quot;#背景描述&quot; class=&quot;headerlink&quot; title=&quot;背景描述&quot;&gt;&lt;/a&gt;背景描述&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;用两个线程，一个输出字母，一个输出数字，交替输出：1A2B3C4D5E…26Z。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;img src=&quot;https://gitee.com/dongzl/article-images/raw/master/2020/07-Several-Methods-Of-Communication-Between-Thread/Several-Methods-Of-Communication-Between-Thread.png&quot;&gt;

&lt;p&gt;这是一道典型的线程间通信的面试题，两个线程交替&lt;strong&gt;运行-暂停&lt;/strong&gt;，并且当一个线程运行后需要暂停，同时要通知另外一个线程运行；另外一个线程得到通知后开始运行，运行后暂停并通知对方线程运行，彼此交替运行，直至打印完整结果。对于这个问题有很多中解法，下面我们就一一分析这些方法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java开发" scheme="https://dongzl.github.io/categories/java%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Thread" scheme="https://dongzl.github.io/tags/Thread/"/>
    
      <category term="Lock" scheme="https://dongzl.github.io/tags/Lock/"/>
    
      <category term="synchronized" scheme="https://dongzl.github.io/tags/synchronized/"/>
    
  </entry>
  
  <entry>
    <title>极客时间 《数据结构与算法之美》 学习笔记</title>
    <link href="https://dongzl.github.io/2020/03/05/06-The-Beauty-Of-Data-Structures-And-Algorithms/"/>
    <id>https://dongzl.github.io/2020/03/05/06-The-Beauty-Of-Data-Structures-And-Algorithms/</id>
    <published>2020-03-05T01:36:44.000Z</published>
    <updated>2020-03-09T14:18:41.064Z</updated>
    
    <content type="html"><![CDATA[<p>本文是 <a href="https://time.geekbang.org/" target="_blank" rel="noopener">极客时间</a> 上 <a href="https://time.geekbang.org/column/intro/126" target="_blank" rel="noopener">数据结构与算法之美</a> 课程的学习笔记内容。</p><a id="more"></a><h2 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h2><h3 id="10-递归：如何用三行代码找到“最终推荐人”？"><a href="#10-递归：如何用三行代码找到“最终推荐人”？" class="headerlink" title="10 | 递归：如何用三行代码找到“最终推荐人”？"></a>10 | 递归：如何用三行代码找到“最终推荐人”？</h3><p><strong>递归需要满足的三个条件</strong>：</p><ul><li>一个问题的解可以分解为几个子问题的解</li><li>这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样</li><li>存在递归终止条件</li></ul><p><font color="red">写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码</font></p><p><strong>编写递归代码的关键是，只要遇到递归，我们就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤。</strong></p><p><strong>使用递归可能需要规避的问题</strong>：</p><ul><li>递归代码要警惕堆栈溢出</li><li>递归代码要警惕重复计算</li></ul><p><a href="https://mp.weixin.qq.com/s/Ki3WN2AJ5HhxxmaQ0lVh3Q" target="_blank" rel="noopener">还有程序员天真地以为”尾递归“真的可以避免堆栈溢出！</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是 &lt;a href=&quot;https://time.geekbang.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;极客时间&lt;/a&gt; 上 &lt;a href=&quot;https://time.geekbang.org/column/intro/126&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;数据结构与算法之美&lt;/a&gt; 课程的学习笔记内容。&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://dongzl.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="https://dongzl.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="https://dongzl.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>聊聊代理模式（Proxy）的使用</title>
    <link href="https://dongzl.github.io/2020/02/29/05-Design-Pattern-Proxy/"/>
    <id>https://dongzl.github.io/2020/02/29/05-Design-Pattern-Proxy/</id>
    <published>2020-02-29T06:44:21.000Z</published>
    <updated>2020-03-23T07:04:57.620Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>最近在学习 <a href="https://time.geekbang.org/" target="_blank" rel="noopener">极客时间</a> 的 <a href="https://time.geekbang.org/column/intro/250" target="_blank" rel="noopener">设计模式之美</a> 课程，这一篇算是自己的学习总结。代理模式（Proxy）在很多非常优秀框架中都有他的身影，比如，大名鼎鼎的 Spring AOP 就是使用动态代理（Dynamic Proxy）模式；还有就是在一些微服务框架中，如果调用一个远程服务接口，RPC 框架一般都会使用代理模式。</p><a id="more"></a><h2 id="代理模式介绍"><a href="#代理模式介绍" class="headerlink" title="代理模式介绍"></a>代理模式介绍</h2><p><strong>代理模式定义</strong></p><p><strong>Proxy Pattern</strong>: Provide a surrogate or placeholder for another object to control access to it.（为其他对象提供一种代理以控制对这个对象的访问。）</p><img src="https://gitee.com/dongzl/article-images/raw/master/2020/05-Design-Pattern-Proxy/Design-Pattern-Proxy_01.png" width="600px"><ul><li>Subject：定义 RealSubject 对外的接口，且这些接口必须被 Proxy 实现，这样外部调用 proxy 的接口最终都被转化为对 RealSubject 的调用。</li><li>RealSubject：真正的目标对象（被代理对象）。</li><li>Proxy：目标对象的代理，负责控制和管理目标对象，并间接地传递外部对目标对象的访问。</li></ul><h2 id="静态代理实现"><a href="#静态代理实现" class="headerlink" title="静态代理实现"></a>静态代理实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticProxy</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> ProxyExecute(<span class="keyword">new</span> RemoteExecute()).execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Executable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RemoteExecute</span> <span class="keyword">implements</span> <span class="title">Executable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">        System.out.println(<span class="string">"Remote execute ......"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProxyExecute</span> <span class="keyword">implements</span> <span class="title">Executable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Executable executable;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxyExecute</span><span class="params">(Executable executable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.executable = executable;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        executable.execute();</span><br><span class="line">        System.out.println(<span class="string">"Time: "</span> + (System.currentTimeMillis() - start));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码就是静态代理个一个简单实现，由于在静态代理模式中 Proxy 只能代理固定实现某个接口的被代理对象，所以并不十分灵活，所以在这个静态代理的基础上就衍生出了动态代理（Dynamic Proxy）。</p><h2 id="JDK-动态代理实现"><a href="#JDK-动态代理实现" class="headerlink" title="JDK 动态代理实现"></a>JDK 动态代理实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDKDynamicProxy</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Executable remote = <span class="keyword">new</span> RemoteExecute();</span><br><span class="line">        </span><br><span class="line">        System.getProperties().setProperty(<span class="string">"sun.misc.ProxyGenerator.saveGeneratedFiles"</span>, <span class="string">"true"</span>);</span><br><span class="line">        </span><br><span class="line">        Executable executable = (Executable)Proxy.newProxyInstance(JDKDynamicProxy.class.getClassLoader(), <span class="keyword">new</span> Class[]&#123;Executable.class&#125;, <span class="keyword">new</span> ExecuteInvocationHandler(remote));</span><br><span class="line">        executable.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExecuteInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Executable executable;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExecuteInvocationHandler</span><span class="params">(Executable executable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.executable = executable;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        Object result = method.invoke(executable, args);</span><br><span class="line">        System.out.println(<span class="string">"Time: "</span> + (System.currentTimeMillis() - start));</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Executable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RemoteExecute</span> <span class="keyword">implements</span> <span class="title">Executable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">        System.out.println(<span class="string">"Remote execute ......"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JDK 的动态代理是通过 Proxy 类来实现的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</span> </span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> IllegalArgumentException</span></span><br></pre></td></tr></table></figure><p>newProxyInstance 方法需要三个参数，</p><ul><li>loader 是生成代理类的类加载器；</li><li>interfaces 指定被代理类实现的接口（所以很多资料都说 JDK 的动态代理需要被代理类必须实现某一个接口，其实证据就在这里）；</li><li>h 调用处理器（实现 InvocationHandler 接口，InvocationHandler 接口中定义了 invoke 方法）。</li></ul><p>通过设置 JDK 属性，我们可以将动态代理过程中生成的代理类保存下来，观察 JDK 动态生成的代理类的一些实现细节：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.getProperties().setProperty(<span class="string">"sun.misc.ProxyGenerator.saveGeneratedFiles"</span>, <span class="string">"true"</span>);</span><br></pre></td></tr></table></figure><p>PS. <strong>这个属性值在不同 JDK 版本名称不同，JDK8 中为 <code>sun.misc.ProxyGenerator.saveGeneratedFiles</code>，JDK12 中是 <code>jdk.proxy.ProxyGenerator.saveGeneratedFiles</code>，没有深究是从 JDK 哪个版本改的这个属性名。</strong></p><p>通过设置这个参数，在程序运行后会生成一个 <code>$Proxy0.class</code> 文件，我们通过工具反编译文件后内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Source code recreated from a .class file by IntelliJ IDEA</span></span><br><span class="line"><span class="comment">// (powered by Fernflower decompiler)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> design.pattern.proxy.v2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.UndeclaredThrowableException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> $<span class="title">Proxy0</span> <span class="keyword">extends</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Executable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> $Proxy0(InvocationHandler var1) <span class="keyword">throws</span>  &#123;</span><br><span class="line">        <span class="keyword">super</span>(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略 equals 方法</span></span><br><span class="line">    <span class="comment">// 省略 toString 方法</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m3, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略 hashCode 方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            m1 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"equals"</span>, Class.forName(<span class="string">"java.lang.Object"</span>));</span><br><span class="line">            m2 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"toString"</span>);</span><br><span class="line">            m3 = Class.forName(<span class="string">"design.pattern.proxy.v2.Executable"</span>).getMethod(<span class="string">"execute"</span>);</span><br><span class="line">            m0 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"hashCode"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodError(var2.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoClassDefFoundError(var3.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过类的结构我们可以知道动态生成代理类 <code>$Proxy0</code> 继承自 <code>Proxy</code> 类，同时实现了我们自定义的 <code>Executable</code> 接口，并重写了其中的 <code>execute</code> 方法，<code>execute</code> 方法实现很简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m3, (Object[])<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p>调用父类中 <code>h</code> 变量的 <code>invoke</code> 方法，其中 <code>h</code> 变量就是我们实现的 <code>InvocationHandler</code> 接口的 <code>ExecuteInvocationHandler</code> 类变量。</p><p>JDK 动态代理实现流程图：</p><img src="https://gitee.com/dongzl/article-images/raw/master/2020/05-Design-Pattern-Proxy/Design-Pattern-Proxy_02.png"><h2 id="cglib-动态代理"><a href="#cglib-动态代理" class="headerlink" title="cglib 动态代理"></a>cglib 动态代理</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CGlibDynamicProxy</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setSuperclass(RemoteExecute.class);</span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> ExecuteMethodInterceptor());</span><br><span class="line">        RemoteExecute execute = (RemoteExecute)enhancer.create();</span><br><span class="line">        execute.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExecuteMethodInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(o.getClass().getSuperclass().getName());</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        Object result = methodProxy.invokeSuper(o, objects);</span><br><span class="line">        System.out.println(<span class="string">"Time: "</span> + (System.currentTimeMillis() - start));</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RemoteExecute</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">        System.out.println(<span class="string">"Remote execute ......"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>cglib 实现的动态代理功能使用的是 <code>Enhancer</code> 类，其中需要定义 <code>MethodInterceptor</code> 接口实现类，<code>MethodInterceptor</code> 接口与 JDK 动态代理中的 InvocationHandler 接口作用非常类型，内部通过反射调用被代理类的方法。</p><p><code>cglib</code> 动态代理一个比较的的优势是被代理类（RemoteExecute）不需要实现任何接口，这个就是很多资料上说的 <code>cglib</code> 动态代理与 <code>JDK</code> 动态代理的一个很大区别就是：<strong>cglib 动态代理不需要被代理类实现任何接口，而 JDK 动态代理需要被代理类必须要实现一个接口。</strong> 由于 <code>cglib</code> 动态代理的这个优势，所以 <code>Spring AOP</code> 的动态代理就是通过 <code>cglib</code> 来实现的。</p><h2 id="代理模式使用总结"><a href="#代理模式使用总结" class="headerlink" title="代理模式使用总结"></a>代理模式使用总结</h2><p>代理模式的目的：</p><ul><li>为外部调用者提供一个访问服务提供者的代理对象。</li></ul><p>代理模式的动机：</p><ul><li>限制对目标对象的直接访问，降低耦合度。</li></ul><p>代理模式优点：</p><ul><li>低耦合（协调调用者和被调用者）</li><li>易扩展</li><li>灵活度高</li></ul><p>代理模式缺点：</p><ul><li>间接访问可能会延迟请求相应</li><li>增加工作量</li></ul><p>代理模式分类：</p><ul><li>静态代理</li><li>动态代理</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><p><a href="https://www.cnblogs.com/yssjun/archive/2019/05/31/10889022.html" target="_blank" rel="noopener">设计模式之代理模式（proxy pattern）</a></p></li><li><p><a href="https://www.cnblogs.com/liuyun1995/p/8144628.html" target="_blank" rel="noopener">JDK动态代理</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景介绍&quot;&gt;&lt;a href=&quot;#背景介绍&quot; class=&quot;headerlink&quot; title=&quot;背景介绍&quot;&gt;&lt;/a&gt;背景介绍&lt;/h2&gt;&lt;p&gt;最近在学习 &lt;a href=&quot;https://time.geekbang.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;极客时间&lt;/a&gt; 的 &lt;a href=&quot;https://time.geekbang.org/column/intro/250&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;设计模式之美&lt;/a&gt; 课程，这一篇算是自己的学习总结。代理模式（Proxy）在很多非常优秀框架中都有他的身影，比如，大名鼎鼎的 Spring AOP 就是使用动态代理（Dynamic Proxy）模式；还有就是在一些微服务框架中，如果调用一个远程服务接口，RPC 框架一般都会使用代理模式。&lt;/p&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="https://dongzl.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://dongzl.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>极客时间 《深入浅出计算机组成原理》 学习笔记</title>
    <link href="https://dongzl.github.io/2020/02/21/04-On-The-Principle-Of-Computer-Composition/"/>
    <id>https://dongzl.github.io/2020/02/21/04-On-The-Principle-Of-Computer-Composition/</id>
    <published>2020-02-21T12:54:33.000Z</published>
    <updated>2020-03-10T02:25:46.323Z</updated>
    
    <content type="html"><![CDATA[<p>本文是 <a href="https://time.geekbang.org/" target="_blank" rel="noopener">极客时间</a> 上 <a href="https://time.geekbang.org/column/intro/170" target="_blank" rel="noopener">深入浅出计算机组成原理</a> 课程的学习笔记内容。</p><a id="more"></a><h2 id="入门篇"><a href="#入门篇" class="headerlink" title="入门篇"></a>入门篇</h2><h3 id><a href="#" class="headerlink" title></a></h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是 &lt;a href=&quot;https://time.geekbang.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;极客时间&lt;/a&gt; 上 &lt;a href=&quot;https://time.geekbang.org/column/intro/170&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;深入浅出计算机组成原理&lt;/a&gt; 课程的学习笔记内容。&lt;/p&gt;
    
    </summary>
    
    
      <category term="其他" scheme="https://dongzl.github.io/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="计算机组成原理" scheme="https://dongzl.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>计算机中常用数学公式汇总</title>
    <link href="https://dongzl.github.io/2020/02/17/03-The-Mathematical-Formula-Summary/"/>
    <id>https://dongzl.github.io/2020/02/17/03-The-Mathematical-Formula-Summary/</id>
    <published>2020-02-17T14:04:54.000Z</published>
    <updated>2020-03-09T14:20:17.388Z</updated>
    
    <content type="html"><![CDATA[<ul><li>斐波那契数列通向公式：</li></ul><p>$$a_n=\frac{1}{\sqrt{5}} \begin{bmatrix} \begin{pmatrix} \frac{1 + \sqrt{5}}{2} \end{pmatrix}^n - \begin{pmatrix} \frac{1 - \sqrt{5}}{2} \end{pmatrix}^n\end{bmatrix}$$</p><ul><li>斐波那契数列矩阵方程：</li></ul><p>$$\begin{bmatrix} f(n)\\ f(n - 1) \end{bmatrix} = \begin{bmatrix} 1&amp;1\\ 1&amp;0 \end{bmatrix} \begin{bmatrix} f(n - 1)\\ f(n - 2) \end{bmatrix} = \begin{bmatrix} 1&amp;1\\ 1&amp;0 \end{bmatrix}^{n + 1} \begin{bmatrix} f(1)\\ f(0) \end{bmatrix}$$</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;斐波那契数列通向公式：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$$a_n=\frac{1}{\sqrt{5}} \begin{bmatrix} \begin{pmatrix} \frac{1 + \sqrt{5}}{2} \end{pmatrix}^n - \begin{
      
    
    </summary>
    
    
      <category term="其他" scheme="https://dongzl.github.io/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="数学公式" scheme="https://dongzl.github.io/tags/%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>各种算法的复杂度</title>
    <link href="https://dongzl.github.io/2020/02/13/02-Know-Thy-Complexities/"/>
    <id>https://dongzl.github.io/2020/02/13/02-Know-Thy-Complexities/</id>
    <published>2020-02-13T02:17:58.000Z</published>
    <updated>2020-03-23T07:05:26.584Z</updated>
    
    <content type="html"><![CDATA[<p>你好，这个页面涵盖了计算机科学中常用算法的时间和空间复杂度。在准备过去的技术采访中，我自己花了几个小时爬取网页，把搜索、排序算法中最好情况、最坏情况以及平均情况时间复杂度的内容汇总到一起，这样我就不会在被问及这些问题时被难住了。在过去的几年里，我采访了硅谷的几家初创公司，以及一些大公司，例如谷歌、Facebook、雅虎、LinkedIn和Uber，每次我准备采访时，我都会想“为什么没有人创建一个好的大O备忘单呢？”。所以，为了给你们这些好人节省很多时间，我创造了一个。享受吧！</p><a id="more"></a><blockquote><p>Hi there!  This webpage covers the space and time Big-O complexities of common algorithms used in Computer Science.  When preparing for technical interviews in the past, I found myself spending hours crawling the internet putting together the best, average, and worst case complexities for search and sorting algorithms so that I wouldn’t be stumped when asked about them.  Over the last few years, I’ve interviewed at several Silicon Valley startups, and also some bigger companies, like Google, Facebook, Yahoo, LinkedIn, and Uber, and each time that I prepared for an interview, I thought to myself “Why hasn’t someone created a nice Big-O cheat sheet?”.  So, to save all of you fine folks a ton of time, I went ahead and created one.  Enjoy!</p></blockquote><h2 id="大O复杂度统计图"><a href="#大O复杂度统计图" class="headerlink" title="大O复杂度统计图"></a>大O复杂度统计图</h2><p>Big-O Complexity Chart</p><img src="https://gitee.com/dongzl/article-images/raw/master/2020/02-Know-Thy-Complexities/Big-O-Complexity-Chart.png" width="1000px"><h2 id="常用数据结构操作"><a href="#常用数据结构操作" class="headerlink" title="常用数据结构操作"></a>常用数据结构操作</h2><p>Common Data Structure Operations</p><img src="https://gitee.com/dongzl/article-images/raw/master/2020/02-Know-Thy-Complexities/Common-Data-Structure-Operations.png" width="1000px"><h2 id="线性排序算法"><a href="#线性排序算法" class="headerlink" title="线性排序算法"></a>线性排序算法</h2><p>Array Sorting Algorithms</p><img src="https://gitee.com/dongzl/article-images/raw/master/2020/02-Know-Thy-Complexities/Array-Sorting-Algorithms.png" width="1000px"><h2 id="官方网站-Big-O-统计数据图"><a href="#官方网站-Big-O-统计数据图" class="headerlink" title="官方网站 Big-O 统计数据图"></a>官方网站 Big-O 统计数据图</h2><p>Get the Official Big-O Cheat Sheet Poster</p><img src="https://gitee.com/dongzl/article-images/raw/master/2020/02-Know-Thy-Complexities/Big-O-Cheat-Sheet-Poster.png" width="1000px"><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.bigocheatsheet.com/" target="_blank" rel="noopener">Know Thy Complexities!</a></li><li><a href="https://blog.csdn.net/herorenme/article/details/8919095" target="_blank" rel="noopener">Know Thy Complexities! (各种算法的复杂度)</a></li><li><a href="https://www.cnblogs.com/datascientist/p/3557401.html" target="_blank" rel="noopener">Know Thy Complexities!</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;你好，这个页面涵盖了计算机科学中常用算法的时间和空间复杂度。在准备过去的技术采访中，我自己花了几个小时爬取网页，把搜索、排序算法中最好情况、最坏情况以及平均情况时间复杂度的内容汇总到一起，这样我就不会在被问及这些问题时被难住了。在过去的几年里，我采访了硅谷的几家初创公司，以及一些大公司，例如谷歌、Facebook、雅虎、LinkedIn和Uber，每次我准备采访时，我都会想“为什么没有人创建一个好的大O备忘单呢？”。所以，为了给你们这些好人节省很多时间，我创造了一个。享受吧！&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://dongzl.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="https://dongzl.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="https://dongzl.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Google Guava EventBus 在 ShardingShere 中的应用</title>
    <link href="https://dongzl.github.io/2020/02/01/01-Google-Guava-EventBus-ShardingSphere/"/>
    <id>https://dongzl.github.io/2020/02/01/01-Google-Guava-EventBus-ShardingSphere/</id>
    <published>2020-02-01T10:02:52.000Z</published>
    <updated>2020-03-23T07:04:13.795Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Guava-EventBus-介绍"><a href="#Guava-EventBus-介绍" class="headerlink" title="Guava EventBus 介绍"></a>Guava EventBus 介绍</h2><p>Guava 的 EventBus 可以简化生产/消费模型。EventBus 通过非常简单的方式，实现了观察者模式中的监听注册，事件分发。</p><blockquote><p>Dispatches events to listeners, and provides ways for listeners to register themselves. The EventBus allows publish-subscribe-style communication between components without requiring the components to explicitly register with one another (and thus be aware of each other). It is designed exclusively to replace traditional Java in-processs event distribution using explicit registration. It is not a general-purpose publish-subscribe system, nor is it intended for interprocess communication.</p></blockquote><blockquote><p>将事件分发给监听器，同时提供监听器注册监听的方式。EventBus 支持组件之间的发布-订阅式通信，而不需要组件显式地彼此注册（从而彼此感知对方存在）。它是专门为使用显式注册来替代传统的 Java 进程内事件分发而设计的。它不是一个通用的发布订阅系统，也不支持进程间通信。</p></blockquote><a id="more"></a><img src="https://gitee.com/dongzl/article-images/raw/master/2020/01-Google-Guava-EventBus-ShardingSphere/Google-Guava-EventBus.png" width="600px"><p>通过阅读 Guava 的 EventBus 源码，EventBus 支持的操作如下：</p><ul><li>Receiving Events（接收事件）</li><li>Posting Events （发布事件）</li><li>Subscriber Methods （订阅事件）</li><li>Dead Events （没有订阅者的事件）</li></ul><h2 id="EventBus-发布-订阅使用"><a href="#EventBus-发布-订阅使用" class="headerlink" title="EventBus 发布/订阅使用"></a>EventBus 发布/订阅使用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 订阅者</span></span><br><span class="line"><span class="keyword">import</span> com.google.common.eventbus.Subscribe;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EventHandler</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Subscribe</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mq</span><span class="params">(MQEvent mq)</span> </span>&#123;</span><br><span class="line">        System.out.println(mq.getClass().getCanonicalName() + <span class="string">" work"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 订阅事件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MQEvent</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试类</span></span><br><span class="line"><span class="keyword">import</span> com.google.common.eventbus.EventBus;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EventTest</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//初始化消息总线</span></span><br><span class="line">        EventBus eventBus = <span class="keyword">new</span> EventBus();</span><br><span class="line">        <span class="comment">// 注册订阅者</span></span><br><span class="line">        eventBus.register(<span class="keyword">new</span> EventHandler());</span><br><span class="line">        <span class="comment">//MqEvent推送给订阅者</span></span><br><span class="line">        MQEvent mqEvent = <span class="keyword">new</span> MQEvent();</span><br><span class="line">        <span class="comment">//发布消息</span></span><br><span class="line">        eventBus.post(mqEvent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="EventBus-在-ShardingSphere-中的实际应用"><a href="#EventBus-在-ShardingSphere-中的实际应用" class="headerlink" title="EventBus 在 ShardingSphere 中的实际应用"></a>EventBus 在 ShardingSphere 中的实际应用</h2><p>在 <a href="https://github.com/apache/incubator-shardingsphere" target="_blank" rel="noopener">ShardingSphere</a> 项目中需要将数据库配置信息存储到统一配置中心（例如：ZooKeeper、nacos、Apollo），对于统一的配置中心可以通过监听机制，监听配置中心配置信息的变化，将配置中心变更的信息推送给 ShardingSphere，对于这种情况就是一个典型的发布-订阅模型，在 ShardingSphere 就是通过 EventBus 来完成这个功能的，我们来看一下 ShardingSphere 的代码实现：</p><ul><li><p>系统启动时，通过 ShardingOrchestrationFacade.init() 方法注册监听内容，ConfigurationChangedListenerManager.initListeners() 方法用于启动对于系统配置的监听。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigurationChangedListenerManager</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    ... ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Initialize all configuration changed listeners.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initListeners</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        schemaChangedListener.watch(ChangedType.UPDATED, ChangedType.DELETED);</span><br><span class="line">        propertiesChangedListener.watch(ChangedType.UPDATED);</span><br><span class="line">        authenticationChangedListener.watch(ChangedType.UPDATED);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>例如在 PropertiesChangedListener.watch() 方法中，通过调用父类的 PostShardingConfigCenterEventListener.watch(final ChangedType… watchedChangedTypes) 方法完成监听，在 PostShardingConfigCenterEventListener 方法中使用了 EventBus，注册监听配置中心中某个 Key 的变化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">watch</span><span class="params">(<span class="keyword">final</span> String watchKey, <span class="keyword">final</span> Collection&lt;ChangedType&gt; watchedChangedTypeList)</span> </span>&#123;</span><br><span class="line">    configCenter.watch(watchKey, <span class="keyword">new</span> DataChangedEventListener() &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onChange</span><span class="params">(<span class="keyword">final</span> DataChangedEvent dataChangedEvent)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (watchedChangedTypeList.contains(dataChangedEvent.getChangedType())) &#123;</span><br><span class="line">                eventBus.post(createShardingOrchestrationEvent(dataChangedEvent));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>对于配置中心监听配置信息的变化都是由不同的框架（ZooKeeper、nacos、Apollo）来完成的，下面以 nacos 为例，看一下监听实现，nacos 中配置信息发生变化后对通过 receiveConfigInfo 方法推送给 ShardingShpere，ShardingShpere 接收到变更后通过 EventBus 的 post 方法发送变更事件，订阅事件的类接收到变更后会进行相应逻辑处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">watch</span><span class="params">(<span class="keyword">final</span> String key, <span class="keyword">final</span> DataChangedEventListener dataChangedEventListener)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String dataId = key.replace(<span class="string">"/"</span>, <span class="string">"."</span>);</span><br><span class="line">        String group = properties.getProperty(<span class="string">"group"</span>, <span class="string">"SHARDING_SPHERE_DEFAULT_GROUP"</span>);</span><br><span class="line">        configService.addListener(dataId, group, <span class="keyword">new</span> Listener() &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Executor <span class="title">getExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveConfigInfo</span><span class="params">(<span class="keyword">final</span> String configInfo)</span> </span>&#123;</span><br><span class="line">                dataChangedEventListener.onChange(<span class="keyword">new</span> DataChangedEvent(key, configInfo, DataChangedEvent.ChangedType.UPDATED));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> NacosException ex) &#123;</span><br><span class="line">        log.debug(<span class="string">"Nacos watch key exception for: &#123;&#125;"</span>, ex.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>ShardingSphere 中事件订阅，例如，在 ShardingProxyContext 需要监听配置信息变化，在构造方法中将当前实例对象（this）注册到 EventBus，通过 @Subscribe 注解监听配置变更，监听到配置变更的数据后发送给 ShardingShere，处理内部相关逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ShardingProxyContext</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ShardingProxyContext INSTANCE = <span class="keyword">new</span> ShardingProxyContext();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> ShardingProperties shardingProperties = <span class="keyword">new</span> ShardingProperties(<span class="keyword">new</span> Properties());</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ShardingProxyContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ShardingOrchestrationEventBus.getInstance().register(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ShardingProxyContext <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Renew properties.</span></span><br><span class="line"><span class="comment">     * 监听事件的变化</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> event properties changed event</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Subscribe</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">renew</span><span class="params">(<span class="keyword">final</span> PropertiesChangedEvent event)</span> </span>&#123;</span><br><span class="line">        ConfigurationLogger.log(event.getProps());</span><br><span class="line">        shardingProperties = <span class="keyword">new</span> ShardingProperties(event.getProps());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="DeadEvent-使用场景"><a href="#DeadEvent-使用场景" class="headerlink" title="DeadEvent 使用场景"></a>DeadEvent 使用场景</h2><blockquote><p>Wraps an event that was posted, but which had no subscribers and thus could not be delivered.Registering a DeadEvent subscriber is useful for debugging or logging, as it can detect misconfigurations in a system’s event distribution.</p></blockquote><blockquote><p>包装了一个被发送的事件，但是这个事件却没有任何订阅者，因此这个事件可能不会被实际发送。注册一个 DeadEvent 事件订阅器对于调试或日志记录很有用，因为它可以检测事件分布系统中的错误配置。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义事件，没有订阅者</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MQEvent</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DeadEvent 处理器</span></span><br><span class="line"><span class="keyword">import</span> com.google.common.eventbus.DeadEvent;</span><br><span class="line"><span class="keyword">import</span> com.google.common.eventbus.Subscribe;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadEventHandler</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 没有订阅者时被触发</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Subscribe</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deadEvent</span><span class="params">(DeadEvent event)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Receive a DeadEvent"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试类</span></span><br><span class="line"><span class="keyword">import</span> com.google.common.eventbus.EventBus;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadEventTest</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化消息总线</span></span><br><span class="line">        EventBus eventBus = <span class="keyword">new</span> EventBus();</span><br><span class="line">        <span class="comment">// 注册 DeadEvent 订阅者</span></span><br><span class="line">        eventBus.register(<span class="keyword">new</span> DeadEventHandler());</span><br><span class="line">        <span class="comment">// MqEvent推送给订阅者</span></span><br><span class="line">        MQEvent mqEvent = <span class="keyword">new</span> MQEvent();</span><br><span class="line">        <span class="comment">// 发布消息，没有订阅者</span></span><br><span class="line">        eventBus.post(mqEvent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其他类使用"><a href="#其他类使用" class="headerlink" title="其他类使用"></a>其他类使用</h2><ul><li><p>AsyncEventBus：异步事件总线，当处理耗时的处理时很有用，我们要依赖Executors来实现异步事件总线。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AsyncEventBus asyncEventBus = <span class="keyword">new</span> AsyncEventBus(executorService);</span><br></pre></td></tr></table></figure></li><li><p>AllowConcurrentEvents：在设置观察者时，需要使用注解类@Subscribe来标识一个订阅者，但在注解中还要一个注解@AllowConcurrentEvents，这个注解是用来标识当前订阅者是线程安全的。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Creates a &#123;<span class="doctag">@code</span> Subscriber&#125; for &#123;<span class="doctag">@code</span> method&#125; on &#123;<span class="doctag">@code</span> listener&#125;. </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Subscriber <span class="title">create</span><span class="params">(EventBus bus, Object listener, Method method)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> isDeclaredThreadSafe(method)</span><br><span class="line">        ? <span class="keyword">new</span> Subscriber(bus, listener, method)</span><br><span class="line">        : <span class="keyword">new</span> SynchronizedSubscriber(bus, listener, method);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://greengerong.github.io/blog/2014/11/27/guava-eventbus/" target="_blank" rel="noopener">Guava - EventBus(事件总线)</a></li><li><a href="https://www.jianshu.com/p/a950d7c294e5" target="_blank" rel="noopener">Guava eventBus 关于@AllowConcurrentEvents 纪实</a></li><li><a href="https://www.iteye.com/blog/uule-2096279" target="_blank" rel="noopener">用guava实现简单的事件驱动</a></li><li><a href="https://www.jianshu.com/p/703fa6cf6e44" target="_blank" rel="noopener">Guava EventBus</a></li><li><a href="https://www.yeetrack.com/?p=1177" target="_blank" rel="noopener">走近Guava(六): 事件总线EventBus</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Guava-EventBus-介绍&quot;&gt;&lt;a href=&quot;#Guava-EventBus-介绍&quot; class=&quot;headerlink&quot; title=&quot;Guava EventBus 介绍&quot;&gt;&lt;/a&gt;Guava EventBus 介绍&lt;/h2&gt;&lt;p&gt;Guava 的 EventBus 可以简化生产/消费模型。EventBus 通过非常简单的方式，实现了观察者模式中的监听注册，事件分发。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Dispatches events to listeners, and provides ways for listeners to register themselves. The EventBus allows publish-subscribe-style communication between components without requiring the components to explicitly register with one another (and thus be aware of each other). It is designed exclusively to replace traditional Java in-processs event distribution using explicit registration. It is not a general-purpose publish-subscribe system, nor is it intended for interprocess communication.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;将事件分发给监听器，同时提供监听器注册监听的方式。EventBus 支持组件之间的发布-订阅式通信，而不需要组件显式地彼此注册（从而彼此感知对方存在）。它是专门为使用显式注册来替代传统的 Java 进程内事件分发而设计的。它不是一个通用的发布订阅系统，也不支持进程间通信。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="web开发" scheme="https://dongzl.github.io/categories/web%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Guava" scheme="https://dongzl.github.io/tags/Guava/"/>
    
      <category term="EventBus" scheme="https://dongzl.github.io/tags/EventBus/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://dongzl.github.io/2019/12/26/hello-world/"/>
    <id>https://dongzl.github.io/2019/12/26/hello-world/</id>
    <published>2019-12-26T13:35:58.000Z</published>
    <updated>2020-03-09T13:29:46.081Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;Quick-Start&quot;&gt;&lt;a href=&quot;#Quick-Start&quot; class=&quot;headerlink&quot; title=&quot;Quick Start&quot;&gt;&lt;/a&gt;Quick Start&lt;/h2&gt;&lt;h3 id=&quot;Create-a-new-post&quot;&gt;&lt;a href=&quot;#Create-a-new-post&quot; class=&quot;headerlink&quot; title=&quot;Create a new post&quot;&gt;&lt;/a&gt;Create a new post&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo new &lt;span class=&quot;string&quot;&gt;&quot;My New Post&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="其他" scheme="https://dongzl.github.io/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="hexo" scheme="https://dongzl.github.io/tags/hexo/"/>
    
  </entry>
  
</feed>
