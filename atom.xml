<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>董宗磊的博客</title>
  
  <subtitle>董宗磊的博客--善积跬步，方以千里</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://dongzl.github.io/"/>
  <updated>2020-03-15T04:25:17.588Z</updated>
  <id>https://dongzl.github.io/</id>
  
  <author>
    <name>[object Object]</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MySQL 主从复制原理及配置</title>
    <link href="https://dongzl.github.io/2020/03/15/12-MySQL-Master-Slave-Replication/"/>
    <id>https://dongzl.github.io/2020/03/15/12-MySQL-Master-Slave-Replication/</id>
    <published>2020-03-15T03:04:01.000Z</published>
    <updated>2020-03-15T04:25:17.588Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MySQL-主从复制原理"><a href="#MySQL-主从复制原理" class="headerlink" title="MySQL 主从复制原理"></a>MySQL 主从复制原理</h2><h3 id="什么是-MySQL-的主从复制"><a href="#什么是-MySQL-的主从复制" class="headerlink" title="什么是 MySQL 的主从复制"></a>什么是 MySQL 的主从复制</h3><p>MySQL 主从复制是指数据可以从一个 MySQL 数据库服务器主节点复制到一个或多个从节点。MySQL 默认采用异步复制方式，这样从节点不用一直访问主服务器来更新自己的数据，数据的更新可以在远程连接上进行，从节点可以复制主数据库中的所有数据库或者特定的数据库，或者特定的表。</p><h3 id="为什么需要主从复制"><a href="#为什么需要主从复制" class="headerlink" title="为什么需要主从复制"></a>为什么需要主从复制</h3><ul><li>提高数据库读写性能，提升系统吞吐量</li></ul><p>在业务复杂的系统中，如果有一条 SQL 语句的执行需要锁表，导致 MySQL 暂时不能提供读的服务，那么就很影响运行中的业务，使用主从复制，让主库负责写，从库负责读，这样即使主库出现了锁表的情景，通过读从库也可以保证业务的正常运作。</p><ul><li><p>做数据库热备</p></li><li><p>架构扩展需要</p></li></ul><p>业务量越来越大，I/O 访问频率过高，单机无法满足，此时做多库的存储，降低磁盘I/O 访问的频率，提升整个数据库性能。</p><h3 id="MySQL-的复制原理"><a href="#MySQL-的复制原理" class="headerlink" title="MySQL 的复制原理"></a>MySQL 的复制原理</h3><p><strong>原理</strong>：</p><ul><li><p>master 服务器将数据的改变记录二进制 binlog 日志，当 master 上的数据发生改变时，则将其改变写入二进制日志中；</p></li><li><p>slave 服务器会在一定时间间隔内对 master 二进制日志进行探测其是否发生改变，如果发生改变，则开始一个 I/OThread 请求 master 二进制事件；</p></li><li><p>同时主节点为每个 I/O 线程启动一个 dump 线程，用于向其发送二进制事件，并保存至从节点本地的中继日志中，从节点将启动 SQL 线程从中继日志中读取二进制日志，在本地重放，使得其数据和主节点的保持一致，最后 I/OThread 和 SQLThread 将进入睡眠状态，等待下一次被唤醒。</p></li></ul><p><strong>也就是</strong>：</p><ul><li><p>从库会生成两个线程,一个 I/O 线程,一个 SQL 线程；</p></li><li><p>I/O 线程会去请求主库的 binlog，并将得到的 binlog 写到本地的 relay-log（中继日志）文件中；主库会生成一个 log dump 线程,用来给从库 I/O 线程传 binlog；</p></li><li><p>SQL 线程，会读取 relay log 文件中的日志，并解析成sql语句逐一执行。</p></li></ul><p><strong>注意</strong>：</p><ul><li><p>master 将操作语句记录到 binlog 日志中，然后授予 slave 远程连接的权限（master 一定要开启 binlog 二进制日志功能；通常为了数据安全考虑，slave 也开启binlog功能）；</p></li><li><p>slave 开启两个线程：IO 线程和 SQL 线程。其中：IO 线程负责读取 master 的 binlog 内容到中继日志 relay log 里；SQL 线程负责从 relay log 日志里读出 binlog 内容，并更新到 slave 的数据库里，这样就能保证 slave 数据和 master 数据保持一致了；</p></li><li><p>MySQL 复制至少需要两个 MySQL 的服务，当然 MySQL 服务可以分布在不同的服务器上，也可以在一台服务器上启动多个服务；</p></li><li><p>MySQL复制最好确保 master 和 slave 服务器上的 MySQL 版本相同（如果不能满足版本一致，那么要保证 master 主节点的版本低于 slave 从节点的版本）；</p></li><li><p>master 和 slave 两节点间时间需同步。</p></li></ul><img src="https://gitee.com/dongzl/article-images/raw/master/2020/12-MySQL-Master-Slave-Replication/MySQL-Master-Slave-Replication-01.jpeg"><p><strong>具体步骤</strong>：</p><ul><li><p>从库通过手工执行 change master to 语句连接主库，提供了连接的用户一切条件（user 、password、port、ip），并且让从库知道，二进制日志的起点位置（file名 position 号）start slave；</p></li><li><p>从库的 IO 线程和主库的 dump 线程建立连接；</p></li><li><p>从库根据 change master to 语句提供的 file 名和 position 号，IO 线程向主库发起 binlog 的请求；</p></li><li><p>主库 dump 线程根据从库的请求，将本地 binlog 以 events 的方式发给从库IO 线程；</p></li><li><p>从库 IO 线程接收 binlog events，并存放到本地 relay-log 中，传送过来的信息，会记录到 <code>master.info</code> 中；</p></li><li><p>从库 SQL 线程应用 relay-log，并且把应用过的记录到 <code>relay-log.info</code> 中，默认情况下，已经应用过的 relay 会自动被清理 purge。</p></li></ul><h3 id="MySQL-主从复制的形式"><a href="#MySQL-主从复制的形式" class="headerlink" title="MySQL 主从复制的形式"></a>MySQL 主从复制的形式</h3><ul><li><p>一主一从</p></li><li><p>主主复制</p></li><li><p>一主多从</p></li><li><p>多主一从</p></li><li><p>级联复制</p></li></ul><img src="https://gitee.com/dongzl/article-images/raw/master/2020/12-MySQL-Master-Slave-Replication/MySQL-Master-Slave-Replication-02.png"><h3 id="MySQL-主从复制延时分析"><a href="#MySQL-主从复制延时分析" class="headerlink" title="MySQL 主从复制延时分析"></a>MySQL 主从复制延时分析</h3><p>MySQL 的主从复制都是单线程的操作，主库对所有 DDL 和 DML 产生的日志写进 binlog，由于 binlog 是顺序写，所以效率很高，slave 的 SQL thread 线程将主库的 DDL 和 DML 操作事件在 slave 中重放。DML 和 DDL 的 IO 操作是随机的，不是顺序，所以成本要高很多，另一方面，由于 SQL thread 也是单线程的，当主库的并发较高时，产生的 DML 数量超过 slave 的 SQL thread 所能处理的速度，或者当 slave 中有大型 query 语句产生了锁等待，那么延时就产生了。</p><p><strong>解决方案</strong>：</p><ul><li>业务的持久层实现采用分库架构，mysql 服务可以水平扩展，分散压力；</li><li>单个库读写分离，一主多从，主写从读，分散压力；这样从库压力可能会比主库高，保护主库。</li><li>服务的基础架构在业务系统和mysql之间加入memcache或者redis 的cache层，降低mysql读压力。</li><li>不同业务的mysql物理上放在不同的机器，分散压力。</li><li>使用比主库更好的硬件设备作为slave，mysql压力小，延迟自然会变小。</li><li>使用更加强劲的硬件设备。</li></ul><h2 id="MySQL-主从复制安装配置"><a href="#MySQL-主从复制安装配置" class="headerlink" title="MySQL 主从复制安装配置"></a>MySQL 主从复制安装配置</h2><h3 id="基础设置准备"><a href="#基础设置准备" class="headerlink" title="基础设置准备"></a>基础设置准备</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">操作系统：</span></span><br><span class="line">centos6.5</span><br><span class="line"><span class="meta">#</span><span class="bash">mysql版本：</span></span><br><span class="line">5.7</span><br><span class="line"><span class="meta">#</span><span class="bash">两台虚拟机：</span></span><br><span class="line">node1:192.168.85.111（主）</span><br><span class="line">node2:192.168.85.112（从）</span><br></pre></td></tr></table></figure><h3 id="安装-MySQL-数据库"><a href="#安装-MySQL-数据库" class="headerlink" title="安装 MySQL 数据库"></a>安装 MySQL 数据库</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">## 在两台数据库中分别创建数据库</span></span></span><br><span class="line"></span><br><span class="line">```sql</span><br><span class="line">--注意两台必须全部执行</span><br><span class="line">create database test;</span><br></pre></td></tr></table></figure><h3 id="在主（node1）服务器进行如下配置："><a href="#在主（node1）服务器进行如下配置：" class="headerlink" title="在主（node1）服务器进行如下配置："></a>在主（node1）服务器进行如下配置：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">修改配置文件，执行以下命令打开mysql配置文件</span></span><br><span class="line">vi /etc/my.cnf</span><br><span class="line"><span class="meta">#</span><span class="bash">在mysqld模块中添加如下配置信息</span></span><br><span class="line">log-bin=master-bin #二进制文件名称</span><br><span class="line">binlog-format=ROW  #二进制日志格式，有row、statement、mixed三种格式，row指的是把改变的内容复制过去，而不是把命令在从服务器上执行一遍，statement指的是在主服务器上执行的SQL语句，在从服务器上执行同样的语句。MySQL默认采用基于语句的复制，效率比较高。mixed指的是默认采用基于语句的复制，一旦发现基于语句的无法精确的复制时，就会采用基于行的复制。</span><br><span class="line">server-id=1   #要求各个服务器的id必须不一样</span><br><span class="line">binlog-do-db=test   #同步的数据库名称</span><br></pre></td></tr></table></figure><h3 id="配置从服务器登录主服务器的账号授权"><a href="#配置从服务器登录主服务器的账号授权" class="headerlink" title="配置从服务器登录主服务器的账号授权"></a>配置从服务器登录主服务器的账号授权</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--授权操作</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> validate_password_policy=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> validate_password_length=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">replication</span> <span class="keyword">slave</span> <span class="keyword">on</span> *.* <span class="keyword">to</span> <span class="string">'root'</span>@<span class="string">'%'</span> <span class="keyword">identified</span> <span class="keyword">by</span> <span class="string">'123456'</span>;</span><br><span class="line"><span class="comment">--刷新权限</span></span><br><span class="line"><span class="keyword">flush</span> <span class="keyword">privileges</span>;</span><br></pre></td></tr></table></figure><h3 id="从服务器的配置"><a href="#从服务器的配置" class="headerlink" title="从服务器的配置"></a>从服务器的配置</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">修改配置文件，执行以下命令打开mysql配置文件</span></span><br><span class="line">vi /etc/my.cnf</span><br><span class="line"><span class="meta">#</span><span class="bash">在mysqld模块中添加如下配置信息</span></span><br><span class="line">log-bin=master-bin#二进制文件的名称</span><br><span class="line">binlog-format=ROW#二进制文件的格式</span><br><span class="line">server-id=2#服务器的id</span><br></pre></td></tr></table></figure><h3 id="重启主服务器的mysqld服务"><a href="#重启主服务器的mysqld服务" class="headerlink" title="重启主服务器的mysqld服务"></a>重启主服务器的mysqld服务</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">重启mysql服务</span></span><br><span class="line">service mysqld restart</span><br><span class="line"><span class="meta">#</span><span class="bash">登录mysql数据库</span></span><br><span class="line">mysql -uroot -p</span><br><span class="line"><span class="meta">#</span><span class="bash">查看master的状态</span></span><br><span class="line">show master status；</span><br></pre></td></tr></table></figure><h3 id="重启从服务器并进行相关配置"><a href="#重启从服务器并进行相关配置" class="headerlink" title="重启从服务器并进行相关配置"></a>重启从服务器并进行相关配置</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">重启mysql服务</span></span><br><span class="line">service mysqld restart</span><br><span class="line"><span class="meta">#</span><span class="bash">登录mysql</span></span><br><span class="line">mysql -uroot -p</span><br><span class="line"><span class="meta">#</span><span class="bash">连接主服务器</span></span><br><span class="line">change master to master_host='192.168.85.11',master_user='root',master_password='123456',master_port=3306,master_log_file='master-bin.000001',master_log_pos=154;</span><br><span class="line"><span class="meta">#</span><span class="bash">启动slave</span></span><br><span class="line">start slave</span><br><span class="line"><span class="meta">#</span><span class="bash">查看slave的状态</span></span><br><span class="line">show slave status\G(注意没有分号)</span><br></pre></td></tr></table></figure><blockquote><p>内容来源：<a href="http://www.mashibing.com/" target="_blank" rel="noopener">马士兵教育</a> 公开课内容知识整理</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;MySQL-主从复制原理&quot;&gt;&lt;a href=&quot;#MySQL-主从复制原理&quot; class=&quot;headerlink&quot; title=&quot;MySQL 主从复制原理&quot;&gt;&lt;/a&gt;MySQL 主从复制原理&lt;/h2&gt;&lt;h3 id=&quot;什么是-MySQL-的主从复制&quot;&gt;&lt;a href=
      
    
    </summary>
    
    
      <category term="数据库" scheme="https://dongzl.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MySQL" scheme="https://dongzl.github.io/tags/MySQL/"/>
    
      <category term="主从复制" scheme="https://dongzl.github.io/tags/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 数据库优化知识总结</title>
    <link href="https://dongzl.github.io/2020/03/14/11-MySQL-Optimization-Knowledge-Summary/"/>
    <id>https://dongzl.github.io/2020/03/14/11-MySQL-Optimization-Knowledge-Summary/</id>
    <published>2020-03-14T14:06:18.000Z</published>
    <updated>2020-03-15T02:56:38.528Z</updated>
    
    <content type="html"><![CDATA[<h2 id="性能监控"><a href="#性能监控" class="headerlink" title="性能监控"></a>性能监控</h2><h3 id="show-profile-查询剖析工具"><a href="#show-profile-查询剖析工具" class="headerlink" title="show profile 查询剖析工具"></a>show profile 查询剖析工具</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">## https://dev.mysql.com/doc/refman/5.7/en/show-profile.html</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">profiles</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">## 开启 show profile 监控</span></span><br><span class="line"><span class="keyword">set</span> profiling=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">## 根据 Type 查询</span></span><br><span class="line"><span class="keyword">show</span> profile cpu <span class="keyword">for</span> <span class="keyword">query</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">show</span> profile <span class="keyword">all</span> <span class="keyword">for</span> <span class="keyword">query</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">## 未来有可能被移除，推荐使用 Performance Schema</span></span><br><span class="line">Note: </span><br><span class="line">The <span class="keyword">SHOW</span> PROFILE <span class="keyword">and</span> <span class="keyword">SHOW</span> <span class="keyword">PROFILES</span> statements <span class="keyword">are</span> deprecated <span class="keyword">and</span> will be removed <span class="keyword">in</span> a future MySQL release. </span><br><span class="line"><span class="keyword">Use</span> the <span class="keyword">Performance</span> <span class="keyword">Schema</span> instead; see Section 25.19.1, “Query Profiling Using Performance Schema”.</span><br><span class="line"></span><br><span class="line"><span class="comment">## 查看MySQL支持存储引擎类型</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">engines</span>;</span><br></pre></td></tr></table></figure><h3 id="Performance-Schema-库"><a href="#Performance-Schema-库" class="headerlink" title="Performance Schema 库"></a>Performance Schema 库</h3><p>5.7 新提供自带监控数据库，有 87 张数据表。</p><p><a href="https://dev.mysql.com/doc/refman/5.7/en/performance-schema.html" target="_blank" rel="noopener">MySQL Performance Schema</a></p><h3 id="使用-show-processlist-查看连接"><a href="#使用-show-processlist-查看连接" class="headerlink" title="使用 show processlist 查看连接"></a>使用 show processlist 查看连接</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">processlist</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'%max_connection%'</span>;</span><br></pre></td></tr></table></figure><h2 id="schema-与数据类型优化"><a href="#schema-与数据类型优化" class="headerlink" title="schema 与数据类型优化"></a>schema 与数据类型优化</h2><h3 id="数据类型优化"><a href="#数据类型优化" class="headerlink" title="数据类型优化"></a>数据类型优化</h3><ul><li>更小的通常更好</li><li>简单就好<ul><li>整型比字符类型代价更低</li><li>使用MySQL自带类型而不是字符串类型还存储日期和时间</li><li>用整型存储IP地址</li></ul></li></ul><ul><li>尽量避免 null</li><li>实际细则</li></ul><h3 id="索引优化细节"><a href="#索引优化细节" class="headerlink" title="索引优化细节"></a>索引优化细节</h3><ul><li><p>当使用索引列进行查询的时候尽量不要使用表达式，把计算放到业务层而不是数据层（表达式会导致索引失效）；</p></li><li><p>尽量使用主键查询，而不是其它索引，因为主键查询不会触发回表查询，减少 IO 次数；</p></li><li><p>使用前缀索引，前缀索引可以减少空间占用；</p></li><li><p>使用索引扫描来排序；</p></li><li><p>union all，in，or 都能够使用索引，但是推荐使用 in；</p></li><li><p>范围列可以用到索引；</p></li><li><p>强制类型转换会导致全表扫描，即索引失效；</p></li><li><p>更新十分频繁，数据区分度不高的字段上不宜建立索引；</p></li><li><p>创建索引的列，不允许为 null，可能会得到不符合预期的结果（null != null）；</p></li><li><p>当需要进行表连接的时候，最好不要超过三张表，因为需要 join 的字段，数据类型必须一致；</p></li><li><p>能使用 limit 的时候尽量使用 limit，减少后续查询操作（limit 1）；</p></li><li><p>单表索引建议控制在 5 个以内；</p></li><li><p>单索引字段数不允许超过 5 个（组合索引字段个数）；</p></li><li><p>创建索引的时候需要避免的错误概念：1、索引越多越好；2、过早优化，在不了解系统的情况下进行优化。</p></li></ul><h2 id="MySQL-执行计划"><a href="#MySQL-执行计划" class="headerlink" title="MySQL 执行计划"></a>MySQL 执行计划</h2><p>​在企业的应用场景中，为了知道优化SQL语句的执行，需要查看SQL语句的具体执行过程，以加快SQL语句的执行效率。</p><p>可以使用 explain + SQL 语句来模拟优化器执行 SQL 查询语句，从而知道 MySQL 是如何处理 SQL 语句的。</p><p>​<a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html" target="_blank" rel="noopener">EXPLAIN Output Format</a></p><h3 id="执行计划中包含的信息"><a href="#执行计划中包含的信息" class="headerlink" title="执行计划中包含的信息"></a>执行计划中包含的信息</h3><table><thead><tr><th align="center">Column</th><th align="center">Meaning</th></tr></thead><tbody><tr><td align="center">id</td><td align="center">The <code>SELECT</code> identifier</td></tr><tr><td align="center">select_type</td><td align="center">The <code>SELECT</code> type</td></tr><tr><td align="center">table</td><td align="center">The table for the output row</td></tr><tr><td align="center">partitions</td><td align="center">The matching partitions</td></tr><tr><td align="center">type</td><td align="center">The join type</td></tr><tr><td align="center">possible_keys</td><td align="center">The possible indexes to choose</td></tr><tr><td align="center">key</td><td align="center">The index actually chosen</td></tr><tr><td align="center">key_len</td><td align="center">The length of the chosen key</td></tr><tr><td align="center">ref</td><td align="center">The columns compared to the index</td></tr><tr><td align="center">rows</td><td align="center">Estimate of rows to be examined</td></tr><tr><td align="center">filtered</td><td align="center">Percentage of rows filtered by table condition</td></tr><tr><td align="center">extra</td><td align="center">Additional information</td></tr></tbody></table><p><strong>id</strong></p><p>select 查询的序列号，包含一组数字，表示查询中执行 select 子句或者操作表的顺序</p><p>id 号分为三种情况：</p><p>​1、如果 id 相同，那么执行顺序从上到下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp e <span class="keyword">join</span> dept d <span class="keyword">on</span> e.deptno = d.deptno <span class="keyword">join</span> salgrade sg <span class="keyword">on</span> e.sal <span class="keyword">between</span> sg.losal <span class="keyword">and</span> sg.hisal;</span><br></pre></td></tr></table></figure><p>​2、如果 id 不同，如果是子查询，id 的序号会递增，id 值越大优先级越高，越先被执行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp e <span class="keyword">where</span> e.deptno <span class="keyword">in</span> (<span class="keyword">select</span> d.deptno <span class="keyword">from</span> dept d <span class="keyword">where</span> d.dname = <span class="string">'SALES'</span>);</span><br></pre></td></tr></table></figure><p>3、id 相同和不同的，同时存在：相同的可以认为是一组，从上往下顺序执行，在所有组中，id 值越大，优先级越高，越先执行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp e <span class="keyword">join</span> dept d <span class="keyword">on</span> e.deptno = d.deptno <span class="keyword">join</span> salgrade sg <span class="keyword">on</span> e.sal <span class="keyword">between</span> sg.losal <span class="keyword">and</span> sg.hisal <span class="keyword">where</span> e.deptno <span class="keyword">in</span> (<span class="keyword">select</span> d.deptno <span class="keyword">from</span> dept d <span class="keyword">where</span> d.dname = <span class="string">'SALES'</span>);</span><br></pre></td></tr></table></figure><p><strong>select_type</strong></p><p>主要用来分辨查询的类型，是普通查询还是联合查询还是子查询</p><table><thead><tr><th align="center"><code>select_type</code> Value</th><th align="center">Meaning</th></tr></thead><tbody><tr><td align="center">SIMPLE</td><td align="center">Simple SELECT (not using UNION or subqueries)</td></tr><tr><td align="center">PRIMARY</td><td align="center">Outermost SELECT</td></tr><tr><td align="center">UNION</td><td align="center">Second or later SELECT statement in a UNION</td></tr><tr><td align="center">DEPENDENT UNION</td><td align="center">Second or later SELECT statement in a UNION, dependent on outer query</td></tr><tr><td align="center">UNION RESULT</td><td align="center">Result of a UNION.</td></tr><tr><td align="center">SUBQUERY</td><td align="center">First SELECT in subquery</td></tr><tr><td align="center">DEPENDENT SUBQUERY</td><td align="center">First SELECT in subquery, dependent on outer query</td></tr><tr><td align="center">DERIVED</td><td align="center">Derived table</td></tr><tr><td align="center">UNCACHEABLE SUBQUERY</td><td align="center">A subquery for which the result cannot be cached and must be re-evaluated for each row of the outer query</td></tr><tr><td align="center">UNCACHEABLE UNION</td><td align="center">The second or later select in a UNION that belongs to an uncacheable subquery (see UNCACHEABLE SUBQUERY)</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--sample:简单的查询，不包含子查询和union</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp;</span><br><span class="line"></span><br><span class="line"><span class="comment">--primary:查询中若包含任何复杂的子查询，最外层查询则被标记为Primary</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> staname,ename supname <span class="keyword">from</span> (<span class="keyword">select</span> ename staname,mgr <span class="keyword">from</span> emp) t <span class="keyword">join</span> emp <span class="keyword">on</span> t.mgr=emp.empno ;</span><br><span class="line"></span><br><span class="line"><span class="comment">--union:若第二个select出现在union之后，则被标记为union</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> deptno = <span class="number">10</span> <span class="keyword">union</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> sal &gt;<span class="number">2000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--dependent union:跟union类似，此处的depentent表示union或union all联合而成的结果会受外部表影响</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp e <span class="keyword">where</span> e.empno  <span class="keyword">in</span> ( <span class="keyword">select</span> empno <span class="keyword">from</span> emp <span class="keyword">where</span> deptno = <span class="number">10</span> <span class="keyword">union</span> <span class="keyword">select</span> empno <span class="keyword">from</span> emp <span class="keyword">where</span> sal &gt;<span class="number">2000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">--union result:从union表获取结果的select</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> deptno = <span class="number">10</span> <span class="keyword">union</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> sal &gt;<span class="number">2000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--subquery:在select或者where列表中包含子查询</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> sal &gt; (<span class="keyword">select</span> <span class="keyword">avg</span>(sal) <span class="keyword">from</span> emp) ;</span><br><span class="line"></span><br><span class="line"><span class="comment">--dependent subquery:subquery的子查询要受到外部表查询的影响</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp e <span class="keyword">where</span> e.deptno <span class="keyword">in</span> (<span class="keyword">select</span> <span class="keyword">distinct</span> deptno <span class="keyword">from</span> dept);</span><br><span class="line"></span><br><span class="line"><span class="comment">--DERIVED: from子句中出现的子查询，也叫做派生类，</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> staname,ename supname <span class="keyword">from</span> (<span class="keyword">select</span> ename staname,mgr <span class="keyword">from</span> emp) t <span class="keyword">join</span> emp <span class="keyword">on</span> t.mgr=emp.empno ;</span><br><span class="line"></span><br><span class="line"><span class="comment">--UNCACHEABLE SUBQUERY：表示使用子查询的结果不能被缓存</span></span><br><span class="line"> <span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> empno = (<span class="keyword">select</span> empno <span class="keyword">from</span> emp <span class="keyword">where</span> deptno=@@sort_buffer_size);</span><br><span class="line"> </span><br><span class="line"><span class="comment">--uncacheable union:表示union的查询结果不能被缓存：sql语句未验证</span></span><br></pre></td></tr></table></figure><p><strong>table</strong></p><p>对应行正在访问哪一个表，表名或者别名，可能是临时表或者 union 合并结果集</p><p>1、如果是具体的表名，则表明从实际的物理表中获取数据，当然也可以是表的别名</p><p>2、表名是 derivedN 的形式，表示使用了 id 为 N 的查询产生的衍生表</p><p>3、当有 union result 的时候，表名是 union n1,n2 等的形式，n1,n2 表示参与 union 的 id</p><p><strong>type</strong></p><p>type 显示的是访问类型，访问类型表示我是以何种方式去访问我们的数据，最容易想的是全表扫描，直接暴力的遍历一张表去寻找需要的数据，效率非常低下，访问的类型有很多，效率从最好到最坏依次是：</p><p>system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL </p><p>一般情况下，得保证查询至少达到 range 级别，最好能达到 ref</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--all:全表扫描，一般情况下出现这样的sql语句而且数据量比较大的话那么就需要进行优化。</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp;</span><br><span class="line"></span><br><span class="line"><span class="comment">--index：全索引扫描这个比all的效率要好，主要有两种情况，一种是当前的查询时覆盖索引，即我们需要的数据在索引中就可以索取，或者是使用了索引进行排序，这样就避免数据的重排序</span></span><br><span class="line"><span class="keyword">explain</span>  <span class="keyword">select</span> empno <span class="keyword">from</span> emp;</span><br><span class="line"></span><br><span class="line"><span class="comment">--range：表示利用索引查询的时候限制了范围，在指定范围内进行查询，这样避免了index的全索引扫描，适用的操作符： =, &lt;&gt;, &gt;, &gt;=, &lt;, &lt;=, IS NULL, BETWEEN, LIKE, or IN() </span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> empno <span class="keyword">between</span> <span class="number">7000</span> <span class="keyword">and</span> <span class="number">7500</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--index_subquery：利用索引来关联子查询，不再扫描全表</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> emp.job <span class="keyword">in</span> (<span class="keyword">select</span> job <span class="keyword">from</span> t_job);</span><br><span class="line"></span><br><span class="line"><span class="comment">--unique_subquery:该连接类型类似与index_subquery,使用的是唯一索引</span></span><br><span class="line"> <span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp e <span class="keyword">where</span> e.deptno <span class="keyword">in</span> (<span class="keyword">select</span> <span class="keyword">distinct</span> deptno <span class="keyword">from</span> dept);</span><br><span class="line"> </span><br><span class="line"><span class="comment">--index_merge：在查询过程中需要多个索引组合使用，没有模拟出来</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--ref_or_null：对于某个字段即需要关联条件，也需要null值的情况下，查询优化器会选择这种访问方式</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp e <span class="keyword">where</span>  e.mgr <span class="keyword">is</span> <span class="literal">null</span> <span class="keyword">or</span> e.mgr=<span class="number">7369</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--ref：使用了非唯一性索引进行数据的查找</span></span><br><span class="line"> <span class="keyword">create</span> <span class="keyword">index</span> idx_3 <span class="keyword">on</span> emp(deptno);</span><br><span class="line"> <span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp e,dept d <span class="keyword">where</span> e.deptno =d.deptno;</span><br><span class="line"></span><br><span class="line"><span class="comment">--eq_ref ：使用唯一性索引进行数据查找</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp,emp2 <span class="keyword">where</span> emp.empno = emp2.empno;</span><br><span class="line"></span><br><span class="line"><span class="comment">--const：这个表至多有一个匹配行，</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> empno = <span class="number">7369</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">--system：表只有一行记录（等于系统表），这是const类型的特例，平时不会出现</span></span><br></pre></td></tr></table></figure><p> <strong>possible_keys</strong> </p><p>显示可能应用在这张表中的索引，一个或多个，查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询实际使用</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp,dept <span class="keyword">where</span> emp.deptno = dept.deptno <span class="keyword">and</span> emp.deptno = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p><strong>key</strong></p><p>实际使用的索引，如果为 null，则没有使用索引，查询中若使用了覆盖索引，则该索引和查询的 select 字段重叠。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp,dept <span class="keyword">where</span> emp.deptno = dept.deptno <span class="keyword">and</span> emp.deptno = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p><strong>key_len</strong></p><p>表示索引中使用的字节数，可以通过 key_len 计算查询中使用的索引长度，在不损失精度的情况下长度越短越好。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp,dept <span class="keyword">where</span> emp.deptno = dept.deptno <span class="keyword">and</span> emp.deptno = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p><strong>ref</strong></p><p>显示索引的哪一列被使用了，如果可能的话，是一个常数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp,dept <span class="keyword">where</span> emp.deptno = dept.deptno <span class="keyword">and</span> emp.deptno = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p><strong>rows</strong></p><p>根据表的统计信息及索引使用情况，大致估算出找出所需记录需要读取的行数，此参数很重要，直接反应的 SQL 找了多少数据，在完成目的的情况下越少越好</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp;</span><br></pre></td></tr></table></figure><p><strong>extra</strong></p><p>包含额外的信息。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--using filesort:说明mysql无法利用索引进行排序，只能利用排序算法进行排序，会消耗额外的位置</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">order</span> <span class="keyword">by</span> sal;</span><br><span class="line"></span><br><span class="line"><span class="comment">--using temporary:建立临时表来保存中间结果，查询完成之后把临时表删除</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> ename,<span class="keyword">count</span>(*) <span class="keyword">from</span> emp <span class="keyword">where</span> deptno = <span class="number">10</span> <span class="keyword">group</span> <span class="keyword">by</span> ename;</span><br><span class="line"></span><br><span class="line"><span class="comment">--using index:这个表示当前的查询时覆盖索引的，直接从索引中读取数据，而不用访问数据表。如果同时出现using where 表名索引被用来执行索引键值的查找，如果没有，表面索引被用来读取数据，而不是真的查找</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> deptno,<span class="keyword">count</span>(*) <span class="keyword">from</span> emp <span class="keyword">group</span> <span class="keyword">by</span> deptno <span class="keyword">limit</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--using where:使用where进行条件过滤</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> t_user <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--using join buffer:使用连接缓存，情况没有模拟出来</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--impossible where：where语句的结果总是false</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> empno = <span class="number">7469</span>;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://zhenganwen.top/posts/433a3305/" target="_blank" rel="noopener">MySQL优化面试</a></li><li><a href="http://tigcms.jd.com/details/HkO5QrfPQ.html" target="_blank" rel="noopener">MySQL explain详解</a></li><li><a href="http://tigcms.jd.com/details/ryG-r2dM7.html" target="_blank" rel="noopener">MySQL数据库开发规范</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;性能监控&quot;&gt;&lt;a href=&quot;#性能监控&quot; class=&quot;headerlink&quot; title=&quot;性能监控&quot;&gt;&lt;/a&gt;性能监控&lt;/h2&gt;&lt;h3 id=&quot;show-profile-查询剖析工具&quot;&gt;&lt;a href=&quot;#show-profile-查询剖析工具&quot; class
      
    
    </summary>
    
    
      <category term="数据库" scheme="https://dongzl.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MySQL" scheme="https://dongzl.github.io/tags/MySQL/"/>
    
      <category term="优化" scheme="https://dongzl.github.io/tags/%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 数据库索引的实现原理</title>
    <link href="https://dongzl.github.io/2020/03/14/10-The-Implementation-Principles-Of-MySQL-Index/"/>
    <id>https://dongzl.github.io/2020/03/14/10-The-Implementation-Principles-Of-MySQL-Index/</id>
    <published>2020-03-14T05:52:04.000Z</published>
    <updated>2020-03-15T00:10:01.550Z</updated>
    
    <content type="html"><![CDATA[<h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><blockquote><p>1、MySQL 数据库索引分类。<br>2、MySQL 数据库 InnoDB 存储引擎的底层数据结构。<br>3、为什么底层使用 B+ 树而不用 B 树</p></blockquote><h2 id="MySQL-架构"><a href="#MySQL-架构" class="headerlink" title="MySQL 架构"></a>MySQL 架构</h2><img src="https://gitee.com/dongzl/article-images/raw/master/2020/10-The-Implementation-Principles-Of-MySQL-Index/The-Implementation-Principles-Of-MySQL-Index-03.png"><h2 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h2><p>MySQL 索引分五种类型：主键索引、唯一索引、普通索引和全文索引、组合索引。通过给字段添加索引可以提高数据的读取速度，提高项目的并发能力和抗压能力。</p><ul><li><p>主键索引：主键是一种唯一性索引，但它必须指定为 PRIMARY KEY，每个表只能有一个主键；</p></li><li><p>唯一索引：索引列的所有值都只能出现一次，即必须唯一，但是值可以为空；</p></li><li><p>普通索引：基本的索引类型，值可以为空，没有唯一性的限制；</p></li><li><p>全文索引：全文索引的索引类型为 FULLTEXT，全文索引可以在 varchar、char、text 类型的列上创建；（使用较少，一般都使用专门的搜索框架，例如 ElasticSearch）</p></li><li><p>组合索引：多列值组成一个索引，专门用于组合搜索。</p></li></ul><h2 id="MySQL-索引实现原理分析"><a href="#MySQL-索引实现原理分析" class="headerlink" title="MySQL 索引实现原理分析"></a>MySQL 索引实现原理分析</h2><p><strong>为什么没有使用 Hash 表的索引格式</strong></p><p>使用类似于 JDK 中 HashMap 的数据结构来存储索引数据，有如下特点：</p><ul><li><p>优点：查询速度快，Hash 数据结构查询时间复杂度为 O(1);</p></li><li><p>缺点：</p><ul><li>1、需要将数据文件 load 到内存，比较耗费内存空间；</li><li>2、Hash 快速查询只适合等值查询，对于范围查询效率低下，在实际工作中范围查询的场景比较多。</li></ul></li></ul><p><strong>为什么没有使用二叉树和红黑树索引格式</strong></p><p>无论是二叉树还是红黑树，都会因为树的深度过深而造成 IO 次数变多，影响数据读取效率。</p><p><strong>为什么没有使用 B 树索引格式</strong></p><p>B 树特点：</p><p>1、所有键值分布在整棵树中；<br>2、搜索有可能在非叶子节点结束，在关键字全集内做一次查找，性能逼近二分查找；<br>3、每个节点最多拥有 m 个子树；<br>4、根节点至少有 2 个子树；<br>5、分支节点至少拥有 m / 2 棵子树（除根节点和叶子节点外都是分支节点）；<br>6、所有叶子节点都在同一层、每个节点最多可以有 m - 1 个 key，并且以升序排列。</p><p>B 树缺点：</p><ul><li><p>每个节点都有 key，同时也包含 data，而每个页存储空间是有限的，如果 data 比较大的话会导致每个节点存储的 key 数量变小；</p></li><li><p>当存储的数据量很大的时候会导致深度较大，增大查询时磁盘 IO 次数，进而影响查询性能。</p></li></ul><img src="https://gitee.com/dongzl/article-images/raw/master/2020/10-The-Implementation-Principles-Of-MySQL-Index/The-Implementation-Principles-Of-MySQL-Index-01.png"><p><strong>MySQL B+ 树索引格式实现原理</strong></p><p>B+ 树是在 B 树的基础上做的一种优化，优化如下：</p><ul><li><p>B+ 树每个节点可以包含更多的节点（非叶子节点不在存储数据），这样做的原因有两个，第一是为了降低树的高度，第二个原因是将数据范围变为多个区间，区间越多，数据检索越快；</p></li><li><p>非叶子节点存储 key ，叶子节点存储 key 和数据；</p></li><li><p>叶子节点两两指针互相连接（符合磁盘的预读特性），顺序查询性能更高。</p></li></ul><p><strong>MySQL InnoDB–B+ 树，叶子节点直接存储数据</strong></p><ul><li><p>InnoDB 是通过 B+ 树结构对主键创建索引，在叶子节点中存储记录数据，如果没有主键，就选择唯一键，如果没有唯一键，那么会生成一个 6 位的 row_id 来作为主键；</p></li><li><p>如果创建索引的键是其他字段，那么在叶子节点中存储的是该记录的主键，然后在通过主键索引找到对应的记录，这个过程叫做回表。</p></li></ul><p><strong>MySQL MyISAM–B+ 树，叶子节点存储表中数据的地址</strong></p><img src="https://gitee.com/dongzl/article-images/raw/master/2020/10-The-Implementation-Principles-Of-MySQL-Index/The-Implementation-Principles-Of-MySQL-Index-02.png"><h2 id="MySQL-索引的一些其他内容"><a href="#MySQL-索引的一些其他内容" class="headerlink" title="MySQL 索引的一些其他内容"></a>MySQL 索引的一些其他内容</h2><h3 id="回表"><a href="#回表" class="headerlink" title="回表"></a>回表</h3><p>如果 MySQL 中的索引不是主键索引，在使用这个索引进行数据查询时，需要现在这个索引的 B+ 树中找到叶子节点存储的主键 ID，然后根据主键 ID 到主键索引的 B+ 树中查找到最终记录，这个过程就叫做回表。</p><h3 id="最左匹配原则"><a href="#最左匹配原则" class="headerlink" title="最左匹配原则"></a>最左匹配原则</h3><p>在创建联合索引时，如果在查询条件中包含索引的最左列，那么这个索引可以匹配到，如果不包含最左列，这个索引无法匹配，这个称做最左原则。</p><p>比如某个表有联合索引，索引字段为 (column1, column2)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a、<span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> column1 = <span class="string">'c1'</span> <span class="keyword">and</span> column2 = <span class="string">'c2'</span>;</span><br><span class="line"></span><br><span class="line">b、<span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> column2 = <span class="string">'c2'</span> <span class="keyword">and</span> column1 = <span class="string">'c1'</span>;</span><br><span class="line"></span><br><span class="line">c、<span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> column1 = <span class="string">'c1'</span>;</span><br><span class="line"></span><br><span class="line">d、<span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> column2 = <span class="string">'c2'</span>;</span><br></pre></td></tr></table></figure><p>上述 a、b、c 三个查询可以使用该索引，查询 d 无法使用该索引。</p><p>知识补充，如果上述四条SQL语句都希望走索引，需要创建两个索引：</p><p>组合索引: (column1, column2), 和 column2 单列索引；</p><p>或者是组合索引: (column2, column1), 和 column1 单列索引；</p><p>具体选择哪种方案，需要对比 column1、column2 字段类型，在满足查询优化情况尽量减少磁盘空间占用。</p><p>PS.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 范围查询只能用到 column2 列上索引，column2 上用不到</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> column1 &gt; <span class="string">'c1'</span> <span class="keyword">and</span> column2 = <span class="string">'c2'</span>;</span><br></pre></td></tr></table></figure><h3 id="索引覆盖"><a href="#索引覆盖" class="headerlink" title="索引覆盖"></a>索引覆盖</h3><p>如果索引中包含查询结果需要的全部字段，那么将不需要在回表查询该记录的所有数据，这个过程就是索引覆盖，覆盖索引在查询计划中表现为：<code>using index</code>。</p><h3 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h3><p>例如有 user_table 表，表上有 (user_name, age) 联合索引<br>如果现在有一个需求，查出名称中以“张”开头且年龄小于等于 10 的用户信息：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> user_table <span class="keyword">where</span> user_name <span class="keyword">like</span> <span class="string">'张%'</span> <span class="keyword">and</span> age &gt; <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>这条查询语句有两种执行可能：</p><ul><li><p>根据 (user_name, age) 联合索引查询所有满足名称以“张”开头的索引，然后回表查询出相应的全行数据，然后再筛选出满足年龄小于等于10的用户数据。</p></li><li><p>根据 (user_name, age) 联合索引查询所有满足名称以“张”开头的索引，然后直接再筛选出年龄小于等于10的索引，之后再回表查询全行数据。</p></li></ul><p>很明显，后一种方式需要回表查询的全行数据比较少，这就是 MySQL 的索引下推。</p><h3 id="聚簇索引与费聚簇索引"><a href="#聚簇索引与费聚簇索引" class="headerlink" title="聚簇索引与费聚簇索引"></a>聚簇索引与费聚簇索引</h3><p>聚簇索引并不是一种索引类型，而是一种数据存储方式，指的是数据行跟相邻的键值紧凑的存储在一起。费聚簇索引是指数据文件和索引文件分开存放。</p><p>MySQL 数据库中 InnoDB 存储引擎，B+ 树索引可以分为聚簇索引（也称聚集索引，clustered index）和辅助索引（有时也称非聚簇索引或二级索引，secondary index，non-clustered index）。这两种索引内部都是B+树，聚集索引的叶子节点存放着一整行的数据。</p><p>InnoDB 中的主键索引是一种聚簇索引，非聚簇索引都是辅助索引，像复合索引、前缀索引、唯一索引。</p><p>InnoDB 使用的是聚簇索引，MyISAM 使用的是非聚簇索引。</p><p><strong>聚簇索引的优缺点</strong>：</p><p>优点：</p><ul><li><p>数据访问更快，因为聚簇索引将索引和数据保存在同一个B+树中，因此从聚簇索引中获取数据比非聚簇索引更快；</p></li><li><p>聚簇索引对于主键的排序查找和范围查找速度非常快。</p></li></ul><p>缺点：</p><ul><li><p>插入速度严重依赖于插入顺序，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个自增的ID列为主键</p></li><li><p>更新主键的代价很高，因为将会导致被更新的行移动。因此，对于 InnoDB 表，我们一般定义主键为不可更新。</p></li><li><p>二级索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据。</p></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.jianshu.com/p/bdc9e57ccf8b" target="_blank" rel="noopener">MySQL 索引篇之覆盖索引、联合索引、索引下推</a></li><li><a href="https://blog.csdn.net/mccand1234/article/details/95799942" target="_blank" rel="noopener">索引下推（5.6版本+）</a></li><li><a href="https://zhenganwen.top/posts/433a3305/" target="_blank" rel="noopener">MySQL优化面试</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;面试题&quot;&gt;&lt;a href=&quot;#面试题&quot; class=&quot;headerlink&quot; title=&quot;面试题&quot;&gt;&lt;/a&gt;面试题&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;1、MySQL 数据库索引分类。&lt;br&gt;2、MySQL 数据库 InnoDB 存储引擎的底层数据结构。&lt;b
      
    
    </summary>
    
    
      <category term="数据库" scheme="https://dongzl.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MySQL" scheme="https://dongzl.github.io/tags/MySQL/"/>
    
      <category term="索引" scheme="https://dongzl.github.io/tags/%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 数据库事务 ACID 的实现原理</title>
    <link href="https://dongzl.github.io/2020/03/13/09-The-Implementation-Principles-Of-MySQL-ACID/"/>
    <id>https://dongzl.github.io/2020/03/13/09-The-Implementation-Principles-Of-MySQL-ACID/</id>
    <published>2020-03-13T13:39:26.000Z</published>
    <updated>2020-03-14T11:44:27.951Z</updated>
    
    <content type="html"><![CDATA[<h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><blockquote><p>MySQL 数据库的原子性和持久性怎么保证？</p></blockquote><blockquote><p>技术关键点：通过 undo log 保证原子性；通过 redo log 保证持久性。</p></blockquote><h2 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h2><p>首先介绍一下 MySQL 事务的 ACID 特性：</p><ul><li><p>原子性（Atomicity）：事务中所有操作作为一个整体像原子一样不可分割，要么全部成功，要么全部失败；</p></li><li><p>一致性（Consistency）：事务的执行结果必须使数据从一个一致性状态到另一个一致性状态。一致性状态是指：a. 系统的状态满足数据的完整性约束；b. 系统的状态反映数据库本应描述现实世界的真实状态，比如转账前后两个账户的金额总和应该保持不变；</p></li><li><p>隔离性（Isolation）：并发执行的事务不会互相影响，其对数据库的影响和他们串行执行时一样。比如多个用户同时往一个账户转账，最后账户的结果应该和他们按先后次序转账的结果一样；</p></li><li><p>持久性（Durability）：事务一旦提交，其对数据库的更新就是持久的。任何事务或系统故障都不会导致数据丢失。</p></li></ul><h3 id="事务的特点"><a href="#事务的特点" class="headerlink" title="事务的特点"></a>事务的特点</h3><p>事务的根本追求：数据一致性</p><p>可能会对事务一致性造成破坏的原因：</p><ul><li><p>事务的并发执行</p></li><li><p>事务故障或系统故障</p></li></ul><p>避免事务一致性被破坏的技术手段：</p><ul><li><p>并发控制技术（保证事务隔离性，防止事务并发执行破坏数据的一致性）</p></li><li><p>日志恢复技术（保证事务的原子性和持久性，防止事务故障或系统故障破坏数据一致性）</p></li></ul><img src="https://gitee.com/dongzl/article-images/raw/master/2020/09-The-Implementation-Principles-Of-MySQL-ACID/The-Implementation-Principles-Of-MySQL-ACID_01.png"><h3 id="事务的实现原理"><a href="#事务的实现原理" class="headerlink" title="事务的实现原理"></a>事务的实现原理</h3><ul><li><p>原子性：通过 undo log 来实现</p></li><li><p>持久性：通过 redo log 来实现</p></li><li><p>隔离性：读写锁 + MVCC 来实现</p></li><li><p>一致性：通过 原子性 + 隔离性 + 持久性 来实现</p></li></ul><p><strong>undo log 作用以及实现原理</strong></p><p>作用：保证事务原子性；实现多版本并发控制（MVCC）</p><p>原理：在操作任何数据之前，先将数据备份到 undo log，然后进行数据的修改，如果出现了错误或者 ROLLBACK 回滚事务，可以利用 undo log 中的备份将数据回复到事务开始之前的状态，undo log 是逻辑日志，可以理解为：</p><ul><li>当 delete 一条记录时，undo log 中会记录一条对应的 insert 记录；</li><li>当 insert 一条记录时，undo log 中会记录一条对应的 delete 记录；</li><li>当 update 一条记录时，它记录一条对应相反的 update 记录。</li></ul><p><strong>redo log 作用以及实现原理</strong></p><p>作用：保证事务的持久性</p><p>原理：redo log 记录的是新数据的备份。在事务提交前，只要将 redo log 持久化即可，不需要立即将数据持久化（预写式日志：WAL）。当系统崩溃时，虽然数据没有持久化，但是 redo log 已经持久化。系统可以根据 redo log 的内容，将所有的数据恢复到最新的状态。</p><p><strong>事务的隔离性</strong></p><p>事务具有隔离性，理论上来说事务之间的执行不应该互相影响，其对数据库的影响应该和串行执行时一样。</p><p>然而完全的隔离级别会导致系统并发性能很低，降低对资源的利用率，因此对事务的隔离性要求会放宽，这也会一定程度上造成对数据库一致性要求降低。</p><p>SQL 标准定义的事务的隔离级别：</p><ul><li><p>读未提交（READ UNCOMMITTED）：对事务处理没有任何限制，不推荐</p></li><li><p>读已提交（READ COMMITTED）：Oracle 数据库默认的隔离级别</p></li><li><p>可重复读（REPEATABLE READ）：MySQL 数据库默认隔离级别</p></li><li><p>串行化（SERIALIZABLE）：并发性能最低，不推荐</p></li></ul><p>不同的隔离级别可能导致的并发异常：</p><table><thead><tr><th>事务的隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>读未提交（READ UNCOMMITTED）</td><td>YES</td><td>YES</td><td>YES</td></tr><tr><td>读已提交（READ COMMITTED）</td><td></td><td>YES</td><td>YES</td></tr><tr><td>可重复读（REPEATABLE READ）</td><td></td><td></td><td>YES</td></tr><tr><td>串行化（SERIALIZABLE）</td><td></td><td></td><td></td></tr></tbody></table><p>设置事务的隔离级别操作：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 查看 MySQL 事务是否自动提交</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">session</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'autocommit'</span>;</span><br><span class="line"><span class="keyword">select</span> @@autocommit;</span><br><span class="line"></span><br><span class="line">// MySQL 关闭事务自动提交</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">session</span> autocommit=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">// 查看 MySQL 当前事务隔离级别</span><br><span class="line"><span class="keyword">SELECT</span> @@tx_isolation;</span><br><span class="line"></span><br><span class="line">// 修改 MySQL 事务隔离级别</span><br><span class="line">// 设置read uncommitted级别：</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">session</span> <span class="keyword">transaction</span> <span class="keyword">isolation</span> <span class="keyword">level</span> <span class="keyword">read</span> uncommitted;</span><br><span class="line"></span><br><span class="line">// 设置read committed级别：</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">session</span> <span class="keyword">transaction</span> <span class="keyword">isolation</span> <span class="keyword">level</span> <span class="keyword">read</span> committed;</span><br><span class="line"></span><br><span class="line">// 设置repeatable read级别：</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">session</span> <span class="keyword">transaction</span> <span class="keyword">isolation</span> <span class="keyword">level</span> repeatable <span class="keyword">read</span>;</span><br><span class="line"></span><br><span class="line">// 设置serializable级别：</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">session</span> <span class="keyword">transaction</span> <span class="keyword">isolation</span> <span class="keyword">level</span> <span class="keyword">serializable</span>;</span><br></pre></td></tr></table></figure><p><strong>事务的隔离性实现原理：锁</strong></p><p>MySQL 锁分类：</p><ul><li><p>共享锁（读锁）：数据只能读取，不能更新；</p></li><li><p>排他锁（写锁）：执行写入操作时，其他事务不能读取。</p></li></ul><p>锁粒度：锁定对象的大小就是锁的粒度：记录 / 表。</p><p>基于锁的并发流程控制：</p><ul><li><p>事务根据自己对数据项进行的操作类型申请相应的锁（读申请共享锁，写申请排他锁）</p></li><li><p>申请锁的请求被发送给锁管理器。锁管理器根据当前数据项是否已经有锁以及申请的和持有的锁是否冲突决定是否为该请求授予锁；</p></li><li><p>若锁被授予，则申请锁的事务可以继续执行；若被拒绝，则申请锁的事务将进行等待，知道锁被其他事务释放。</p></li></ul><h2 id="面试题-1"><a href="#面试题-1" class="headerlink" title="面试题"></a>面试题</h2><blockquote><p>MySQL 中 InnoDB 存储引擎和 MyISAM 存储引擎的区别？</p></blockquote><p><a href="https://www.zhihu.com/question/20596402?sort=created" target="_blank" rel="noopener">Mysql 中 MyISAM 和 InnoDB 的区别有哪些？</a></p><table><thead><tr><th>特征</th><th>MyISAM</th><th>InnoDB</th></tr></thead><tbody><tr><td>索引类型</td><td>非聚簇索引</td><td>聚簇索引</td></tr><tr><td>支持事务</td><td>否</td><td>是</td></tr><tr><td>支持表锁</td><td>是</td><td>是</td></tr><tr><td>支持行锁</td><td>否</td><td>是</td></tr><tr><td>支持外键</td><td>否</td><td>是</td></tr><tr><td>支持全文索引</td><td>是</td><td>是（5.6版本后支持）</td></tr><tr><td>适合操作类型</td><td>大量select</td><td>大量 inset/delete/update</td></tr><tr><td>文件组织形式</td><td>.frm / .ibd</td><td>.MYD / .MYI / .frm</td></tr></tbody></table><p><strong>其他区别内容：</strong></p><ul><li><p>MyISAM：.frm文件存储表定义；数据文件的扩展名为.MYD(MYData)；索引文件的扩展名是.MYI (MYIndex)。</p></li><li><p>InnoDB：.frm文件存储表定义；.ibd 文件和 .ibdata 文件：这两种文件都是存放InnoDB 数据的文件，之所以用两种文件来存放 文件：这两种文件都是存放InnoDB 的数据，是因为 文件：这两种文件都是存放InnoDB 的数据存储方式能够通过配置来决定是使用共享表空间存放存储数据，还是用独享表空间存放存储数据。独享表空间存储方式使用 .ibd 文件，并且每个表一个 .ibd 文件；共享表空间存储方式使用 .ibdata 文件，所有表共同使用一个 .ibdata 文件。</p></li><li><p>MyISAM：允许没有任何索引和主键的表存在，索引都是保存行的地址。</p></li><li><p>InnoDB：如果没有设定主键或者非空唯一索引，就会自动生成一个6字节的主键(用户不可见)，数据是主索引的一部分，附加索引保存的是主索引的值。</p></li><li><p>MyISAM： 保存有表的总行数，如果 select count() from table; 会直接取出出该值。</p></li><li><p>InnoDB： 没有保存表的总行数，如果使用 select count(*) from table; 就会遍历整个表，消耗相当大，但是在加了 wehre 条件后，MyISAM 和 InnoDB 处理的方式都一样。</p></li></ul><div class="row">    <embed src="https://gitee.com/dongzl/article-images/raw/master/pdf/这几道mysql题你搞懂了，金三银四涨薪稳了.pdf" width="100%" height="550" type="application/pdf"></div><ul><li><p>参考资料</p></li><li><p><a href="https://www.cnblogs.com/f-ck-need-u/archive/2018/05/08/9010872.html" target="_blank" rel="noopener">详细分析MySQL事务日志(redo log和undo log)</a></p></li><li><p><a href="https://www.zhihu.com/question/20596402?sort=created" target="_blank" rel="noopener">Mysql 中 MyISAM 和 InnoDB 的区别有哪些？</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;面试题&quot;&gt;&lt;a href=&quot;#面试题&quot; class=&quot;headerlink&quot; title=&quot;面试题&quot;&gt;&lt;/a&gt;面试题&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;MySQL 数据库的原子性和持久性怎么保证？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
      
    
    </summary>
    
    
      <category term="数据库" scheme="https://dongzl.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="ACID" scheme="https://dongzl.github.io/tags/ACID/"/>
    
      <category term="MySQL" scheme="https://dongzl.github.io/tags/MySQL/"/>
    
      <category term="Redo log" scheme="https://dongzl.github.io/tags/Redo-log/"/>
    
      <category term="Undo log" scheme="https://dongzl.github.io/tags/Undo-log/"/>
    
  </entry>
  
  <entry>
    <title>论“茴”字的四种写法：一道面试题总结线程间通信的几种方式</title>
    <link href="https://dongzl.github.io/2020/03/07/07-Several-Methods-Of-Communication-Between-Thread/"/>
    <id>https://dongzl.github.io/2020/03/07/07-Several-Methods-Of-Communication-Between-Thread/</id>
    <published>2020-03-07T13:35:58.000Z</published>
    <updated>2020-03-09T13:32:28.199Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景描述"><a href="#背景描述" class="headerlink" title="背景描述"></a>背景描述</h2><blockquote><p>用两个线程，一个输出字母，一个输出数字，交替输出：1A2B3C4D5E…26Z。</p></blockquote><img src="https://gitee.com/dongzl/article-images/raw/master/2020/07-Several-Methods-Of-Communication-Between-Thread/Several-Methods-Of-Communication-Between-Thread.png"><p>这是一道典型的线程间通信的面试题，两个线程交替<strong>运行-暂停</strong>，并且当一个线程运行后需要暂停，同时要通知另外一个线程运行；另外一个线程得到通知后开始运行，运行后暂停并通知对方线程运行，彼此交替运行，直至打印完整结果。对于这个问题有很多中解法，下面我们就一一分析这些方法。</p><a id="more"></a><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="LockSupport-类实现"><a href="#LockSupport-类实现" class="headerlink" title="LockSupport 类实现"></a>LockSupport 类实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.LockSupport;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockSupportDemo</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Thread t1, t2;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] digit = <span class="keyword">new</span> String[]&#123;<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"5"</span>, <span class="string">"6"</span>, <span class="string">"7"</span>, <span class="string">"8"</span>, <span class="string">"9"</span>, <span class="string">"10"</span>&#125;;</span><br><span class="line">        String[] alphabet = <span class="keyword">new</span> String[]&#123;<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>, <span class="string">"E"</span>, <span class="string">"F"</span>, <span class="string">"G"</span>, <span class="string">"H"</span>, <span class="string">"I"</span>, <span class="string">"J"</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (String d : digit) &#123;</span><br><span class="line">                    System.out.println(d);</span><br><span class="line">                    LockSupport.unpark(t2);</span><br><span class="line">                    LockSupport.park(t1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t1"</span>);</span><br><span class="line">        </span><br><span class="line">        t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (String a : alphabet) &#123;</span><br><span class="line">                    LockSupport.park(t2);</span><br><span class="line">                    System.out.println(a);</span><br><span class="line">                    LockSupport.unpark(t1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t2"</span>);</span><br><span class="line">        </span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>LockSupport</code> 中的 <code>park</code> 和 <code>unpark</code> 可以实现线程的阻塞与唤醒。</p><ul><li><p><code>park</code>: Disables the current thread for thread scheduling purposes unless the permit is available.</p></li><li><p><code>unpark</code>: Makes available the permit for the given thread, if it was not already available.</p></li></ul><h3 id="while-循环-volatile-变量实现"><a href="#while-循环-volatile-变量实现" class="headerlink" title="while 循环 + volatile 变量实现"></a>while 循环 + volatile 变量实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WhileCycleDemo</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">enum</span> RunThreadEnum &#123;T1, T2&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> RunThreadEnum run = RunThreadEnum.T1;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] digit = <span class="keyword">new</span> String[]&#123;<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"5"</span>, <span class="string">"6"</span>, <span class="string">"7"</span>, <span class="string">"8"</span>, <span class="string">"9"</span>, <span class="string">"10"</span>&#125;;</span><br><span class="line">        String[] alphabet = <span class="keyword">new</span> String[]&#123;<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>, <span class="string">"E"</span>, <span class="string">"F"</span>, <span class="string">"G"</span>, <span class="string">"H"</span>, <span class="string">"I"</span>, <span class="string">"J"</span>&#125;;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (String d : digit) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (run != RunThreadEnum.T1) &#123;&#125;</span><br><span class="line">                    System.out.println(d);</span><br><span class="line">                    run = RunThreadEnum.T2;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t1"</span>).start();</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (String a : alphabet) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (run != RunThreadEnum.T2) &#123;&#125;</span><br><span class="line">                    System.out.println(a);</span><br><span class="line">                    run = RunThreadEnum.T1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 <code>while 循环 + volatile 变量</code> 这种实现方案，程序并不难理解，通过交替设置某个变量值的方式实现效果，不过这种方式实现需要注意一点就是 <code>run</code> 变量一定要使用 <code>volatile</code> 关键字修饰，保证变量的内存可见性。</p><h3 id="AtomicBoolean-类实现"><a href="#AtomicBoolean-类实现" class="headerlink" title="AtomicBoolean 类实现"></a>AtomicBoolean 类实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicBoolean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicBooleanDemo</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> AtomicBoolean run = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] digit = <span class="keyword">new</span> String[]&#123;<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"5"</span>, <span class="string">"6"</span>, <span class="string">"7"</span>, <span class="string">"8"</span>, <span class="string">"9"</span>, <span class="string">"10"</span>&#125;;</span><br><span class="line">        String[] alphabet = <span class="keyword">new</span> String[]&#123;<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>, <span class="string">"E"</span>, <span class="string">"F"</span>, <span class="string">"G"</span>, <span class="string">"H"</span>, <span class="string">"I"</span>, <span class="string">"J"</span>&#125;;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (String d : digit) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (run.get()) &#123;&#125;</span><br><span class="line">                    System.out.println(d);</span><br><span class="line">                    run.set(<span class="keyword">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t1"</span>).start();</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (String a : alphabet) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (!run.get()) &#123;&#125;</span><br><span class="line">                    System.out.println(a);</span><br><span class="line">                    run.set(<span class="keyword">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>AtomicBoolean</code> 类实现也比较好理解，主要是借助内部API实现来保证变量在线程之间的可见性。</p><h3 id="BlockingQueue-阻塞队列实现"><a href="#BlockingQueue-阻塞队列实现" class="headerlink" title="BlockingQueue 阻塞队列实现"></a>BlockingQueue 阻塞队列实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockingQueueDemo</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> BlockingQueue&lt;String&gt; queue1 = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">static</span> BlockingQueue&lt;String&gt; queue2 = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] digit = <span class="keyword">new</span> String[]&#123;<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"5"</span>, <span class="string">"6"</span>, <span class="string">"7"</span>, <span class="string">"8"</span>, <span class="string">"9"</span>, <span class="string">"10"</span>&#125;;</span><br><span class="line">        String[] alphabet = <span class="keyword">new</span> String[]&#123;<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>, <span class="string">"E"</span>, <span class="string">"F"</span>, <span class="string">"G"</span>, <span class="string">"H"</span>, <span class="string">"I"</span>, <span class="string">"J"</span>&#125;;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (String d : digit) &#123;</span><br><span class="line">                    System.out.println(d);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        queue1.put(<span class="string">"ok"</span>);</span><br><span class="line">                        queue2.take();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t1"</span>).start();</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (String a : alphabet) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        queue1.take();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(a);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        queue2.put(<span class="string">"ok"</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>借助 <code>BlockingQueue</code> 类实现，主要是借助阻塞队列的阻塞特性，当队列为空时，调用阻塞队列的 <code>take</code> 方法，会阻塞当前线程的执行，直到队列不为空后唤醒当前线程继续执行。</p><h3 id="PipedInputStream-amp-PipedOutputStream-实现"><a href="#PipedInputStream-amp-PipedOutputStream-实现" class="headerlink" title="PipedInputStream &amp; PipedOutputStream 实现"></a>PipedInputStream &amp; PipedOutputStream 实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PipedInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.PipedOutputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PipedStreamDemo</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String[] digit = <span class="keyword">new</span> String[]&#123;<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"5"</span>, <span class="string">"6"</span>, <span class="string">"7"</span>, <span class="string">"8"</span>, <span class="string">"9"</span>, <span class="string">"10"</span>&#125;;</span><br><span class="line">        String[] alphabet = <span class="keyword">new</span> String[]&#123;<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>, <span class="string">"E"</span>, <span class="string">"F"</span>, <span class="string">"G"</span>, <span class="string">"H"</span>, <span class="string">"I"</span>, <span class="string">"J"</span>&#125;;</span><br><span class="line">    </span><br><span class="line">        PipedInputStream input1 = <span class="keyword">new</span> PipedInputStream();</span><br><span class="line">        PipedInputStream input2 = <span class="keyword">new</span> PipedInputStream();</span><br><span class="line">        PipedOutputStream output1 = <span class="keyword">new</span> PipedOutputStream();</span><br><span class="line">        PipedOutputStream output2 = <span class="keyword">new</span> PipedOutputStream();</span><br><span class="line">        </span><br><span class="line">        input1.connect(output2);</span><br><span class="line">        input2.connect(output1);</span><br><span class="line">        </span><br><span class="line">        String msg = <span class="string">"exchange"</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">8</span>];</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (String d : digit) &#123;</span><br><span class="line">                        System.out.println(d);</span><br><span class="line">                        output1.write(msg.getBytes());</span><br><span class="line">                        input1.read(buffer);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t1"</span>).start();</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">8</span>];</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (String a : alphabet) &#123;</span><br><span class="line">                        input2.read(buffer);</span><br><span class="line">                        System.out.println(a);</span><br><span class="line">                        output2.write(msg.getBytes());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种事借助了 <code>java.io</code> 包中的 <code>PipedInputStream &amp; PipedOutputStream</code> 来实现，这两个类在实际中真是没有使用过，而且从程序运行效果来看，上述代码执行效率非常之低，其实这种实现方案只是一个凑数，开脑洞的方案。</p><h3 id="synchronized-wait-notifyAll-实现"><a href="#synchronized-wait-notifyAll-实现" class="headerlink" title="synchronized + wait() + notifyAll() 实现"></a>synchronized + wait() + notifyAll() 实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitNotifyDemo</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        Object o = <span class="keyword">new</span> Object();</span><br><span class="line">        </span><br><span class="line">        String[] digit = <span class="keyword">new</span> String[]&#123;<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"5"</span>, <span class="string">"6"</span>, <span class="string">"7"</span>, <span class="string">"8"</span>, <span class="string">"9"</span>, <span class="string">"10"</span>&#125;;</span><br><span class="line">        String[] alphabet = <span class="keyword">new</span> String[]&#123;<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>, <span class="string">"E"</span>, <span class="string">"F"</span>, <span class="string">"G"</span>, <span class="string">"H"</span>, <span class="string">"I"</span>, <span class="string">"J"</span>&#125;;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (o) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (String d : digit) &#123;</span><br><span class="line">                        System.out.println(d);</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            o.notifyAll();</span><br><span class="line">                            o.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    o.notifyAll(); <span class="comment">//一定再调用一次，否则程序无法退出执行</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t1"</span>).start();</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (o) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (String a : alphabet) &#123;</span><br><span class="line">                        System.out.println(a);</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            o.notifyAll();</span><br><span class="line">                            o.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    o.notifyAll();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 <code>Object</code> 类中 <code>wait()</code> &amp; <code>notifyAll()</code> 方法使用，也可以达到交替打印的效果。其中 <code>wait()</code> 方法作用是使当前线程阻塞，释放资源对象 o，<code>notifyAll()</code> 方法作用是唤醒正在等待资源对象 o 的线程，使其继续向下执行。这里需要注意一点是在循环打印输出之后，一定要再次调用<code>notifyAll()</code> 方法，因为两个线程交替<strong>执行-等待</strong>，最后一定会有一个线程处于等待状态，如果不最后再调用一次<code>notifyAll()</code> 方法，那么一定会有一个线程无法退出执行，程序也就无法终止。</p><p>PS. 这里还有一点需要注意就是上述程序无法控制<strong>数字和字母输出先后顺序，也行是数字先输出，也许是字母先输出</strong>，因为线程两断代码完全一致，执行先后顺序无法确定，这个问题我们可以借助 <code>CountDownLatch</code> 工具类或者通过一个标志变量来处理，程序如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitNotifyDemo</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        Object o = <span class="keyword">new</span> Object();</span><br><span class="line">    </span><br><span class="line">        CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        String[] digit = <span class="keyword">new</span> String[]&#123;<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"5"</span>, <span class="string">"6"</span>, <span class="string">"7"</span>, <span class="string">"8"</span>, <span class="string">"9"</span>, <span class="string">"10"</span>&#125;;</span><br><span class="line">        String[] alphabet = <span class="keyword">new</span> String[]&#123;<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>, <span class="string">"E"</span>, <span class="string">"F"</span>, <span class="string">"G"</span>, <span class="string">"H"</span>, <span class="string">"I"</span>, <span class="string">"J"</span>&#125;;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">//latch.await(); //借助 CountDownLatch 工具解决先后顺序问题(需要处理异常)</span></span><br><span class="line">                <span class="keyword">synchronized</span> (o) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (!flag) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            o.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">for</span> (String d : digit) &#123;</span><br><span class="line">                        System.out.println(d);</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            o.notifyAll();</span><br><span class="line">                            o.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    o.notifyAll(); <span class="comment">//一定再调用一次，否则程序无法退出执行</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t1"</span>).start();</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (o) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (String a : alphabet) &#123;</span><br><span class="line">                        System.out.println(a);</span><br><span class="line">                        <span class="comment">//latch.countDown();</span></span><br><span class="line">                        flag = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            o.notifyAll();</span><br><span class="line">                            o.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    o.notifyAll();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Lock-Condition-实现"><a href="#Lock-Condition-实现" class="headerlink" title="Lock + Condition 实现"></a>Lock + Condition 实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockConditionDemo</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        String[] digit = <span class="keyword">new</span> String[]&#123;<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"5"</span>, <span class="string">"6"</span>, <span class="string">"7"</span>, <span class="string">"8"</span>, <span class="string">"9"</span>, <span class="string">"10"</span>&#125;;</span><br><span class="line">        String[] alphabet = <span class="keyword">new</span> String[]&#123;<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>, <span class="string">"E"</span>, <span class="string">"F"</span>, <span class="string">"G"</span>, <span class="string">"H"</span>, <span class="string">"I"</span>, <span class="string">"J"</span>&#125;;</span><br><span class="line">    </span><br><span class="line">        Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        Condition condition1 = lock.newCondition();</span><br><span class="line">        Condition condition2 = lock.newCondition();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    lock.lock();</span><br><span class="line">                    <span class="keyword">for</span> (String d : digit) &#123;</span><br><span class="line">                        System.out.println(d);</span><br><span class="line">                        condition2.signalAll();</span><br><span class="line">                        condition1.await();</span><br><span class="line">                    &#125;</span><br><span class="line">                    condition2.signalAll(); <span class="comment">// 需要调用一次，否则程序无法终止</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t1"</span>).start();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    lock.lock();</span><br><span class="line">                    <span class="keyword">for</span> (String a : alphabet) &#123;</span><br><span class="line">                        System.out.println(a);</span><br><span class="line">                        condition1.signalAll();</span><br><span class="line">                        condition2.await();</span><br><span class="line">                    &#125;</span><br><span class="line">                    condition1.signalAll();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Lock + Condition</code> 实现方案与 <code>synchronized + wait() + notifyAll()</code>实现方案非常类似，包括使用的API都存在相似的对应关系：</p><ul><li>synchronized 关键字 VS Lock 类</li><li>Condition.await() VS Object.wait()</li><li>Condition.signalAll() VS Object.notifyAll()</li></ul><p>包括需要注意的问题，在使用 <code>Lock + Condition</code> 时我们也需要在循环执行最后在调用一次 <code>signalAll()</code> 方法，否则程序无法终止运行。</p><h2 id="最后总结"><a href="#最后总结" class="headerlink" title="最后总结"></a>最后总结</h2><p>对于这道面试题，主要还是考察线程之间通信问题，主要的考点应该是在<code>synchronized + wait() + notifyAll()</code> 的使用上，当然对于其他实现方案，比较好的是：</p><ul><li>Lock + Condition 实现</li><li>LockSupport 类实现</li></ul><p>对于其它的方案，有的是使用了一些编程技巧，有的是利用 JDK 中现有类的一些实现，并不是重点考察方向，像 <code>PipedInputStream &amp; PipedOutputStream</code> 的实现方案，虽然可以达到效果，其实有些充数的嫌疑，如果有面试官硬扣这种实现，就有点像鲁迅笔下的孔乙己先生在和你讨论“茴”字有几种写法的味道了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景描述&quot;&gt;&lt;a href=&quot;#背景描述&quot; class=&quot;headerlink&quot; title=&quot;背景描述&quot;&gt;&lt;/a&gt;背景描述&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;用两个线程，一个输出字母，一个输出数字，交替输出：1A2B3C4D5E…26Z。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;img src=&quot;https://gitee.com/dongzl/article-images/raw/master/2020/07-Several-Methods-Of-Communication-Between-Thread/Several-Methods-Of-Communication-Between-Thread.png&quot;&gt;

&lt;p&gt;这是一道典型的线程间通信的面试题，两个线程交替&lt;strong&gt;运行-暂停&lt;/strong&gt;，并且当一个线程运行后需要暂停，同时要通知另外一个线程运行；另外一个线程得到通知后开始运行，运行后暂停并通知对方线程运行，彼此交替运行，直至打印完整结果。对于这个问题有很多中解法，下面我们就一一分析这些方法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java开发" scheme="https://dongzl.github.io/categories/java%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Thread" scheme="https://dongzl.github.io/tags/Thread/"/>
    
      <category term="Lock" scheme="https://dongzl.github.io/tags/Lock/"/>
    
      <category term="synchronized" scheme="https://dongzl.github.io/tags/synchronized/"/>
    
  </entry>
  
  <entry>
    <title>极客时间 《数据结构与算法之美》 学习笔记</title>
    <link href="https://dongzl.github.io/2020/03/05/06-The-Beauty-Of-Data-Structures-And-Algorithms/"/>
    <id>https://dongzl.github.io/2020/03/05/06-The-Beauty-Of-Data-Structures-And-Algorithms/</id>
    <published>2020-03-05T01:36:44.000Z</published>
    <updated>2020-03-09T14:18:41.064Z</updated>
    
    <content type="html"><![CDATA[<p>本文是 <a href="https://time.geekbang.org/" target="_blank" rel="noopener">极客时间</a> 上 <a href="https://time.geekbang.org/column/intro/126" target="_blank" rel="noopener">数据结构与算法之美</a> 课程的学习笔记内容。</p><a id="more"></a><h2 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h2><h3 id="10-递归：如何用三行代码找到“最终推荐人”？"><a href="#10-递归：如何用三行代码找到“最终推荐人”？" class="headerlink" title="10 | 递归：如何用三行代码找到“最终推荐人”？"></a>10 | 递归：如何用三行代码找到“最终推荐人”？</h3><p><strong>递归需要满足的三个条件</strong>：</p><ul><li>一个问题的解可以分解为几个子问题的解</li><li>这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样</li><li>存在递归终止条件</li></ul><p><font color="red">写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码</font></p><p><strong>编写递归代码的关键是，只要遇到递归，我们就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤。</strong></p><p><strong>使用递归可能需要规避的问题</strong>：</p><ul><li>递归代码要警惕堆栈溢出</li><li>递归代码要警惕重复计算</li></ul><p><a href="https://mp.weixin.qq.com/s/Ki3WN2AJ5HhxxmaQ0lVh3Q" target="_blank" rel="noopener">还有程序员天真地以为”尾递归“真的可以避免堆栈溢出！</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是 &lt;a href=&quot;https://time.geekbang.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;极客时间&lt;/a&gt; 上 &lt;a href=&quot;https://time.geekbang.org/column/intro/126&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;数据结构与算法之美&lt;/a&gt; 课程的学习笔记内容。&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://dongzl.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="https://dongzl.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="https://dongzl.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>聊聊代理模式（Proxy）的使用</title>
    <link href="https://dongzl.github.io/2020/02/29/05-Design-Pattern-Proxy/"/>
    <id>https://dongzl.github.io/2020/02/29/05-Design-Pattern-Proxy/</id>
    <published>2020-02-29T06:44:21.000Z</published>
    <updated>2020-03-09T13:35:42.159Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>最近在学习 <a href="https://time.geekbang.org/" target="_blank" rel="noopener">极客时间</a> 的 <a href="https://time.geekbang.org/column/intro/250" target="_blank" rel="noopener">设计模式之美</a> 课程，这一篇算是自己的学习总结。代理模式（Proxy）在很多非常优秀框架中都有他的身影，比如，大名鼎鼎的 Spring AOP 就是使用动态代理（Dynamic Proxy）模式；还有就是在一些微服务框架中，如果调用一个远程服务接口，RPC 框架一般都会使用代理模式。</p><a id="more"></a><h2 id="代理模式介绍"><a href="#代理模式介绍" class="headerlink" title="代理模式介绍"></a>代理模式介绍</h2><p><strong>代理模式定义</strong></p><p><strong>Proxy Pattern</strong>: Provide a surrogate or placeholder for another object to control access to it.（为其他对象提供一种代理以控制对这个对象的访问。）</p><img src="https://gitee.com/dongzl/article-images/raw/master/2020/05-Design-Pattern-Proxy/Design-Pattern-Proxy_01.png" width="600px"><ul><li>Subject：定义 RealSubject 对外的接口，且这些接口必须被 Proxy 实现，这样外部调用 proxy 的接口最终都被转化为对 RealSubject 的调用。</li><li>RealSubject：真正的目标对象（被代理对象）。</li><li>Proxy：目标对象的代理，负责控制和管理目标对象，并间接地传递外部对目标对象的访问。</li></ul><h2 id="静态代理实现"><a href="#静态代理实现" class="headerlink" title="静态代理实现"></a>静态代理实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticProxy</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> ProxyExecute(<span class="keyword">new</span> RemoteExecute()).execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Executable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RemoteExecute</span> <span class="keyword">implements</span> <span class="title">Executable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">        System.out.println(<span class="string">"Remote execute ......"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProxyExecute</span> <span class="keyword">implements</span> <span class="title">Executable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Executable executable;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxyExecute</span><span class="params">(Executable executable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.executable = executable;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        executable.execute();</span><br><span class="line">        System.out.println(<span class="string">"Time: "</span> + (System.currentTimeMillis() - start));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码就是静态代理个一个简单实现，由于在静态代理模式中 Proxy 只能代理固定实现某个接口的被代理对象，所以并不十分灵活，所以在这个静态代理的基础上就衍生出了动态代理（Dynamic Proxy）。</p><h2 id="JDK-动态代理实现"><a href="#JDK-动态代理实现" class="headerlink" title="JDK 动态代理实现"></a>JDK 动态代理实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDKDynamicProxy</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Executable remote = <span class="keyword">new</span> RemoteExecute();</span><br><span class="line">        </span><br><span class="line">        System.getProperties().setProperty(<span class="string">"sun.misc.ProxyGenerator.saveGeneratedFiles"</span>, <span class="string">"true"</span>);</span><br><span class="line">        </span><br><span class="line">        Executable executable = (Executable)Proxy.newProxyInstance(JDKDynamicProxy.class.getClassLoader(), <span class="keyword">new</span> Class[]&#123;Executable.class&#125;, <span class="keyword">new</span> ExecuteInvocationHandler(remote));</span><br><span class="line">        executable.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExecuteInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Executable executable;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExecuteInvocationHandler</span><span class="params">(Executable executable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.executable = executable;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        Object result = method.invoke(executable, args);</span><br><span class="line">        System.out.println(<span class="string">"Time: "</span> + (System.currentTimeMillis() - start));</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Executable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RemoteExecute</span> <span class="keyword">implements</span> <span class="title">Executable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">        System.out.println(<span class="string">"Remote execute ......"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JDK 的动态代理是通过 Proxy 类来实现的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</span> </span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> IllegalArgumentException</span></span><br></pre></td></tr></table></figure><p>newProxyInstance 方法需要三个参数，</p><ul><li>loader 是生成代理类的类加载器；</li><li>interfaces 指定被代理类实现的接口（所以很多资料都说 JDK 的动态代理需要被代理类必须实现某一个接口，其实证据就在这里）；</li><li>h 调用处理器（实现 InvocationHandler 接口，InvocationHandler 接口中定义了 invoke 方法）。</li></ul><p>通过设置 JDK 属性，我们可以将动态代理过程中生成的代理类保存下来，观察 JDK 动态生成的代理类的一些实现细节：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.getProperties().setProperty(<span class="string">"sun.misc.ProxyGenerator.saveGeneratedFiles"</span>, <span class="string">"true"</span>);</span><br></pre></td></tr></table></figure><p>PS. <strong>这个属性值在不同 JDK 版本名称不同，JDK8 中为 <code>sun.misc.ProxyGenerator.saveGeneratedFiles</code>，JDK12 中是 <code>jdk.proxy.ProxyGenerator.saveGeneratedFiles</code>，没有深究是从 JDK 哪个版本改的这个属性名。</strong></p><p>通过设置这个参数，在程序运行后会生成一个 <code>$Proxy0.class</code> 文件，我们通过工具反编译文件后内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Source code recreated from a .class file by IntelliJ IDEA</span></span><br><span class="line"><span class="comment">// (powered by Fernflower decompiler)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> design.pattern.proxy.v2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.UndeclaredThrowableException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> $<span class="title">Proxy0</span> <span class="keyword">extends</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Executable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> $Proxy0(InvocationHandler var1) <span class="keyword">throws</span>  &#123;</span><br><span class="line">        <span class="keyword">super</span>(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略 equals 方法</span></span><br><span class="line">    <span class="comment">// 省略 toString 方法</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m3, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略 hashCode 方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            m1 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"equals"</span>, Class.forName(<span class="string">"java.lang.Object"</span>));</span><br><span class="line">            m2 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"toString"</span>);</span><br><span class="line">            m3 = Class.forName(<span class="string">"design.pattern.proxy.v2.Executable"</span>).getMethod(<span class="string">"execute"</span>);</span><br><span class="line">            m0 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"hashCode"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodError(var2.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoClassDefFoundError(var3.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过类的结构我们可以知道动态生成代理类 <code>$Proxy0</code> 继承自 <code>Proxy</code> 类，同时实现了我们自定义的 <code>Executable</code> 接口，并重写了其中的 <code>execute</code> 方法，<code>execute</code> 方法实现很简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m3, (Object[])<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p>调用父类中 <code>h</code> 变量的 <code>invoke</code> 方法，其中 <code>h</code> 变量就是我们实现的 <code>InvocationHandler</code> 接口的 <code>ExecuteInvocationHandler</code> 类变量。</p><p>JDK 动态代理实现流程图：</p><img src="https://gitee.com/dongzl/article-images/raw/master/2020/05-Design-Pattern-Proxy/Design-Pattern-Proxy_02.png"><h2 id="cglib-动态代理"><a href="#cglib-动态代理" class="headerlink" title="cglib 动态代理"></a>cglib 动态代理</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CGlibDynamicProxy</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setSuperclass(RemoteExecute.class);</span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> ExecuteMethodInterceptor());</span><br><span class="line">        RemoteExecute execute = (RemoteExecute)enhancer.create();</span><br><span class="line">        execute.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExecuteMethodInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(o.getClass().getSuperclass().getName());</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        Object result = methodProxy.invokeSuper(o, objects);</span><br><span class="line">        System.out.println(<span class="string">"Time: "</span> + (System.currentTimeMillis() - start));</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RemoteExecute</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">        System.out.println(<span class="string">"Remote execute ......"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>cglib 实现的动态代理功能使用的是 <code>Enhancer</code> 类，其中需要定义 <code>MethodInterceptor</code> 接口实现类，<code>MethodInterceptor</code> 接口与 JDK 动态代理中的 InvocationHandler 接口作用非常类型，内部通过反射调用被代理类的方法。</p><p><code>cglib</code> 动态代理一个比较的的优势是被代理类（RemoteExecute）不需要实现任何接口，这个就是很多资料上说的 <code>cglib</code> 动态代理与 <code>JDK</code> 动态代理的一个很大区别就是：<strong>cglib 动态代理不需要被代理类实现任何接口，而 JDK 动态代理需要被代理类必须要实现一个接口。</strong> 由于 <code>cglib</code> 动态代理的这个优势，所以 <code>Spring AOP</code> 的动态代理就是通过 <code>cglib</code> 来实现的。</p><h2 id="代理模式使用总结"><a href="#代理模式使用总结" class="headerlink" title="代理模式使用总结"></a>代理模式使用总结</h2><p>代理模式的目的：</p><ul><li>为外部调用者提供一个访问服务提供者的代理对象。</li></ul><p>代理模式的动机：</p><ul><li>限制对目标对象的直接访问，降低耦合度。</li></ul><p>代理模式优点：</p><ul><li>低耦合（协调调用者和被调用者）</li><li>易扩展</li><li>灵活度高</li></ul><p>代理模式缺点：</p><ul><li>间接访问可能会延迟请求相应</li><li>增加工作量</li></ul><p>代理模式分类：</p><ul><li>静态代理</li><li>动态代理</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><p><a href="https://www.cnblogs.com/yssjun/archive/2019/05/31/10889022.html" target="_blank" rel="noopener">设计模式之代理模式（proxy pattern）</a></p></li><li><p><a href="https://www.cnblogs.com/liuyun1995/p/8144628.html" target="_blank" rel="noopener">JDK动态代理</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景介绍&quot;&gt;&lt;a href=&quot;#背景介绍&quot; class=&quot;headerlink&quot; title=&quot;背景介绍&quot;&gt;&lt;/a&gt;背景介绍&lt;/h2&gt;&lt;p&gt;最近在学习 &lt;a href=&quot;https://time.geekbang.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;极客时间&lt;/a&gt; 的 &lt;a href=&quot;https://time.geekbang.org/column/intro/250&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;设计模式之美&lt;/a&gt; 课程，这一篇算是自己的学习总结。代理模式（Proxy）在很多非常优秀框架中都有他的身影，比如，大名鼎鼎的 Spring AOP 就是使用动态代理（Dynamic Proxy）模式；还有就是在一些微服务框架中，如果调用一个远程服务接口，RPC 框架一般都会使用代理模式。&lt;/p&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="https://dongzl.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://dongzl.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="代理模式" scheme="https://dongzl.github.io/tags/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Proxy" scheme="https://dongzl.github.io/tags/Proxy/"/>
    
  </entry>
  
  <entry>
    <title>极客时间 《深入浅出计算机组成原理》 学习笔记</title>
    <link href="https://dongzl.github.io/2020/02/21/04-On-The-Principle-Of-Computer-Composition/"/>
    <id>https://dongzl.github.io/2020/02/21/04-On-The-Principle-Of-Computer-Composition/</id>
    <published>2020-02-21T12:54:33.000Z</published>
    <updated>2020-03-10T02:25:46.323Z</updated>
    
    <content type="html"><![CDATA[<p>本文是 <a href="https://time.geekbang.org/" target="_blank" rel="noopener">极客时间</a> 上 <a href="https://time.geekbang.org/column/intro/170" target="_blank" rel="noopener">深入浅出计算机组成原理</a> 课程的学习笔记内容。</p><a id="more"></a><h2 id="入门篇"><a href="#入门篇" class="headerlink" title="入门篇"></a>入门篇</h2><h3 id><a href="#" class="headerlink" title></a></h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是 &lt;a href=&quot;https://time.geekbang.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;极客时间&lt;/a&gt; 上 &lt;a href=&quot;https://time.geekbang.org/column/intro/170&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;深入浅出计算机组成原理&lt;/a&gt; 课程的学习笔记内容。&lt;/p&gt;
    
    </summary>
    
    
      <category term="其他" scheme="https://dongzl.github.io/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="计算机组成原理" scheme="https://dongzl.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>计算机中常用数学公式汇总</title>
    <link href="https://dongzl.github.io/2020/02/17/03-The-Mathematical-Formula-Summary/"/>
    <id>https://dongzl.github.io/2020/02/17/03-The-Mathematical-Formula-Summary/</id>
    <published>2020-02-17T14:04:54.000Z</published>
    <updated>2020-03-09T14:20:17.388Z</updated>
    
    <content type="html"><![CDATA[<ul><li>斐波那契数列通向公式：</li></ul><p>$$a_n=\frac{1}{\sqrt{5}} \begin{bmatrix} \begin{pmatrix} \frac{1 + \sqrt{5}}{2} \end{pmatrix}^n - \begin{pmatrix} \frac{1 - \sqrt{5}}{2} \end{pmatrix}^n\end{bmatrix}$$</p><ul><li>斐波那契数列矩阵方程：</li></ul><p>$$\begin{bmatrix} f(n)\\ f(n - 1) \end{bmatrix} = \begin{bmatrix} 1&amp;1\\ 1&amp;0 \end{bmatrix} \begin{bmatrix} f(n - 1)\\ f(n - 2) \end{bmatrix} = \begin{bmatrix} 1&amp;1\\ 1&amp;0 \end{bmatrix}^{n + 1} \begin{bmatrix} f(1)\\ f(0) \end{bmatrix}$$</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;斐波那契数列通向公式：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$$a_n=\frac{1}{\sqrt{5}} \begin{bmatrix} \begin{pmatrix} \frac{1 + \sqrt{5}}{2} \end{pmatrix}^n - \begin{
      
    
    </summary>
    
    
      <category term="其他" scheme="https://dongzl.github.io/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="数学公式" scheme="https://dongzl.github.io/tags/%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>各种算法的复杂度</title>
    <link href="https://dongzl.github.io/2020/02/13/02-Know-Thy-Complexities/"/>
    <id>https://dongzl.github.io/2020/02/13/02-Know-Thy-Complexities/</id>
    <published>2020-02-13T02:17:58.000Z</published>
    <updated>2020-03-09T14:18:35.599Z</updated>
    
    <content type="html"><![CDATA[<p>你好，这个页面涵盖了计算机科学中常用算法的时间和空间复杂度。在准备过去的技术采访中，我自己花了几个小时爬取网页，把搜索、排序算法中最好情况、最坏情况以及平均情况时间复杂度的内容汇总到一起，这样我就不会在被问及这些问题时被难住了。在过去的几年里，我采访了硅谷的几家初创公司，以及一些大公司，例如谷歌、Facebook、雅虎、LinkedIn和Uber，每次我准备采访时，我都会想“为什么没有人创建一个好的大O备忘单呢？”。所以，为了给你们这些好人节省很多时间，我创造了一个。享受吧！</p><a id="more"></a><blockquote><p>Hi there!  This webpage covers the space and time Big-O complexities of common algorithms used in Computer Science.  When preparing for technical interviews in the past, I found myself spending hours crawling the internet putting together the best, average, and worst case complexities for search and sorting algorithms so that I wouldn’t be stumped when asked about them.  Over the last few years, I’ve interviewed at several Silicon Valley startups, and also some bigger companies, like Google, Facebook, Yahoo, LinkedIn, and Uber, and each time that I prepared for an interview, I thought to myself “Why hasn’t someone created a nice Big-O cheat sheet?”.  So, to save all of you fine folks a ton of time, I went ahead and created one.  Enjoy!</p></blockquote><h2 id="大O复杂度统计图"><a href="#大O复杂度统计图" class="headerlink" title="大O复杂度统计图"></a>大O复杂度统计图</h2><p>Big-O Complexity Chart</p><img src="https://gitee.com/dongzl/article-images/raw/master/2020/02-Know-Thy-Complexities/Big-O-Complexity-Chart.png" width="1000px"><h2 id="常用数据结构操作"><a href="#常用数据结构操作" class="headerlink" title="常用数据结构操作"></a>常用数据结构操作</h2><p>Common Data Structure Operations</p><img src="https://gitee.com/dongzl/article-images/raw/master/2020/02-Know-Thy-Complexities/Common-Data-Structure-Operations.png" width="1000px"><h2 id="线性排序算法"><a href="#线性排序算法" class="headerlink" title="线性排序算法"></a>线性排序算法</h2><p>Array Sorting Algorithms</p><img src="https://gitee.com/dongzl/article-images/raw/master/2020/02-Know-Thy-Complexities/Array-Sorting-Algorithms.png" width="1000px"><h2 id="官方网站-Big-O-统计数据图"><a href="#官方网站-Big-O-统计数据图" class="headerlink" title="官方网站 Big-O 统计数据图"></a>官方网站 Big-O 统计数据图</h2><p>Get the Official Big-O Cheat Sheet Poster</p><img src="https://gitee.com/dongzl/article-images/raw/master/2020/02-Know-Thy-Complexities/Big-O-Cheat-Sheet-Poster.png" width="1000px"><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.bigocheatsheet.com/" target="_blank" rel="noopener">Know Thy Complexities!</a></li><li><a href="https://blog.csdn.net/herorenme/article/details/8919095" target="_blank" rel="noopener">Know Thy Complexities! (各种算法的复杂度)</a></li><li><a href="https://www.cnblogs.com/datascientist/p/3557401.html" target="_blank" rel="noopener">Know Thy Complexities!</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;你好，这个页面涵盖了计算机科学中常用算法的时间和空间复杂度。在准备过去的技术采访中，我自己花了几个小时爬取网页，把搜索、排序算法中最好情况、最坏情况以及平均情况时间复杂度的内容汇总到一起，这样我就不会在被问及这些问题时被难住了。在过去的几年里，我采访了硅谷的几家初创公司，以及一些大公司，例如谷歌、Facebook、雅虎、LinkedIn和Uber，每次我准备采访时，我都会想“为什么没有人创建一个好的大O备忘单呢？”。所以，为了给你们这些好人节省很多时间，我创造了一个。享受吧！&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://dongzl.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Big-O" scheme="https://dongzl.github.io/tags/Big-O/"/>
    
  </entry>
  
  <entry>
    <title>Google Guava EventBus 在 ShardingShere 中的应用</title>
    <link href="https://dongzl.github.io/2020/02/01/01-Google-Guava-EventBus-ShardingSphere/"/>
    <id>https://dongzl.github.io/2020/02/01/01-Google-Guava-EventBus-ShardingSphere/</id>
    <published>2020-02-01T10:02:52.000Z</published>
    <updated>2020-03-09T13:37:28.929Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Guava-EventBus-介绍"><a href="#Guava-EventBus-介绍" class="headerlink" title="Guava EventBus 介绍"></a>Guava EventBus 介绍</h2><p>Guava 的 EventBus 可以简化生产/消费模型。EventBus 通过非常简单的方式，实现了观察者模式中的监听注册，事件分发。</p><blockquote><p>Dispatches events to listeners, and provides ways for listeners to register themselves. The EventBus allows publish-subscribe-style communication between components without requiring the components to explicitly register with one another (and thus be aware of each other). It is designed exclusively to replace traditional Java in-processs event distribution using explicit registration. It is not a general-purpose publish-subscribe system, nor is it intended for interprocess communication.</p></blockquote><blockquote><p>将事件分发给监听器，同时提供监听器注册监听的方式。EventBus 支持组件之间的发布-订阅式通信，而不需要组件显式地彼此注册（从而彼此感知对方存在）。它是专门为使用显式注册来替代传统的 Java 进程内事件分发而设计的。它不是一个通用的发布订阅系统，也不支持进程间通信。</p></blockquote><a id="more"></a><img src="https://gitee.com/dongzl/article-images/raw/master/2020/01-Google-Guava-EventBus-ShardingSphere/Google-Guava-EventBus.png" width="600px"><p>通过阅读 Guava 的 EventBus 源码，EventBus 支持的操作如下：</p><ul><li>Receiving Events（接收事件）</li><li>Posting Events （发布事件）</li><li>Subscriber Methods （订阅事件）</li><li>Dead Events （没有订阅者的事件）</li></ul><h2 id="EventBus-发布-订阅使用"><a href="#EventBus-发布-订阅使用" class="headerlink" title="EventBus 发布/订阅使用"></a>EventBus 发布/订阅使用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 订阅者</span></span><br><span class="line"><span class="keyword">import</span> com.google.common.eventbus.Subscribe;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EventHandler</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Subscribe</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mq</span><span class="params">(MQEvent mq)</span> </span>&#123;</span><br><span class="line">        System.out.println(mq.getClass().getCanonicalName() + <span class="string">" work"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 订阅事件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MQEvent</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试类</span></span><br><span class="line"><span class="keyword">import</span> com.google.common.eventbus.EventBus;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EventTest</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//初始化消息总线</span></span><br><span class="line">        EventBus eventBus = <span class="keyword">new</span> EventBus();</span><br><span class="line">        <span class="comment">// 注册订阅者</span></span><br><span class="line">        eventBus.register(<span class="keyword">new</span> EventHandler());</span><br><span class="line">        <span class="comment">//MqEvent推送给订阅者</span></span><br><span class="line">        MQEvent mqEvent = <span class="keyword">new</span> MQEvent();</span><br><span class="line">        <span class="comment">//发布消息</span></span><br><span class="line">        eventBus.post(mqEvent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="EventBus-在-ShardingSphere-中的实际应用"><a href="#EventBus-在-ShardingSphere-中的实际应用" class="headerlink" title="EventBus 在 ShardingSphere 中的实际应用"></a>EventBus 在 ShardingSphere 中的实际应用</h2><p>在 <a href="https://github.com/apache/incubator-shardingsphere" target="_blank" rel="noopener">ShardingSphere</a> 项目中需要将数据库配置信息存储到统一配置中心（例如：ZooKeeper、nacos、Apollo），对于统一的配置中心可以通过监听机制，监听配置中心配置信息的变化，将配置中心变更的信息推送给 ShardingSphere，对于这种情况就是一个典型的发布-订阅模型，在 ShardingSphere 就是通过 EventBus 来完成这个功能的，我们来看一下 ShardingSphere 的代码实现：</p><ul><li><p>系统启动时，通过 ShardingOrchestrationFacade.init() 方法注册监听内容，ConfigurationChangedListenerManager.initListeners() 方法用于启动对于系统配置的监听。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigurationChangedListenerManager</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    ... ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Initialize all configuration changed listeners.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initListeners</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        schemaChangedListener.watch(ChangedType.UPDATED, ChangedType.DELETED);</span><br><span class="line">        propertiesChangedListener.watch(ChangedType.UPDATED);</span><br><span class="line">        authenticationChangedListener.watch(ChangedType.UPDATED);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>例如在 PropertiesChangedListener.watch() 方法中，通过调用父类的 PostShardingConfigCenterEventListener.watch(final ChangedType… watchedChangedTypes) 方法完成监听，在 PostShardingConfigCenterEventListener 方法中使用了 EventBus，注册监听配置中心中某个 Key 的变化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">watch</span><span class="params">(<span class="keyword">final</span> String watchKey, <span class="keyword">final</span> Collection&lt;ChangedType&gt; watchedChangedTypeList)</span> </span>&#123;</span><br><span class="line">    configCenter.watch(watchKey, <span class="keyword">new</span> DataChangedEventListener() &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onChange</span><span class="params">(<span class="keyword">final</span> DataChangedEvent dataChangedEvent)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (watchedChangedTypeList.contains(dataChangedEvent.getChangedType())) &#123;</span><br><span class="line">                eventBus.post(createShardingOrchestrationEvent(dataChangedEvent));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>对于配置中心监听配置信息的变化都是由不同的框架（ZooKeeper、nacos、Apollo）来完成的，下面以 nacos 为例，看一下监听实现，nacos 中配置信息发生变化后对通过 receiveConfigInfo 方法推送给 ShardingShpere，ShardingShpere 接收到变更后通过 EventBus 的 post 方法发送变更事件，订阅事件的类接收到变更后会进行相应逻辑处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">watch</span><span class="params">(<span class="keyword">final</span> String key, <span class="keyword">final</span> DataChangedEventListener dataChangedEventListener)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String dataId = key.replace(<span class="string">"/"</span>, <span class="string">"."</span>);</span><br><span class="line">        String group = properties.getProperty(<span class="string">"group"</span>, <span class="string">"SHARDING_SPHERE_DEFAULT_GROUP"</span>);</span><br><span class="line">        configService.addListener(dataId, group, <span class="keyword">new</span> Listener() &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Executor <span class="title">getExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveConfigInfo</span><span class="params">(<span class="keyword">final</span> String configInfo)</span> </span>&#123;</span><br><span class="line">                dataChangedEventListener.onChange(<span class="keyword">new</span> DataChangedEvent(key, configInfo, DataChangedEvent.ChangedType.UPDATED));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> NacosException ex) &#123;</span><br><span class="line">        log.debug(<span class="string">"Nacos watch key exception for: &#123;&#125;"</span>, ex.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>ShardingSphere 中事件订阅，例如，在 ShardingProxyContext 需要监听配置信息变化，在构造方法中将当前实例对象（this）注册到 EventBus，通过 @Subscribe 注解监听配置变更，监听到配置变更的数据后发送给 ShardingShere，处理内部相关逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ShardingProxyContext</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ShardingProxyContext INSTANCE = <span class="keyword">new</span> ShardingProxyContext();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> ShardingProperties shardingProperties = <span class="keyword">new</span> ShardingProperties(<span class="keyword">new</span> Properties());</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ShardingProxyContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ShardingOrchestrationEventBus.getInstance().register(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ShardingProxyContext <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Renew properties.</span></span><br><span class="line"><span class="comment">     * 监听事件的变化</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> event properties changed event</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Subscribe</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">renew</span><span class="params">(<span class="keyword">final</span> PropertiesChangedEvent event)</span> </span>&#123;</span><br><span class="line">        ConfigurationLogger.log(event.getProps());</span><br><span class="line">        shardingProperties = <span class="keyword">new</span> ShardingProperties(event.getProps());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="DeadEvent-使用场景"><a href="#DeadEvent-使用场景" class="headerlink" title="DeadEvent 使用场景"></a>DeadEvent 使用场景</h2><blockquote><p>Wraps an event that was posted, but which had no subscribers and thus could not be delivered.Registering a DeadEvent subscriber is useful for debugging or logging, as it can detect misconfigurations in a system’s event distribution.</p></blockquote><blockquote><p>包装了一个被发送的事件，但是这个事件却没有任何订阅者，因此这个事件可能不会被实际发送。注册一个 DeadEvent 事件订阅器对于调试或日志记录很有用，因为它可以检测事件分布系统中的错误配置。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义事件，没有订阅者</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MQEvent</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DeadEvent 处理器</span></span><br><span class="line"><span class="keyword">import</span> com.google.common.eventbus.DeadEvent;</span><br><span class="line"><span class="keyword">import</span> com.google.common.eventbus.Subscribe;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadEventHandler</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 没有订阅者时被触发</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Subscribe</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deadEvent</span><span class="params">(DeadEvent event)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Receive a DeadEvent"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试类</span></span><br><span class="line"><span class="keyword">import</span> com.google.common.eventbus.EventBus;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadEventTest</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化消息总线</span></span><br><span class="line">        EventBus eventBus = <span class="keyword">new</span> EventBus();</span><br><span class="line">        <span class="comment">// 注册 DeadEvent 订阅者</span></span><br><span class="line">        eventBus.register(<span class="keyword">new</span> DeadEventHandler());</span><br><span class="line">        <span class="comment">// MqEvent推送给订阅者</span></span><br><span class="line">        MQEvent mqEvent = <span class="keyword">new</span> MQEvent();</span><br><span class="line">        <span class="comment">// 发布消息，没有订阅者</span></span><br><span class="line">        eventBus.post(mqEvent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其他类使用"><a href="#其他类使用" class="headerlink" title="其他类使用"></a>其他类使用</h2><ul><li><p>AsyncEventBus：异步事件总线，当处理耗时的处理时很有用，我们要依赖Executors来实现异步事件总线。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AsyncEventBus asyncEventBus = <span class="keyword">new</span> AsyncEventBus(executorService);</span><br></pre></td></tr></table></figure></li><li><p>AllowConcurrentEvents：在设置观察者时，需要使用注解类@Subscribe来标识一个订阅者，但在注解中还要一个注解@AllowConcurrentEvents，这个注解是用来标识当前订阅者是线程安全的。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Creates a &#123;<span class="doctag">@code</span> Subscriber&#125; for &#123;<span class="doctag">@code</span> method&#125; on &#123;<span class="doctag">@code</span> listener&#125;. </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Subscriber <span class="title">create</span><span class="params">(EventBus bus, Object listener, Method method)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> isDeclaredThreadSafe(method)</span><br><span class="line">        ? <span class="keyword">new</span> Subscriber(bus, listener, method)</span><br><span class="line">        : <span class="keyword">new</span> SynchronizedSubscriber(bus, listener, method);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://greengerong.github.io/blog/2014/11/27/guava-eventbus/" target="_blank" rel="noopener">Guava - EventBus(事件总线)</a></li><li><a href="https://www.jianshu.com/p/a950d7c294e5" target="_blank" rel="noopener">Guava eventBus 关于@AllowConcurrentEvents 纪实</a></li><li><a href="https://www.iteye.com/blog/uule-2096279" target="_blank" rel="noopener">用guava实现简单的事件驱动</a></li><li><a href="https://www.jianshu.com/p/703fa6cf6e44" target="_blank" rel="noopener">Guava EventBus</a></li><li><a href="https://www.yeetrack.com/?p=1177" target="_blank" rel="noopener">走近Guava(六): 事件总线EventBus</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Guava-EventBus-介绍&quot;&gt;&lt;a href=&quot;#Guava-EventBus-介绍&quot; class=&quot;headerlink&quot; title=&quot;Guava EventBus 介绍&quot;&gt;&lt;/a&gt;Guava EventBus 介绍&lt;/h2&gt;&lt;p&gt;Guava 的 EventBus 可以简化生产/消费模型。EventBus 通过非常简单的方式，实现了观察者模式中的监听注册，事件分发。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Dispatches events to listeners, and provides ways for listeners to register themselves. The EventBus allows publish-subscribe-style communication between components without requiring the components to explicitly register with one another (and thus be aware of each other). It is designed exclusively to replace traditional Java in-processs event distribution using explicit registration. It is not a general-purpose publish-subscribe system, nor is it intended for interprocess communication.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;将事件分发给监听器，同时提供监听器注册监听的方式。EventBus 支持组件之间的发布-订阅式通信，而不需要组件显式地彼此注册（从而彼此感知对方存在）。它是专门为使用显式注册来替代传统的 Java 进程内事件分发而设计的。它不是一个通用的发布订阅系统，也不支持进程间通信。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="web开发" scheme="https://dongzl.github.io/categories/web%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Google" scheme="https://dongzl.github.io/tags/Google/"/>
    
      <category term="Guava" scheme="https://dongzl.github.io/tags/Guava/"/>
    
      <category term="EventBus" scheme="https://dongzl.github.io/tags/EventBus/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://dongzl.github.io/2019/12/26/hello-world/"/>
    <id>https://dongzl.github.io/2019/12/26/hello-world/</id>
    <published>2019-12-26T13:35:58.000Z</published>
    <updated>2020-03-09T13:29:46.081Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;Quick-Start&quot;&gt;&lt;a href=&quot;#Quick-Start&quot; class=&quot;headerlink&quot; title=&quot;Quick Start&quot;&gt;&lt;/a&gt;Quick Start&lt;/h2&gt;&lt;h3 id=&quot;Create-a-new-post&quot;&gt;&lt;a href=&quot;#Create-a-new-post&quot; class=&quot;headerlink&quot; title=&quot;Create a new post&quot;&gt;&lt;/a&gt;Create a new post&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo new &lt;span class=&quot;string&quot;&gt;&quot;My New Post&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="其他" scheme="https://dongzl.github.io/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="hexo" scheme="https://dongzl.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>极客时间 《设计模式之美》 学习笔记</title>
    <link href="https://dongzl.github.io/2019/12/26/08-The-Beauty-Of-Design-Pattern/"/>
    <id>https://dongzl.github.io/2019/12/26/08-The-Beauty-Of-Design-Pattern/</id>
    <published>2019-12-26T13:35:58.000Z</published>
    <updated>2020-03-11T13:09:38.903Z</updated>
    
    <content type="html"><![CDATA[<p>本文是 <a href="https://time.geekbang.org/" target="_blank" rel="noopener">极客时间</a> 上 <a href="https://time.geekbang.org/column/intro/100039001" target="_blank" rel="noopener">设计模式之美</a> 课程的学习笔记内容。</p><a id="more"></a><h2 id="设计原则与思想：设计原则"><a href="#设计原则与思想：设计原则" class="headerlink" title="设计原则与思想：设计原则"></a>设计原则与思想：设计原则</h2><h3 id="15-理论一：对于单一职责原则，如何判定某个类的职责是否够“单一”？"><a href="#15-理论一：对于单一职责原则，如何判定某个类的职责是否够“单一”？" class="headerlink" title="15 | 理论一：对于单一职责原则，如何判定某个类的职责是否够“单一”？"></a>15 | 理论一：对于单一职责原则，如何判定某个类的职责是否够“单一”？</h3><p>单一职责原则：Single Responsibility Principle，缩写为 SRP。</p><p>我们可以现写一个粗粒度的类，满足业务需求。随着业务的发展，如果粗粒度的类越来越大，代码越来越多，这个时候，我们就可以将这个粗粒度的类，拆分成几个更细度的类。</p><p><strong>如何理解单一职责（SRP）</strong></p><p>一个类只负责完成一个职责或者功能。不要设计大而全的类，要设计粒度小、功能单一的类。单一职责原则是为了实现代码高内聚、低耦合，提高代码的复用性、可读性、可维护性。</p><p><strong>如何判断类的职责是否足够单一</strong></p><ul><li>类中的代码行数、函数或者属性过多；</li><li>类依赖的其他类过多，或者依赖类的其他类过多；</li><li>私有方法过多；</li><li>比较难给类起一个合适的名字；</li><li>类中大量的方法都是集中操作类中的某几个属性。</li></ul><hr><h3 id="16-理论二：如何做到“对扩展开放、修改关闭”？扩展和修改各指什么？"><a href="#16-理论二：如何做到“对扩展开放、修改关闭”？扩展和修改各指什么？" class="headerlink" title="16 | 理论二：如何做到“对扩展开放、修改关闭”？扩展和修改各指什么？"></a>16 | 理论二：如何做到“对扩展开放、修改关闭”？扩展和修改各指什么？</h3><p>开闭原则：Open Closed Principle，简写为 OCP。</p><blockquote><p>Software entities (modules, classes, functions, etc.) should be open for extension , but closed for modification。</p></blockquote><p>我们把它翻译成中文就是：软件实体（模块、类、方法等）应该“对扩展开放、对修改关闭”。</p><hr><h3 id="17-理论三：里式替换（LSP）跟多态有何区别？哪些代码违背了LSP？"><a href="#17-理论三：里式替换（LSP）跟多态有何区别？哪些代码违背了LSP？" class="headerlink" title="17 | 理论三：里式替换（LSP）跟多态有何区别？哪些代码违背了LSP？"></a>17 | 理论三：里式替换（LSP）跟多态有何区别？哪些代码违背了LSP？</h3><p>里式替换原则：Liskov Substitution Principle，缩写为 LSP。</p><blockquote><p>Functions that use pointers of references to base classes must be able to use objects of derived classes without knowing it。</p></blockquote><p>子类对象（object of subtype/derived class）能够替换程序（program）中父类对象（object of base/parent class）出现的任何地方，并且保证原来程序的逻辑行为（behavior）不变及正确性不被破坏。</p><p><strong>违反里式替换原则的情况：</strong></p><ul><li>子类违背父类声明要实现的功能；</li><li>子类违背父类对输入、输出、异常的约定；</li><li>子类违背父类注释中所罗列的任何特殊说明。</li></ul><p><strong>多态 &amp; 里式替换原则</strong>：</p><p>多态是面向对象编程的一大特性，也是面向对象编程语言的一种语法。它是一种代码实现的思路。而里式替换是一种设计原则，用来指导继承关系中子类该如何设计，子类的设计要保证在替换父类的时候，不改变原有程序的逻辑及不破坏原有程序的正确性。</p><hr><h3 id="18-理论四：接口隔离原则有哪三种应用？原则中的“接口”该如何理解？"><a href="#18-理论四：接口隔离原则有哪三种应用？原则中的“接口”该如何理解？" class="headerlink" title="18 | 理论四：接口隔离原则有哪三种应用？原则中的“接口”该如何理解？"></a>18 | 理论四：接口隔离原则有哪三种应用？原则中的“接口”该如何理解？</h3><p>接口隔离原则：Interface Segregation Principle”，缩写为 ISP。</p><blockquote><p>Clients should not be forced to depend upon interfaces that they do not use。</p></blockquote><p>如果把“接口”理解为一组接口集合，可以是某个微服务的接口，也可以是某个类库的接口等。如果部分接口只被部分调用者使用，我们就需要将这部分接口隔离出来，单独给这部分调用者使用，而不强迫其他调用者也依赖这部分不会被用到的接口。</p><p>如果把“接口”理解为单个 API 接口或函数，部分调用者只需要函数中的部分功能，那我们就需要把函数拆分成粒度更细的多个函数，让调用者只依赖它需要的那个细粒度函数。</p><p>如果把“接口”理解为 OOP 中的接口，也可以理解为面向对象编程语言中的接口语法。那接口的设计要尽量单一，不要让接口的实现类和调用者，依赖不需要的接口函数。</p><hr><h3 id="19-理论五：控制反转、依赖反转、依赖注入，这三者有何区别和联系？"><a href="#19-理论五：控制反转、依赖反转、依赖注入，这三者有何区别和联系？" class="headerlink" title="19 | 理论五：控制反转、依赖反转、依赖注入，这三者有何区别和联系？"></a>19 | 理论五：控制反转、依赖反转、依赖注入，这三者有何区别和联系？</h3><p>依赖倒置原则：Dependency Inversion Principle，缩写为 DIP。</p><blockquote><p>High-level modules shouldn’t depend on low-level modules. Both modules should depend on abstractions. In addition, abstractions shouldn’t depend on details. Details depend on abstractions.</p></blockquote><p>高层模块（high-level modules）不要依赖低层模块（low-level）。高层模块和低层模块应该通过抽象（abstractions）来互相依赖。除此之外，抽象（abstractions）不要依赖具体实现细节（details），具体实现细节（details）依赖抽象（abstractions）。</p><hr><h3 id="20-理论六：我为何说KISS、YAGNI原则看似简单，却经常被用错？"><a href="#20-理论六：我为何说KISS、YAGNI原则看似简单，却经常被用错？" class="headerlink" title="20 | 理论六：我为何说KISS、YAGNI原则看似简单，却经常被用错？"></a>20 | 理论六：我为何说KISS、YAGNI原则看似简单，却经常被用错？</h3><blockquote><p>Keep It Simple and Stupid. 尽量保持简单。</p></blockquote><p><strong>如何写出满足 KISS 原则的代码？</strong></p><ul><li>不要使用同事可能不懂的技术来实现代码。</li><li>不要重复造轮子，要善于使用已经有的工具类库。</li><li>不要过度优化。不要过度使用一些奇技淫巧来优化代码，牺牲代码的可读性。</li></ul><p><strong>YAGNI 原则</strong>（不要做过度设计）</p><blockquote><p>YAGNI 原则的英文全称是：You Ain’t Gonna Need It。</p></blockquote><hr><h3 id="21-理论七：重复的代码就一定违背DRY吗？如何提高代码的复用性？"><a href="#21-理论七：重复的代码就一定违背DRY吗？如何提高代码的复用性？" class="headerlink" title="21 | 理论七：重复的代码就一定违背DRY吗？如何提高代码的复用性？"></a>21 | 理论七：重复的代码就一定违背DRY吗？如何提高代码的复用性？</h3><p><strong>DRY 原则（Don’t Repeat Yourself）</strong></p><ul><li>实现逻辑重复（不违反 DRY 原则）</li><li>功能语义逻辑（违反 DRY 原则）</li><li>代码执行重复（违反 DRY 原则）</li></ul><p><strong>提高代码可复用性的方法</strong></p><ul><li>减少代码耦合</li><li>满足单一职责原则</li><li>模块化</li><li>业务与非业务逻辑分离</li><li>通用代码下沉</li><li>继承、多态、抽象、封装</li><li>应用模板等设计模式</li></ul><hr><h3 id="22-理论八：如何用迪米特法则（LOD）实现“高内聚、松耦合”？"><a href="#22-理论八：如何用迪米特法则（LOD）实现“高内聚、松耦合”？" class="headerlink" title="22 | 理论八：如何用迪米特法则（LOD）实现“高内聚、松耦合”？"></a>22 | 理论八：如何用迪米特法则（LOD）实现“高内聚、松耦合”？</h3><p>迪米特法则：Law of Demeter，缩写是 LOD。</p><p>最小知识原则：The Least Knowledge Principle。</p><blockquote><p>Each unit should have only limited knowledge about other units: only units “closely” related to the current unit. Or: Each unit should only talk to its friends; Don’t talk to strangers.</p></blockquote><hr><h3 id="23-实战一（上）：针对业务系统的开发，如何做需求分析和设计？"><a href="#23-实战一（上）：针对业务系统的开发，如何做需求分析和设计？" class="headerlink" title="23 | 实战一（上）：针对业务系统的开发，如何做需求分析和设计？"></a>23 | 实战一（上）：针对业务系统的开发，如何做需求分析和设计？</h3><ul><li><p>技术人也要有一些产品思维。对于产品设计、需求分析，我们要学会“借鉴”，一定不要自己闷头想。一方面这样做很难想全面，另一方面从零开始设计也比较浪费时间。除此之外，我们还可以通过线框图和用户用例来细化业务流程，挖掘一些比较细节的、不容易想到的功能点。</p></li><li><p>面向对象设计聚焦在代码层面（主要是针对类），那系统设计就是聚焦在架构层面（主要是针对模块），两者有很多相似之处。很多设计原则和思想不仅仅可以应用到代码设计中，还能用到架构设计中。实际上，我们可以借鉴面向对象设计的步骤，来做系统设计。</p></li><li><p>面向对象设计的本质就是把合适的代码放到合适的类中。合理地划分代码可以实现代码的高内聚、低耦合，类与类之间的交互简单清晰，代码整体结构一目了然。类比面向对象设计，系统设计实际上就是将合适的功能放到合适的模块中。合理地划分模块也可以做到模块层面的高内聚、低耦合，架构整洁清晰。在面向对象设计中，类设计好之后，我们需要设计类之间的交互关系。类比到系统设计，系统职责划分好之后，接下来就是设计系统之间的交互了。</p></li></ul><hr><h3 id="24-实战一（下）：如何实现一个遵从设计原则的积分兑换系统？"><a href="#24-实战一（下）：如何实现一个遵从设计原则的积分兑换系统？" class="headerlink" title="24 | 实战一（下）：如何实现一个遵从设计原则的积分兑换系统？"></a>24 | 实战一（下）：如何实现一个遵从设计原则的积分兑换系统？</h3><p><strong>MVC 三层开发作用：</strong></p><ul><li>分层能起到代码复用的作用</li><li>分层能起到隔离变化的作用</li><li>分层能起到隔离关注点的作用</li><li>分层能提高代码的可测试性</li><li>分层能应对系统的复杂性</li></ul><img src="https://static001.geekbang.org/resource/image/33/61/3332071c82182e72518143d05b8eaa61.jpg"><hr><h3 id="25-实战二（上）：针对非业务的通用框架开发，如何做需求分析和设计？"><a href="#25-实战二（上）：针对非业务的通用框架开发，如何做需求分析和设计？" class="headerlink" title="25 | 实战二（上）：针对非业务的通用框架开发，如何做需求分析和设计？"></a>25 | 实战二（上）：针对非业务的通用框架开发，如何做需求分析和设计？</h3><p>对于非业务通用框架开发：</p><ul><li>首先考虑功能性需求分析；</li><li>还要考虑框架的非功能性需求：易用性、性能、扩展性、容错性、通用性。</li></ul><p>复杂框架设计技巧：</p><ul><li>画产品线框图；</li><li>聚焦简单应用场景；</li><li>设计实现最小原型；</li><li>画系统设计图。</li></ul><hr><h3 id="26-实战二（下）：如何实现一个支持各种统计规则的性能计数器？"><a href="#26-实战二（下）：如何实现一个支持各种统计规则的性能计数器？" class="headerlink" title="26 | 实战二（下）：如何实现一个支持各种统计规则的性能计数器？"></a>26 | 实战二（下）：如何实现一个支持各种统计规则的性能计数器？</h3><hr><h2 id="设计原则与思想：规范与重构"><a href="#设计原则与思想：规范与重构" class="headerlink" title="设计原则与思想：规范与重构"></a>设计原则与思想：规范与重构</h2><h3 id="27-理论一：什么情况下要重构？到底重构什么？又该如何重构？"><a href="#27-理论一：什么情况下要重构？到底重构什么？又该如何重构？" class="headerlink" title="27 | 理论一：什么情况下要重构？到底重构什么？又该如何重构？"></a>27 | 理论一：什么情况下要重构？到底重构什么？又该如何重构？</h3><p>重构是一种对软件内部结构的改变，目的是在不改变软件的可见行为的情况下，使其更易理解，修改成本更低。</p><p>大型重构指的是对顶层代码设计的重构，包括：系统、模块、代码结构、类与类之间的关系等的重构，重构的手段有：分层、模块化、解耦、抽象可复用组件等等。</p><p>小型重构指的是对代码细节的重构，主要是针对类、函数、变量等代码级别的重构，比如规范命名、规范注释、消除超大类或函数、提取重复代码等等。</p><h3 id="28-理论二：为了保证重构不出错，有哪些非常能落地的技术手段？"><a href="#28-理论二：为了保证重构不出错，有哪些非常能落地的技术手段？" class="headerlink" title="28 | 理论二：为了保证重构不出错，有哪些非常能落地的技术手段？"></a>28 | 理论二：为了保证重构不出错，有哪些非常能落地的技术手段？</h3><h3 id="29-理论三：什么是代码的可测试性？如何写出可测试性好的代码？"><a href="#29-理论三：什么是代码的可测试性？如何写出可测试性好的代码？" class="headerlink" title="29 | 理论三：什么是代码的可测试性？如何写出可测试性好的代码？"></a>29 | 理论三：什么是代码的可测试性？如何写出可测试性好的代码？</h3><p>常见的测试不友好的代码有下面这 5 种：</p><ul><li>代码中包含未决行为逻辑</li><li>滥用可变全局变量</li><li>滥用静态方法</li><li>使用复杂的继承关系</li><li>高度耦合的代码</li></ul><h3 id="30-理论四：如何通过封装、抽象、模块化、中间层等解耦代码？"><a href="#30-理论四：如何通过封装、抽象、模块化、中间层等解耦代码？" class="headerlink" title="30 | 理论四：如何通过封装、抽象、模块化、中间层等解耦代码？"></a>30 | 理论四：如何通过封装、抽象、模块化、中间层等解耦代码？</h3><p>如何给代码“解耦”：</p><ul><li>封装与抽象</li><li>中间层</li><li>模块化</li><li>其他设计思想和原值<ul><li>单一职责原则</li><li>基于接口而非实现编程</li><li>依赖注入</li><li>对用组合少用继承</li><li>迪米特法则</li></ul></li></ul><h3 id="31-理论五：让你最快速地改善代码质量的20条编程规范（上）"><a href="#31-理论五：让你最快速地改善代码质量的20条编程规范（上）" class="headerlink" title="31 | 理论五：让你最快速地改善代码质量的20条编程规范（上）"></a>31 | 理论五：让你最快速地改善代码质量的20条编程规范（上）</h3><ul><li><p>关于命名：</p><ul><li>命名的关键是能准确达意。</li><li>借助类的信息来简化属性、函数的命名，利用函数的信息来简化函数参数的命名。</li><li>命名要可读、可搜索。</li><li>接口 &amp; 抽象类命名方式。</li></ul></li><li><p>关于注释：</p><ul><li>注释的目的就是让代码更容易看懂。</li><li>注释本身有一定的维护成本，所以并非越多越好。</li></ul></li></ul><h3 id="32-理论五：让你最快速地改善代码质量的20条编程规范（中）"><a href="#32-理论五：让你最快速地改善代码质量的20条编程规范（中）" class="headerlink" title="32 | 理论五：让你最快速地改善代码质量的20条编程规范（中）"></a>32 | 理论五：让你最快速地改善代码质量的20条编程规范（中）</h3><ul><li>合适的类、函数大小</li><li>一行代码最长不能超过 IDE 显示的宽度。</li><li>善用空行分割单元块</li><li>四格缩进还是两格缩进（分割统一，不用tab）</li><li>大括号所在位置（只要团队统一、业内统一、跟开源项目看齐）</li><li>类中成员的排列顺序（先变量后函数，先静态后普通，作用域由大到小）</li></ul><h3 id="33-理论五：让你最快速地改善代码质量的20条编程规范（下）"><a href="#33-理论五：让你最快速地改善代码质量的20条编程规范（下）" class="headerlink" title="33 | 理论五：让你最快速地改善代码质量的20条编程规范（下）"></a>33 | 理论五：让你最快速地改善代码质量的20条编程规范（下）</h3><ul><li>把代码分割成更小的单元块</li><li>避免函数参数过多</li><li>勿用函数参数来控制逻辑(参数中包含 true | false)</li><li>函数设计要职责单一</li><li>移除过深的嵌套层次</li><li>学会使用解释性变量<ul><li>常量取代魔法数字。</li><li>使用解释性变量来解释复杂表达式。</li></ul></li></ul><h3 id="34-实战一（上）：通过一段ID生成器代码，学习如何发现代码质量问题"><a href="#34-实战一（上）：通过一段ID生成器代码，学习如何发现代码质量问题" class="headerlink" title="34 | 实战一（上）：通过一段ID生成器代码，学习如何发现代码质量问题"></a>34 | 实战一（上）：通过一段ID生成器代码，学习如何发现代码质量问题</h3><p>如何发现代码质量问题：<br>大的方向是否可读、可扩展、可维护、灵活、简洁、可复用、可测试<br>具体落实，通用的关注点有：</p><ul><li>1）目录设置是否合理、模块划分是否清晰、代码结构是否满足“高内聚、松耦合”？</li><li>2）是否遵循经典的设计原则和设计思想（SOLID、DRY、KISS、YAGNI、LOD 等）？</li><li>3）设计模式是否应用得当？是否有过度设计？</li><li>4）代码是否容易扩展？如果要添加新功能，是否容易实现？</li><li>5）代码是否可以复用？是否可以复用已有的项目代码或类库？是否有重复造轮子？</li><li>6）代码是否容易测试？单元测试是否全面覆盖了各种正常和异常的情况？</li><li>7）代码是否易读？是否符合编码规范（比如命名和注释是否恰当、代码风格是否一致等）？</li></ul><p>关于业务的一些通用关注点：</p><ul><li>1）代码是否实现了预期的业务需求？</li><li>2）逻辑是否正确？是否处理了各种异常情况？</li><li>3）日志打印是否得当？是否方便 debug 排查问题？</li><li>4）接口是否易用？是否支持幂等、事务等？</li><li>5）代码是否存在并发问题？是否线程安全？</li><li>6）性能是否有优化空间，比如，SQL、算法是否可以优化？</li><li>7）是否有安全漏洞？比如输入输出校验是否全面？</li></ul><h3 id="35-实战一（下）：手把手带你将ID生成器代码从“能用”重构为“好用”"><a href="#35-实战一（下）：手把手带你将ID生成器代码从“能用”重构为“好用”" class="headerlink" title="35 | 实战一（下）：手把手带你将ID生成器代码从“能用”重构为“好用”"></a>35 | 实战一（下）：手把手带你将ID生成器代码从“能用”重构为“好用”</h3><ul><li>即便是非常简单的需求，不同水平的人写出来的代码，差别可能会很大。</li><li>知其然知其所以然，了解优秀代码设计的演变过程，比学习优秀设计本身更有价值。</li><li>设计思想、原则、模式本身并没有太多“高大上”的东西，都是一些简单的道理。</li><li>高手之间的竞争都是在细节。</li></ul><h3 id="36-实战二（上）：程序出错该返回啥？NULL、异常、错误码、空对象？"><a href="#36-实战二（上）：程序出错该返回啥？NULL、异常、错误码、空对象？" class="headerlink" title="36 | 实战二（上）：程序出错该返回啥？NULL、异常、错误码、空对象？"></a>36 | 实战二（上）：程序出错该返回啥？NULL、异常、错误码、空对象？</h3><p>函数出错返回数据类型：</p><ul><li>返回错误码</li><li>返回 NULL 值</li><li>返回空对象</li><li>抛出异常对象<ul><li>如果 func1() 抛出的异常是可以恢复，且 func2() 的调用方并不关心此异常，我们完全可以在 func2() 内将 func1() 抛出的异常吞掉；</li><li>如果 func1() 抛出的异常对 func2() 的调用方来说，也是可以理解的、关心的 ，并且在业务概念上有一定的相关性，我们可以选择直接将 func1 抛出的异常 re-throw；</li><li>如果 func1() 抛出的异常太底层，对 func2() 的调用方来说，缺乏背景去理解、且业务概念上无关，我们可以将它重新包装成调用方可以理解的新异常，然后 re-throw。</li></ul></li></ul><h3 id="37-实战二（下）：重构ID生成器项目中各函数的异常处理代码"><a href="#37-实战二（下）：重构ID生成器项目中各函数的异常处理代码" class="headerlink" title="37 | 实战二（下）：重构ID生成器项目中各函数的异常处理代码"></a>37 | 实战二（下）：重构ID生成器项目中各函数的异常处理代码</h3><ul><li>再简单的代码，看上去再完美的代码，只要我们下功夫去推敲，总有可以优化的空间，就看你愿不愿把事情做到极致。</li><li>如果你内功不够深厚，理论知识不够扎实，那你就很难参透开源项目的代码到底优秀在哪里。</li><li>作为一名程序员，起码对代码要有追求啊，不然跟咸鱼有啥区别！</li></ul><h2 id="设计原则与思想：总结课"><a href="#设计原则与思想：总结课" class="headerlink" title="设计原则与思想：总结课"></a>设计原则与思想：总结课</h2><h3 id="38-总结回顾面向对象、设计原则、编程规范、重构技巧等知识点"><a href="#38-总结回顾面向对象、设计原则、编程规范、重构技巧等知识点" class="headerlink" title="38 | 总结回顾面向对象、设计原则、编程规范、重构技巧等知识点"></a>38 | 总结回顾面向对象、设计原则、编程规范、重构技巧等知识点</h3><p>最常用到几个评判代码质量的标准有：可维护性、可读性、可扩展性、灵活性、简洁性、可复用性、可测试性。</p><p>面向对象编程相比面向过程编程的优势主要有三个：</p><ul><li>对于大规模复杂程序的开发，程序的处理流程并非单一的一条主线，而是错综复杂的网状结构。面向对象编程比起面向过程编程，更能应对这种复杂类型的程序开发。</li><li>面向对象编程相比面向过程编程，具有更加丰富的特性（封装、抽象、继承、多态）。利用这些特性编写出来的代码，更加易扩展、易复用、易维护。</li><li>从编程语言跟机器打交道方式的演进规律中，我们可以总结出：面向对象编程语言比起面向过程编程语言，更加人性化、更加高级、更加智能。</li></ul><p>面向对象分析（OOA）、面向对象设计（OOD）、面向对象编程（OOP），是面向对象开发的三个主要环节。简单点讲，面向对象分析就是要搞清楚做什么，面向对象设计就是要搞清楚怎么做，面向对象编程就是将分析和设计的的结果翻译成代码的过程。</p><p>UML 统一建模语言中定义了六种类之间的关系。它们分别是：泛化、实现、关联、聚合、组合、依赖。我们从更加贴近编程的角度，对类与类之间的关系做了调整，保留了四个关系：泛化、实现、组合、依赖。</p><p>如果要表示一种 is-a 的关系，并且是为了解决代码复用问题，我们就用抽象类；如果要表示一种 has-a 关系，并且是为了解决抽象而非代码复用问题，那我们就用接口。</p><p>基于充血模型的 DDD 开发模式跟基于贫血模型的传统开发模式相比，Controller 层和 Repository 层的代码基本上相同。这是因为，Repository 层的 Entity 生命周期有限，Controller 层的 VO 只是单纯作为一种 DTO。两部分的业务逻辑都不会太复杂。业务逻辑主要集中在 Service 层。所以，Repository 层和 Controller 层继续沿用贫血模型的设计思路是没有问题的。</p><p>设计原则：</p><ul><li>SRP 单一职责原则</li><li>OCP 开闭原则</li><li>LSP 里氏替换原则</li><li>ISP 接口隔离原则</li><li>DIP 依赖倒置原则</li><li>KISS、YAGNI 原则</li><li>DRY 原则</li><li>LOD 原则</li></ul><h3 id="39-运用学过的设计原则和思想完善之前讲的性能计数器项目（上）"><a href="#39-运用学过的设计原则和思想完善之前讲的性能计数器项目（上）" class="headerlink" title="39 | 运用学过的设计原则和思想完善之前讲的性能计数器项目（上）"></a>39 | 运用学过的设计原则和思想完善之前讲的性能计数器项目（上）</h3><img src="https://static001.geekbang.org/resource/image/13/34/1303d16f75c7266cef9105f540c54834.jpg"><h3 id="40-运用学过的设计原则和思想完善之前讲的性能计数器项目（下）"><a href="#40-运用学过的设计原则和思想完善之前讲的性能计数器项目（下）" class="headerlink" title="40 | 运用学过的设计原则和思想完善之前讲的性能计数器项目（下）"></a>40 | 运用学过的设计原则和思想完善之前讲的性能计数器项目（下）</h3><h2 id="设计模式与规范：创建型"><a href="#设计模式与规范：创建型" class="headerlink" title="设计模式与规范：创建型"></a>设计模式与规范：创建型</h2><h3 id="41-单例模式（上）：为什么说支持懒加载的双重检测不比饿汉式更优？"><a href="#41-单例模式（上）：为什么说支持懒加载的双重检测不比饿汉式更优？" class="headerlink" title="41 | 单例模式（上）：为什么说支持懒加载的双重检测不比饿汉式更优？"></a>41 | 单例模式（上）：为什么说支持懒加载的双重检测不比饿汉式更优？</h3><p><strong>单例设计模式</strong>（Singleton Design Pattern）理解起来非常简单。一个类只允许创建一个对象（或者实例），那这个类就是一个单例类，这种设计模式就叫作单例设计模式，简称单例模式。</p><p>如何实现一个单例类？</p><ul><li>构造函数需要是 private 访问权限的，这样才能避免外部通过 new 创建实例；- 考虑对象创建时的线程安全问题；</li><li>考虑是否支持延迟加载；</li><li>考虑 getInstance() 性能是否高（是否加锁）。</li></ul><p>单例的实现：</p><ul><li>饿汉式；</li><li>懒汉式；</li><li>双重检测；</li><li>静态内部类；</li><li>枚举。</li></ul><h3 id="42-单例模式（中）：我为什么不推荐使用单例模式？又有何替代方案？"><a href="#42-单例模式（中）：我为什么不推荐使用单例模式？又有何替代方案？" class="headerlink" title="42 | 单例模式（中）：我为什么不推荐使用单例模式？又有何替代方案？"></a>42 | 单例模式（中）：我为什么不推荐使用单例模式？又有何替代方案？</h3><ul><li>单例对 OOP 特性的支持不友好</li><li>单例会隐藏类之间的依赖关系</li><li>单例对代码的扩展性不友好</li><li>单例对代码的可测试性不友好</li><li>单例不支持有参数的构造函数</li></ul><h3 id="43-单例模式（下）：如何设计实现一个集群环境下的分布式单例模式？"><a href="#43-单例模式（下）：如何设计实现一个集群环境下的分布式单例模式？" class="headerlink" title="43 | 单例模式（下）：如何设计实现一个集群环境下的分布式单例模式？"></a>43 | 单例模式（下）：如何设计实现一个集群环境下的分布式单例模式？</h3><p>单例类中对象的唯一性的作用范围是进程内的，在进程间是不唯一的。</p><p>进程内唯一：使用单例模式；<br>线程内唯一：使用ThreadLocal；<br>进程间唯一：考虑使用分布式锁。</p><p>单例模式并不是严格意义的进程内唯一，而是同一个 ClassLoader 内唯一。</p><h3 id="44-工厂模式（上）：我为什么说没事不要随便用工厂模式创建对象？"><a href="#44-工厂模式（上）：我为什么说没事不要随便用工厂模式创建对象？" class="headerlink" title="44 | 工厂模式（上）：我为什么说没事不要随便用工厂模式创建对象？"></a>44 | 工厂模式（上）：我为什么说没事不要随便用工厂模式创建对象？</h3><ul><li>简单工厂模式（静态工厂模式）</li><li>工厂模式</li><li>抽象工厂模式</li></ul><p>当每个对象的创建逻辑都比较简单的时候，我推荐使用简单工厂模式，将多个对象的创建逻辑放到一个工厂类中。当每个对象的创建逻辑都比较复杂的时候，为了避免设计一个过于庞大的简单工厂类，我推荐使用工厂方法模式，将创建逻辑拆分得更细，每个对象的创建逻辑独立到各自的工厂类中。</p><ul><li>封装变化：创建逻辑有可能变化，封装成工厂类之后，创建逻辑的变更对调用者透明。</li><li>代码复用：创建代码抽离到独立的工厂类之后可以复用。</li><li>隔离复杂性：封装复杂的创建逻辑，调用者无需了解如何创建对象。</li><li>控制复杂度：将创建代码抽离出来，让原本的函数或类职责更单一，代码更简洁。</li></ul><h3 id="45-工厂模式（下）：如何设计实现一个Dependency-Injection框架？"><a href="#45-工厂模式（下）：如何设计实现一个Dependency-Injection框架？" class="headerlink" title="45 | 工厂模式（下）：如何设计实现一个Dependency Injection框架？"></a>45 | 工厂模式（下）：如何设计实现一个Dependency Injection框架？</h3><p>一个简单的 DI 容器的核心功能一般有三个：配置解析、对象创建和对象生命周期管理。</p><p>Spring 处理循环依赖：</p><ul><li>通过构造器注入的循环依赖，是无法解决的。</li><li>Spring 容器对原型作用域的 bean 是不进行缓存，因此无法提前暴露一个创建中的 bean，所以也是无法解决这种情况的循环依赖。</li><li>对于 setter 注入造成的依赖可以通过 Spring 容器提前暴露刚完成构造器注入但未完成其他步骤（如 setter 注入）的 bean 来完成，而且只能解决单例作用域的 bean 依赖。</li></ul><p><a href="https://juejin.im/post/5d0d8f64f265da1b7b3193ac" target="_blank" rel="noopener">Spring 源码学习(五)循环依赖</a></p><h3 id="46-建造者模式：详解构造函数、set方法、建造者模式三种对象创建方式"><a href="#46-建造者模式：详解构造函数、set方法、建造者模式三种对象创建方式" class="headerlink" title="46 | 建造者模式：详解构造函数、set方法、建造者模式三种对象创建方式"></a>46 | 建造者模式：详解构造函数、set方法、建造者模式三种对象创建方式</h3><p>使用建造者模式创建对象，还能避免对象存在无效状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Rectangle r = <span class="keyword">new</span> Rectange(); <span class="comment">// r is invalid</span></span><br><span class="line">r.setWidth(<span class="number">2</span>); <span class="comment">// r is invalid</span></span><br><span class="line">r.setHeight(<span class="number">3</span>); <span class="comment">// r is valid</span></span><br></pre></td></tr></table></figure><p>工厂模式是用来创建不同但是相关类型的对象（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。建造者模式是用来创建一种类型的复杂对象，通过设置不同的可选参数，“定制化”地创建不同的对象。</p><p>顾客走进一家餐馆点餐，我们利用工厂模式，根据用户不同的选择，来制作不同的食物，比如披萨、汉堡、沙拉。对于披萨来说，用户又有各种配料可以定制，比如奶酪、西红柿、起司，我们通过建造者模式根据用户选择的不同配料来制作披萨。</p><h3 id="47-原型模式：如何最快速地clone一个HashMap散列表？"><a href="#47-原型模式：如何最快速地clone一个HashMap散列表？" class="headerlink" title="47 | 原型模式：如何最快速地clone一个HashMap散列表？"></a>47 | 原型模式：如何最快速地clone一个HashMap散列表？</h3><p>如果对象的创建成本比较大，而同一个类的不同对象之间差别不大（大部分字段都相同），在这种情况下，我们可以利用对已有对象（原型）进行复制（或者叫拷贝）的方式，来创建新对象，以达到节省创建时间的目的。这种基于原型来创建对象的方式就叫作原型设计模式，简称原型模式。</p><p>在 Java 语言中，Object 类的 clone() 方法执行的就是我们刚刚说的浅拷贝。它只会拷贝对象中的基本数据类型的数据（比如，int、long），以及引用对象（SearchWord）的内存地址，不会递归地拷贝引用对象本身。</p><img src="https://static001.geekbang.org/resource/image/74/82/74bceb7a0736957daaa4abeba6826182.jpg"><img src="https://static001.geekbang.org/resource/image/b9/1b/b978d054ab3183b9e0ae461e6abac81b.jpg"><h2 id="设计模式与规范：结构型"><a href="#设计模式与规范：结构型" class="headerlink" title="设计模式与规范：结构型"></a>设计模式与规范：结构型</h2><h3 id="48-代理模式：代理在RPC、缓存、监控等场景中的应用"><a href="#48-代理模式：代理在RPC、缓存、监控等场景中的应用" class="headerlink" title="48 | 代理模式：代理在RPC、缓存、监控等场景中的应用"></a>48 | 代理模式：代理在RPC、缓存、监控等场景中的应用</h3><p>在不改变原始类（或叫被代理类）的情况下，通过引入代理类来给原始类附加功能。一般情况下，我们让代理类和原始类实现同样的接口。但是，如果原始类并没有定义接口，并且原始类代码并不是我们开发维护的。在这种情况下，我们可以通过让代理类继承原始类的方法来实现代理模式。</p><p>静态代理需要针对每个类都创建一个代理类，并且每个代理类中的代码都有点像模板式的”重复“代码，增加了维护成本和开发成本。对于静态代理存在的问题，我们可以通过动态代理来解决。我们不事先为每个原始类编写代理类，而是在运行的时候动态地创建原始类对应的代理类，然后在系统中用代理类替换掉原始类。</p><h3 id="49-桥接模式：如何实现支持不同类型和渠道的消息推送系统？"><a href="#49-桥接模式：如何实现支持不同类型和渠道的消息推送系统？" class="headerlink" title="49 | 桥接模式：如何实现支持不同类型和渠道的消息推送系统？"></a>49 | 桥接模式：如何实现支持不同类型和渠道的消息推送系统？</h3><p>Decouple an abstraction from its implementation so that the two can vary independently。（将抽象和实现解耦，让它们可以独立变化。）</p><h3 id="50-装饰器模式：通过剖析Java-IO类库源码学习装饰器模式"><a href="#50-装饰器模式：通过剖析Java-IO类库源码学习装饰器模式" class="headerlink" title="50 | 装饰器模式：通过剖析Java IO类库源码学习装饰器模式"></a>50 | 装饰器模式：通过剖析Java IO类库源码学习装饰器模式</h3><p>装饰器类和原始类继承同样的父类，这样我们可以对原始类“嵌套”多个装饰器类。</p><p>装饰器类是对功能的增强，这也是装饰器模式应用场景的一个重要特点。</p><p>代理模式中，代理类附加的是跟原始类无关的功能，而在装饰器模式中，装饰器类附加的是跟原始类相关的增强功能。</p><img src="https://static001.geekbang.org/resource/image/50/05/507526c2e4b255a45c60722df14f9a05.jpg"><img src="https://static001.geekbang.org/resource/image/50/13/5082df8e7d5a4d44a34811b9f562d613.jpg"><h3 id="51-适配器模式：代理、适配器、桥接、装饰，这四个模式有何区别？"><a href="#51-适配器模式：代理、适配器、桥接、装饰，这四个模式有何区别？" class="headerlink" title="51 | 适配器模式：代理、适配器、桥接、装饰，这四个模式有何区别？"></a>51 | 适配器模式：代理、适配器、桥接、装饰，这四个模式有何区别？</h3><p>适配器模式有两种实现方式：类适配器和对象适配器。其中，类适配器使用继承关系来实现，对象适配器使用组合关系来实现。</p><p><strong>代理模式</strong>：代理模式在不改变原始类接口的条件下，为原始类定义一个代理类，主要目的是控制访问，而非加强功能，这是它跟装饰器模式最大的不同。<br><strong>桥接模式</strong>：桥接模式的目的是将接口部分和实现部分分离，从而让它们可以较为容易、也相对独立地加以改变。<br><strong>装饰器模式</strong>：装饰者模式在不改变原始类接口的情况下，对原始类功能进行增强，并且支持多个装饰器的嵌套使用。<br><strong>适配器模式</strong>：适配器模式是一种事后的补救策略。适配器提供跟原始类不同的接口，而代理模式、装饰器模式提供的都是跟原始类相同的接口。</p><h3 id="52-门面模式：如何设计合理的接口粒度以兼顾接口的易用性和通用性？"><a href="#52-门面模式：如何设计合理的接口粒度以兼顾接口的易用性和通用性？" class="headerlink" title="52 | 门面模式：如何设计合理的接口粒度以兼顾接口的易用性和通用性？"></a>52 | 门面模式：如何设计合理的接口粒度以兼顾接口的易用性和通用性？</h3><p><strong>门面模式</strong>：</p><ul><li>Provide a unified interface to a set of interfaces in a subsystem. Facade Pattern defines a higher-level interface that makes the subsystem easier to use.</li><li>门面模式为子系统提供一组统一的接口，定义一组高层接口让子系统更易用。</li></ul><p>完成接口设计，就相当于完成了一半的开发任务。只要接口设计得好，那代码就差不到哪里去。</p><p>尽量保持接口的可复用性，但针对特殊情况，允许提供冗余的门面接口，来提供更易用的接口。</p><ul><li>当要为一个复杂子系统提供一个简单接口时可以使用外观模式。</li><li>客户程序与多个子系统之间存在很大的依赖性。</li><li>使用外观模式定义系统中每一层的入口，层与层之间不直接产生联系，而通过外观类建立联系，降低层之间的耦合度。</li></ul><p>增加新的子系统可能需要修改外观类或客户端的源代码，<strong>违背了“开闭原则”</strong>。</p><h3 id="53-组合模式：如何设计实现支持递归遍历的文件系统目录树结构？"><a href="#53-组合模式：如何设计实现支持递归遍历的文件系统目录树结构？" class="headerlink" title="53 | 组合模式：如何设计实现支持递归遍历的文件系统目录树结构？"></a>53 | 组合模式：如何设计实现支持递归遍历的文件系统目录树结构？</h3><p>组合模式：Compose objects into tree structure to represent part-whole hierarchies. Composite lets client treat individual objects and compositions of objects uniformly.</p><p>将一组对象组织（Compose）成树形结构，以表示一种“部分 - 整体”的层次结构。组合让客户端（在很多设计模式书籍中，“客户端”代指代码的使用者。）可以统一单个对象和组合对象的处理逻辑。</p><h3 id="54-享元模式（上）：如何利用享元模式优化文本编辑器的内存占用？"><a href="#54-享元模式（上）：如何利用享元模式优化文本编辑器的内存占用？" class="headerlink" title="54 | 享元模式（上）：如何利用享元模式优化文本编辑器的内存占用？"></a>54 | 享元模式（上）：如何利用享元模式优化文本编辑器的内存占用？</h3><p>享元模式(Flyweight Pattern)：运用共享技术有效地支持大量细粒度对象的复用。(Use sharing to support large numbers of fine-grained objects efficiently.)</p><p>享元模式的代码实现非常简单，主要是通过工厂模式，在工厂类中，通过一个 Map 或者 List 来缓存已经创建好的享元对象，以达到复用的目的。</p><h3 id="55-享元模式（下）：剖析享元模式在Java-Integer、String中的应用"><a href="#55-享元模式（下）：剖析享元模式在Java-Integer、String中的应用" class="headerlink" title="55 | 享元模式（下）：剖析享元模式在Java Integer、String中的应用"></a>55 | 享元模式（下）：剖析享元模式在Java Integer、String中的应用</h3><p>JDK 设置 Integer 缓存参数：</p><ul><li>方法一：-Djava.lang.Integer.IntegerCache.high=255</li><li>方法二：-XX:AutoBoxCacheMax=255</li></ul><p>JDK 中 Integer 对象缓存，String 常量池，都是使用的享元模式。</p><h2 id="设计模式与规范：行为型"><a href="#设计模式与规范：行为型" class="headerlink" title="设计模式与规范：行为型"></a>设计模式与规范：行为型</h2><h3 id="56-观察者模式（上）：详解各种应用场景下观察者模式的不同实现方式"><a href="#56-观察者模式（上）：详解各种应用场景下观察者模式的不同实现方式" class="headerlink" title="56 | 观察者模式（上）：详解各种应用场景下观察者模式的不同实现方式"></a>56 | 观察者模式（上）：详解各种应用场景下观察者模式的不同实现方式</h3><p><strong>设计模式要干的事情就是解耦。创建型模式是将创建和使用代码解耦，结构型模式是将不同功能代码解耦，行为型模式是将不同的行为代码解耦，具体到观察者模式，它是将观察者和被观察者代码解耦。</strong></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://blog.cleancoder.com/uncle-bob/2014/05/08/SingleReponsibilityPrinciple.html" target="_blank" rel="noopener">The Clean Code Blog</a></li><li><a href="https://unbug.github.io/codelf/" target="_blank" rel="noopener">Codelf(变量命名神器)</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是 &lt;a href=&quot;https://time.geekbang.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;极客时间&lt;/a&gt; 上 &lt;a href=&quot;https://time.geekbang.org/column/intro/100039001&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;设计模式之美&lt;/a&gt; 课程的学习笔记内容。&lt;/p&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="https://dongzl.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://dongzl.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="设计原则" scheme="https://dongzl.github.io/tags/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>Lombok 框架使用总结</title>
    <link href="https://dongzl.github.io/2019/11/30/12-Lombok-Use-Summary/"/>
    <id>https://dongzl.github.io/2019/11/30/12-Lombok-Use-Summary/</id>
    <published>2019-11-30T12:38:18.000Z</published>
    <updated>2020-03-09T14:23:23.166Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景描述"><a href="#背景描述" class="headerlink" title="背景描述"></a>背景描述</h2><p>最近一直在参与 <a href="https://github.com/apache/incubator-shardingsphere" target="_blank" rel="noopener">ShardingSphere</a> 开源项目的一些工作，在 ShardingSphere 项目中大量的使用了 <a href="https://projectlombok.org/" target="_blank" rel="noopener">Lombok</a> 框架，对于 Lombok 框架只是有个大概了解，并没有实际的使用，也没有做过深入的研究，正好借参与 ShardingSphere 项目的机会对 Lombok 框架做一个学习和总结，先总结一下自己目前使用中遇到的问题，后续持续不断更新。</p><a id="more"></a><p>首先，来看一下 Lombok 官方对这个框架的介绍：</p><blockquote><p>Project Lombok is a java library that automatically plugs into your editor and build tools, spicing up your java.<br>Never write another getter or equals method again, with one annotation your class has a fully featured builder, Automate your logging variables, and much more.</p></blockquote><p>Lombok 是一个 java 类库，它可以自动插入到编辑器和构建工具中，对 java 代码进行增强。</p><p>使用 Lombok 后不需要再实现 getter 或者 equals 方法，使用一个注解，您的类就可以拥有一个功能齐全的构造器，自动生成一个日志变量等等功能。</p><blockquote><p>测试 Lombok 版本：1.18.10</p></blockquote><h2 id="构造方法相关注解"><a href="#构造方法相关注解" class="headerlink" title="构造方法相关注解"></a>构造方法相关注解</h2><h3 id="NoArgsConstructor"><a href="#NoArgsConstructor" class="headerlink" title="@NoArgsConstructor"></a>@NoArgsConstructor</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.AccessLevel;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NoArgsConstructor</span>(access = AccessLevel.PRIVATE, staticName = <span class="string">"of"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@NoArgsConstructor 用于生成无参构造器，如果类中存在 final 字段，则会报编译错误。</p><ul><li><code>access</code> 参数用于指定构造器的访问权限，默认为 <code>AccessLevel.PUBLIC</code> 表示生成 public 访问权限的构造器；</li><li><code>staticName</code> 参数用于自动生成一个静态的“构造器”工厂，其内部包裹着一个私有的构造器，对外提供创建对象的功能，这是明显的工厂模式。</li></ul><h3 id="RequiredArgsConstructor"><a href="#RequiredArgsConstructor" class="headerlink" title="@RequiredArgsConstructor"></a>@RequiredArgsConstructor</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.AccessLevel;</span><br><span class="line"><span class="keyword">import</span> lombok.NonNull;</span><br><span class="line"><span class="keyword">import</span> lombok.RequiredArgsConstructor;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span>(access = AccessLevel.PUBLIC, staticName = <span class="string">"of"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Integer id;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        User user = User.of(<span class="number">1</span>, <span class="string">"test"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@RequiredArgsConstructor 用于按照要求生成部分参数构造器，所谓的要求就是包含 final 和 @NonNull 约束标注的字段，会对 @NonNull 字段进行明确的 null 检查。</p><h3 id="AllArgsConstructor"><a href="#AllArgsConstructor" class="headerlink" title="@AllArgsConstructor"></a>@AllArgsConstructor</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.AccessLevel;</span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.NonNull;</span><br><span class="line"><span class="keyword">import</span> lombok.RequiredArgsConstructor;</span><br><span class="line"></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span>(access = AccessLevel.PUBLIC, staticName = <span class="string">"of"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Integer id;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        User user = User.of(<span class="number">1</span>, <span class="string">"test"</span>);</span><br><span class="line">        User user2 = <span class="keyword">new</span> User(<span class="number">1</span>, <span class="string">"test"</span>, <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@AllArgsConstructor 用于生成包含所有字段的构造器。</p><h2 id="Getter-amp-Setter"><a href="#Getter-amp-Setter" class="headerlink" title="@Getter &amp; @Setter"></a>@Getter &amp; @Setter</h2><p>@Getter &amp; @Setter 标注在字段上，用于自动生成 get、set 方法，boolean 类型字段 get 方法为 isXXX() 方法。</p><p>生成的 get、set 方法默认情况下都是 public 的，但也可以手动指定以下四种范围：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">AccessLevel.PUBLIC</span><br><span class="line">AccessLevel.MODULE</span><br><span class="line">AccessLevel.PROTECTED</span><br><span class="line">AccessLevel.PACKAGE</span><br><span class="line">AccessLevel.PRIVATE</span><br></pre></td></tr></table></figure><p>@Getter &amp; @Setter 也可以标注在类上，表示针对该类中所有的非静态字段进行 get、set 方法自动生成。如果指定某个字段的 <code>AccessLevel = AccessLevel.NONE</code>，则可以使该生成动作失效，此时可以手动实现get、set方法，AccessLevel.NONE 可以应用于在某些方法中有一些自定义逻辑的情况下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.AccessLevel;</span><br><span class="line"><span class="keyword">import</span> lombok.Getter;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Setter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Setter</span>(value = AccessLevel.PRIVATE)</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Getter</span>(value = AccessLevel.PACKAGE)</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Getter</span>(value = AccessLevel.NONE)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> student;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isStudent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (age &lt; <span class="number">18</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ToString"><a href="#ToString" class="headerlink" title="@ToString"></a>@ToString</h2><p>@ToString 标注于类之上，用于生成 toString() 方法。</p><ul><li>includeFieldNames：默认为 true，表示在 toString 输出时输出字段名称；</li><li>exclude：字符串数组，表示在 toString 输出时排除掉字段名称，这个属性将要被废弃了，用 @ToString.Exclude 来代替；</li><li>of：字符串数组，明确的列出在 toString 输出时输出字段名称，这个属性将要被废弃了，用 @ToString.Include 来代替；</li><li>callSuper：默认为 false，表示生成 toString 时不输出超类中的字段内容；</li><li>doNotUseGetters：默认为 false，表示获取字段值时通过 get 方法获取，设置为 true 表示直接通过字段获取；</li><li>onlyExplicitlyIncluded：默认为 false，表示在 toString 输出时输出全部非静态字段；设置为 true 时，表示只输出 @ToString.Include 标识的字段；</li><li>Exclude：标识属性，表示在 toString 输出时排除该字段；</li><li></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.ToString;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@ToString</span>(includeFieldNames = <span class="keyword">true</span>, exclude = &#123;<span class="string">"id"</span>, <span class="string">"name"</span>&#125;, of = &#123;&#125;, callSuper = <span class="keyword">true</span>, doNotUseGetters = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> student;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="EqualsAndHashCode"><a href="#EqualsAndHashCode" class="headerlink" title="@EqualsAndHashCode"></a>@EqualsAndHashCode</h2><p>@EqualsAndHashCode 标注于类之上用于生成hashCode方法和equals方法。</p><ul><li>exclude：字符串数组，表示在 toString 输出时排除掉字段名称；</li><li>of：</li><li>callSuper：默认为 false，表示生成 toString 时不输出超类中的字段内容；</li><li>doNotUseGetters：默认为 false，表示获取字段值时通过 get 方法获取，设置为 true 表示直接通过字段获取。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.EqualsAndHashCode;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@EqualsAndHashCode</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Data"><a href="#Data" class="headerlink" title="@Data"></a>@Data</h2><p>@Data 标注于类之上，是 @ToString、@EqualsAndHashCode、@Getter、@Setter、@RequiredArgsConstructor的综合体</p><ul><li>staticConstructor：类似于 @RequiredArgsConstructor 中 staticName 参数。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span>(staticConstructor = <span class="string">"of"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SneakyThrows"><a href="#SneakyThrows" class="headerlink" title="@SneakyThrows"></a>@SneakyThrows</h2><p>@SneakyThrows 标注于方法之上用于隐藏异常抛出语句。</p><h2 id="Log-日志"><a href="#Log-日志" class="headerlink" title="Log 日志"></a>Log 日志</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">lombok.extern.apachecommons.CommonsLog;</span><br><span class="line">lombok.extern.flogger.Flogger;</span><br><span class="line">lombok.extern.java.Log;</span><br><span class="line">lombok.extern.jbosslog.JBossLog;</span><br><span class="line">lombok.extern.log4j.Log4j;</span><br><span class="line">lombok.extern.log4j.Log4j2;</span><br><span class="line">lombok.extern.slf4j.Slf4j;</span><br><span class="line">lombok.extern.slf4j.XSlf4j;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://projectlombok.org/" target="_blank" rel="noopener">Project Lombok</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景描述&quot;&gt;&lt;a href=&quot;#背景描述&quot; class=&quot;headerlink&quot; title=&quot;背景描述&quot;&gt;&lt;/a&gt;背景描述&lt;/h2&gt;&lt;p&gt;最近一直在参与 &lt;a href=&quot;https://github.com/apache/incubator-shardingsphere&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ShardingSphere&lt;/a&gt; 开源项目的一些工作，在 ShardingSphere 项目中大量的使用了 &lt;a href=&quot;https://projectlombok.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Lombok&lt;/a&gt; 框架，对于 Lombok 框架只是有个大概了解，并没有实际的使用，也没有做过深入的研究，正好借参与 ShardingSphere 项目的机会对 Lombok 框架做一个学习和总结，先总结一下自己目前使用中遇到的问题，后续持续不断更新。&lt;/p&gt;
    
    </summary>
    
    
      <category term="web开发" scheme="https://dongzl.github.io/categories/web%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Lombok" scheme="https://dongzl.github.io/tags/Lombok/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 环境搭建 &amp; 常用插件集成</title>
    <link href="https://dongzl.github.io/2019/11/20/11-Hexo-Environment-Building/"/>
    <id>https://dongzl.github.io/2019/11/20/11-Hexo-Environment-Building/</id>
    <published>2019-11-20T11:12:09.000Z</published>
    <updated>2020-03-13T08:38:55.120Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景描述"><a href="#背景描述" class="headerlink" title="背景描述"></a>背景描述</h2><p>本文主要记录 Hexo 博客系统搭建过程，以及一些常用插件的集成和使用过程，后续会一直迭代更新。</p><a id="more"></a><h2 id="常用插件集成"><a href="#常用插件集成" class="headerlink" title="常用插件集成"></a>常用插件集成</h2><h3 id="PlantUml-安装使用"><a href="#PlantUml-安装使用" class="headerlink" title="PlantUml 安装使用"></a>PlantUml 安装使用</h3><p><strong>作用：</strong> 在 Hexo 中识别并生成由 flow 编写的图表。</p><p><strong>网址：</strong> <a href="http://plantuml.com/zh/" target="_blank" rel="noopener">http://plantuml.com/zh/</a></p><p><strong>Github地址：</strong> 暂无</p><p><strong>Hexo插件：</strong> <a href="https://github.com/two/hexo-tag-plantuml" target="_blank" rel="noopener">two/hexo-tag-plantuml</a></p><p><strong>Install：</strong> <code>npm hexo-tag-plantuml --save</code></p><p><strong>示例：</strong></p><img src="http://www.plantuml.com/plantuml/svg/JK_12i8m3BttAnuxku4UPGoy28BCYqSlTSrqeoJI1b7musqt1q8WoKjUtelfl8qHf-j8dQAkSIEcO3sQnYpWfonBx4Amx-CGrHWM9QWy8Fr2tEB06EtJha1F2czCPozCBoLs4NeV8eIf-h6BSmPIMFHUh0vyGnuKi17j-dzfAbFkX3b9aRkm2cAMIJPbqe_LJDmidgigD-qc5t_EvsVt8hE0frwtE34Ih73K3qnkjcw-"><h3 id="flowchart-安装使用"><a href="#flowchart-安装使用" class="headerlink" title="flowchart 安装使用"></a>flowchart 安装使用</h3><p><strong>作用：</strong> 在 Hexo 中识别并生成由 flow 编写的图表。</p><p><strong>网址：</strong> <a href="http://flowchart.js.org/" target="_blank" rel="noopener">http://flowchart.js.org/</a></p><p><strong>Github地址：</strong> <a href="https://github.com/adrai/flowchart.js" target="_blank" rel="noopener">adrai/flowchart.js</a></p><p><strong>Hexo插件：</strong> <a href="https://github.com/bubkoo/hexo-filter-flowchart" target="_blank" rel="noopener">bubkoo/hexo-filter-flowchart</a></p><p><strong>Install：</strong> <code>npm install hexo-filter-flowchart --save</code></p><p><strong>示例：</strong></p><div id="flowchart-0" class="flow-chart"></div><h3 id="mermaid-安装使用"><a href="#mermaid-安装使用" class="headerlink" title="mermaid 安装使用"></a>mermaid 安装使用</h3><p><strong>作用：</strong> 在 Hexo 中识别并生成由 mermaid 编写的图表。</p><p><strong>网址：</strong> <a href="https://mermaidjs.github.io/" target="_blank" rel="noopener">https://mermaidjs.github.io/</a></p><p><strong>Github地址：</strong> <a href="https://github.com/mermaid-js/mermaid" target="_blank" rel="noopener">mermaid-js/mermaid</a></p><p><strong>Hexo插件：</strong> <a href="https://github.com/webappdevelp/hexo-filter-mermaid-diagrams" target="_blank" rel="noopener">webappdevelp/hexo-filter-mermaid-diagrams</a></p><p><strong>Install：</strong> <code>npm install hexo-filter-mermaid-diagrams --save</code></p><p><strong>示例：</strong></p><pre class="mermaid">sequenceDiagramAlice->>John: Hello John, how are you?loop Healthcheck    John->>John: Fight against hypochondriaendNote right of John: Rational thoughts!John-->>Alice: Great!John->>Bob: How about you?Bob-->>John: Jolly good!</pre><pre class="mermaid">ganttsection SectionCompleted :done,    des1, 2014-01-06,2014-01-08Active        :active,  des2, 2014-01-07, 3dParallel 1   :         des3, after des1, 1dParallel 2   :         des4, after des1, 1dParallel 3   :         des5, after des3, 1dParallel 4   :         des6, after des4, 1d</pre><h3 id="MathJax-安装使用"><a href="#MathJax-安装使用" class="headerlink" title="MathJax 安装使用"></a>MathJax 安装使用</h3><p><strong>作用：</strong> MathJax is an open-source JavaScript display engine for LaTeX, MathML, and AsciiMath notation that works in all modern browsers.</p><p><strong>网址：</strong> <a href="https://www.mathjax.org/" target="_blank" rel="noopener">https://www.mathjax.org/</a></p><p><strong>Github地址：</strong> <a href="https://github.com/mathjax/MathJax" target="_blank" rel="noopener">mathjax/MathJax</a></p><p><strong>Hexo插件：</strong> <a href="https://github.com/phoenixcw/hexo-renderer-mathjax" target="_blank" rel="noopener">phoenixcw/hexo-renderer-mathjax</a> | <a href="https://github.com/hexojs/hexo-math" target="_blank" rel="noopener">hexojs/hexo-math</a></p><p><strong>Install：</strong> <code>npm install hexo-renderer-mathjax --save</code> | <code>npm install hexo-math --save</code></p><p><font color="red"><strong>PS. 对于 MathJax 功能的支持，有一些不同的 hexo 插件，根据使用的插件不同需要不同的配置。我使用的 <a href="https://github.com/sanonz/hexo-theme-concise" target="_blank" rel="noopener">hexo-theme-concise</a> 主题，在这个 issue 中解决了 MathJax 支持问题：<a href="https://github.com/sanonz/hexo-theme-concise/issues/33" target="_blank" rel="noopener">issue33</a></strong></font></p><p><strong>示例：</strong></p><ul><li><p>行内表达式：</p><ul><li><p>$MEMORY*(单节点总核数/NPROC)\leq单节点总内存$</p></li><li><p>$f(x_1,x_x,\ldots,x_n) = x_1^2 + x_2^2 + \cdots + x_n^2$</p></li><li><p>$a = b + c$</p></li><li><p>$F_a = F_b + F_c + F_{\mu}$</p></li></ul></li><li><p>块表达式：</p><ul><li><p>$$ x = {-b \pm \sqrt{b^2-4ac} \over 2a} $$</p></li><li><p>$$ f(x_1,x_x,\ldots,x_n) = x_1^2 + x_2^2 + \cdots + x_n^2 $$</p></li><li><p>$$f(x) = 3x + 7$$</p></li><li><p>$$\frac{\partial u}{\partial t}<br>= h^2 \left( \frac{\partial^2 u}{\partial x^2} +<br>\frac{\partial^2 u}{\partial y^2} +<br>\frac{\partial^2 u}{\partial z^2}\right)$$</p></li><li><p>$$lim_{1\to+\infty}P(|\frac{1}{n}\sum_i^nX_i-\mu|&lt;\epsilon)=1, i=1,…,n$$</p></li></ul></li></ul><h3 id="hexo-pdf-安装使用"><a href="#hexo-pdf-安装使用" class="headerlink" title="hexo-pdf 安装使用"></a>hexo-pdf 安装使用</h3><p><strong>作用：</strong> 在 Hexo 中展示 PDF 文件内容。</p><p><strong>网址：</strong> 暂无</p><p><strong>Github地址：</strong> 暂无</p><p><strong>Hexo插件：</strong> <a href="https://github.com/superalsrk/hexo-pdf" target="_blank" rel="noopener">superalsrk/hexo-pdf</a></p><p><strong>Install：</strong> <code>npm install --save hexo-pdf</code></p><p><strong>示例：</strong></p><ul><li><p>Normal PDF</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% pdf http://7xov2f.com1.z0.glb.clouddn.com/bash_freshman.pdf %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% pdf ./bash_freshman.pdf %&#125;</span><br></pre></td></tr></table></figure></li><li><p>Google drive</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% pdf https://drive.google.com/file/d/0B6qSwdwPxPRdTEliX0dhQ2JfUEU/preview %&#125;</span><br></pre></td></tr></table></figure></li><li><p>Slideshare</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% pdf http://www.slideshare.net/slideshow/embed_code/key/8Jl0hUt2OKUOOE %&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.jianshu.com/p/7ab21c7f0674" target="_blank" rel="noopener">在Hexo中渲染MathJax数学公式</a></li><li><a href="https://segmentfault.com/a/1190000020123689?utm_source=tag-newest" target="_blank" rel="noopener">在Hexo中使用Markdown绘制图表</a></li><li><a href="https://blog.csdn.net/u014630987/article/details/78670258" target="_blank" rel="noopener">如何在 hexo 中支持 Mathjax？</a></li><li><a href="https://blog.csdn.net/crazy_scott/article/details/79293576" target="_blank" rel="noopener">hexo下LaTeX无法显示的解决方案</a></li><li><a href="https://www.jianshu.com/p/7f10f51bce47" target="_blank" rel="noopener">hexo 博客添加 pdf 插件</a></li></ul><script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">st=>start: Start|past:>http://www.google.com[blank]e=>end: End:>http://www.google.comop1=>operation: My Operation|pastop2=>operation: Stuff|currentsub1=>subroutine: My Subroutine|invalidcond=>condition: Yesor No?|approved:>http://www.google.comc2=>condition: Good idea|rejectedio=>inputoutput: catch something...|requestst->op1(right)->condcond(yes, right)->c2cond(no)->sub1(left)->op1c2(yes)->io->ec2(no)->op2->e</textarea><textarea id="flowchart-0-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景描述&quot;&gt;&lt;a href=&quot;#背景描述&quot; class=&quot;headerlink&quot; title=&quot;背景描述&quot;&gt;&lt;/a&gt;背景描述&lt;/h2&gt;&lt;p&gt;本文主要记录 Hexo 博客系统搭建过程，以及一些常用插件的集成和使用过程，后续会一直迭代更新。&lt;/p&gt;
    
    </summary>
    
    
      <category term="其他" scheme="https://dongzl.github.io/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="Hexo" scheme="https://dongzl.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>10-MySQL-InnoDB-Transaction</title>
    <link href="https://dongzl.github.io/2019/11/19/10-MySQL-InnoDB-Transaction/"/>
    <id>https://dongzl.github.io/2019/11/19/10-MySQL-InnoDB-Transaction/</id>
    <published>2019-11-19T11:08:31.000Z</published>
    <updated>2020-03-10T01:08:49.055Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景描述"><a href="#背景描述" class="headerlink" title="背景描述"></a>背景描述</h2><p>目前在维护的 APP 进行了整体重构（其实不能算重构，应该是重新开发），新的服务端系统根据业务场景进行了功能拆分，实现了微服务，结束了以前服务端大一统的部署模式；伴随着微服务的上线，分布式事务也成了一个绕不开的问题。最近的几篇文章计划结合目前项目中的分布式事务的代码实现逻辑，对数据库事务的知识进行系统的学习和整理，当然数据库事务方面的知识很多，所以肯定不是一篇文章可以搞定的，<strong>分布式</strong> 就是要 <strong>“分布试”</strong>。</p><p><strong>PS.数据库事务的知识有哪些，一起来整理一下，今天先以 MySQL 数据库 InnoDB 存储引擎为例，总结一下单数据库事务。</strong></p><a id="more"></a><h2 id="事务的ACID特性"><a href="#事务的ACID特性" class="headerlink" title="事务的ACID特性"></a>事务的ACID特性</h2><h3 id="A：原子性（Atomicity）"><a href="#A：原子性（Atomicity）" class="headerlink" title="A：原子性（Atomicity）"></a>A：原子性（Atomicity）</h3><p>事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。</p><h3 id="C：一致性（Consistency）"><a href="#C：一致性（Consistency）" class="headerlink" title="C：一致性（Consistency）"></a>C：一致性（Consistency）</h3><p>一致性指事务将数据库从一种状态转变为下一种一致的状态。在事务开始之前和事务结束之后，数据库的完整性约束没有被破坏。在一致性状态下，所有事务对一个数据的读取结果都是相同的。</p><h3 id="I：隔离性（Isolation）"><a href="#I：隔离性（Isolation）" class="headerlink" title="I：隔离性（Isolation）"></a>I：隔离性（Isolation）</h3><p>一个事务所做的修改在最终提交以前，对其它事务是不可见的。</p><h3 id="D：持久性（Durability）"><a href="#D：持久性（Durability）" class="headerlink" title="D：持久性（Durability）"></a>D：持久性（Durability）</h3><p>一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务的执行结果页不能丢失。</p><h2 id="事务的并发一致性问题"><a href="#事务的并发一致性问题" class="headerlink" title="事务的并发一致性问题"></a>事务的并发一致性问题</h2><h3 id="丢失更新"><a href="#丢失更新" class="headerlink" title="丢失更新"></a>丢失更新</h3><h4 id="第一类丢失更新"><a href="#第一类丢失更新" class="headerlink" title="第一类丢失更新"></a>第一类丢失更新</h4><p>一个事务（A）更新某条记录数据，此时还未提交，这时另外一个事务（B）也更新了该记录数据并提交事务成功，这时 A 撤销事务，此时 B 更新成功的数据会丢失。</p><table><thead><tr><th>时间</th><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td>T1</td><td>开启事务</td><td></td></tr><tr><td>T2</td><td></td><td>开启事务</td></tr><tr><td>T3</td><td>查询账户余额为 100</td><td></td></tr><tr><td>T4</td><td></td><td>查询账户余额为 100</td></tr><tr><td>T5</td><td></td><td>更新数据 + 10 结果为 110</td></tr><tr><td>T6</td><td></td><td>提交事务</td></tr><tr><td>T7</td><td>更新数据 - 10 结果为 90</td><td></td></tr><tr><td>T8</td><td>撤销事务</td><td></td></tr><tr><td>T7</td><td>数据恢复为100（丢失更新）</td><td></td></tr></tbody></table><h4 id="第二类丢失更新"><a href="#第二类丢失更新" class="headerlink" title="第二类丢失更新"></a>第二类丢失更新</h4><p>一个事务（A）更新某条记录数据，此时还未提交，这时另外一个事务（B）也更新了该记录数据并提交事务成功，此时 A 提交事务，此时 B 更新成功的数据会丢失。</p><table><thead><tr><th>时间</th><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td>T1</td><td>开启事务</td><td></td></tr><tr><td>T2</td><td></td><td>开启事务</td></tr><tr><td>T3</td><td>查询账户余额为100</td><td></td></tr><tr><td>T4</td><td></td><td>查询账户余额为100</td></tr><tr><td>T5</td><td></td><td>更新数据 - 10 结果为 90</td></tr><tr><td>T6</td><td></td><td>提交事务</td></tr><tr><td>T7</td><td>更新数据 + 10 结果 为 110</td><td></td></tr><tr><td>T8</td><td>提交事务</td><td></td></tr><tr><td>T7</td><td>数据结果为110（丢失更新）</td><td></td></tr></tbody></table><h3 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h3><p>脏读是指一个事务读取到了另外一个事务未提交的数据。一个事务正在对一条记录进行修改，在这个事务提交并完成前，这条记录的数据就处于不一致状态。这时， 另一个事务也来读取同一条记录，如果不加控制，第二个事务读取了这些“脏”数据，并据此做进一步的处理，就会产生未提交的数据依赖关系。</p><table><thead><tr><th>时间</th><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td>T1</td><td>开启事务</td><td></td></tr><tr><td>T2</td><td>查询账户余额为100</td><td>开启事务</td></tr><tr><td>T3</td><td>充值50，余额修改为150</td><td></td></tr><tr><td>T4</td><td></td><td>查询余额为150</td></tr><tr><td>T5</td><td>撤销事务，余额改回100</td><td></td></tr><tr><td>T6</td><td></td><td>汇入50，余额修改为200</td></tr><tr><td>T7</td><td></td><td>提交事务</td></tr></tbody></table><h3 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h3><p>不可重复读是指一个事务读取到了另外一个事务已提交的数据。一个事务（A）读取某一个数据后，另外一个事务（B）对该数据进行了修改，当 A 再读取这个数据时，发现前后两次读取的数据不一致。</p><table><thead><tr><th>时间</th><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td>T1</td><td>开启事务</td><td></td></tr><tr><td>T2</td><td>查询账户余额为100</td><td>开启事务</td></tr><tr><td>T3</td><td></td><td>更新账户余额为150</td></tr><tr><td>T4</td><td></td><td>提交事务</td></tr><tr><td>T5</td><td>查询账户余额为150</td><td></td></tr><tr><td>T6</td><td>…</td><td></td></tr><tr><td>T7</td><td>提交事务</td><td></td></tr></tbody></table><h3 id="幻读（幻影读）"><a href="#幻读（幻影读）" class="headerlink" title="幻读（幻影读）"></a>幻读（幻影读）</h3><p>一个事务（A）按某一条件检索到 N 条数据，另外一个事务（B）新增或删除了满足条件的数据，这时 A 再按相同条件检索数据，查询到的结果 != N。</p><table><thead><tr><th>时间</th><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td>T1</td><td>开启事务</td><td>开启事务</td></tr><tr><td>T2</td><td>select * from table where condition = ‘xxx’ 返回 N 条记录</td><td></td></tr><tr><td>T3</td><td></td><td>向 table 表插入一条满足 condition = ‘xxx’ 的数据</td></tr><tr><td>T4</td><td></td><td>提交事务</td></tr><tr><td>T5</td><td>select * from table where condition = ‘xxx’ 返回 N + 1 条记录</td><td></td></tr><tr><td>T6</td><td>…</td><td></td></tr><tr><td>T7</td><td>提交事务</td><td></td></tr></tbody></table><h3 id="总结说明"><a href="#总结说明" class="headerlink" title="总结说明"></a>总结说明</h3><ul><li><p>幻读和不可重复读的区别：</p><ul><li>不可重复读的重点是更新：在同一事务中，相同的条件，第一次和第二次读取到的数据不一致（中间有其它事务提交了更新）；</li><li>幻读的重点是新增或删除：在同一事务中，相同的条件，第一次和第二次读到的记录数据不一样（中间有其它事务提交了新增或者删除）。</li></ul></li><li><p>两类丢失更新问题：</p><ul><li>第一类丢失更新 （通过设置 <strong>Repeatable Read</strong> 隔离级别解决）</li><li>第二类丢失更新 （需要应用程序控制，使用乐观锁解决）</li></ul></li></ul><h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><p>SQL 标准定义了四种数据库事务的隔离级别，每一种级别中都规定了一个事务中所做的修改，哪些在事务内和事务间是可见的，哪些是不可见的。</p><ul><li>Read Uncommitted：所有事务都可以看到其它事务未提交的执行结果。</li><li>Read Committed（RC）：一个事务能够看到其它事务已提交的执行结果。</li><li>Repeatable Read（RR）：在一个事务内多次执行同一个查询操作，前后几次获取的结果相同。</li><li>Serializable：串行化，每次读都需要获得表级共享锁，读写相互阻塞。</li></ul><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>Read Uncommitted</td><td>YES</td><td>YES</td><td>YES</td></tr><tr><td>Read Committed</td><td>NO</td><td>YES</td><td>YES</td></tr><tr><td>Repeatable Read</td><td>NO</td><td>NO</td><td>YES</td></tr><tr><td>Serializable</td><td>NO</td><td>NO</td><td>NO</td></tr></tbody></table><p>四种数据库事务的隔离级别只是 SQL 标准的定义，对于不同的数据库也会有不同的实现，比如：Oracle 仅支持 Read Committed 和 Serializable 隔离级别，其中 Read Committed 是默认的隔离级别；对于 MySQL 支持 SQL 标准的四种隔离级别，其中 Repeatable Read 为默认的隔离级别。</p><p><a href="https://github.com/ctripcorp/apollo/wiki/Java%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97#1241-environment" target="_blank" rel="noopener">https://github.com/ctripcorp/apollo/wiki/Java%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97#1241-environment</a></p><p><a href="https://github.com/ctripcorp/apollo/wiki/Apollo%E5%BC%80%E6%94%BE%E5%B9%B3%E5%8F%B0" target="_blank" rel="noopener">https://github.com/ctripcorp/apollo/wiki/Apollo%E5%BC%80%E6%94%BE%E5%B9%B3%E5%8F%B0</a></p><p><a href="https://www.jianshu.com/p/03d1bf80f7e8" target="_blank" rel="noopener">https://www.jianshu.com/p/03d1bf80f7e8</a></p><p><a href="https://blog.csdn.net/z69183787/article/details/52213670" target="_blank" rel="noopener">https://blog.csdn.net/z69183787/article/details/52213670</a></p><p><a href="https://www.jianshu.com/p/592b2cdbc589" target="_blank" rel="noopener">https://www.jianshu.com/p/592b2cdbc589</a></p><p><a href="https://www.jianshu.com/p/d829df873332" target="_blank" rel="noopener">https://www.jianshu.com/p/d829df873332</a></p><p><a href="https://blog.csdn.net/weixin_28760063/article/details/81369266" target="_blank" rel="noopener">https://blog.csdn.net/weixin_28760063/article/details/81369266</a></p><p><a href="https://juejin.im/post/5b5a0bf9f265da0f6523913b" target="_blank" rel="noopener">https://juejin.im/post/5b5a0bf9f265da0f6523913b</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景描述&quot;&gt;&lt;a href=&quot;#背景描述&quot; class=&quot;headerlink&quot; title=&quot;背景描述&quot;&gt;&lt;/a&gt;背景描述&lt;/h2&gt;&lt;p&gt;目前在维护的 APP 进行了整体重构（其实不能算重构，应该是重新开发），新的服务端系统根据业务场景进行了功能拆分，实现了微服务，结束了以前服务端大一统的部署模式；伴随着微服务的上线，分布式事务也成了一个绕不开的问题。最近的几篇文章计划结合目前项目中的分布式事务的代码实现逻辑，对数据库事务的知识进行系统的学习和整理，当然数据库事务方面的知识很多，所以肯定不是一篇文章可以搞定的，&lt;strong&gt;分布式&lt;/strong&gt; 就是要 &lt;strong&gt;“分布试”&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;PS.数据库事务的知识有哪些，一起来整理一下，今天先以 MySQL 数据库 InnoDB 存储引擎为例，总结一下单数据库事务。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="https://dongzl.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库事务" scheme="https://dongzl.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/"/>
    
      <category term="ACID" scheme="https://dongzl.github.io/tags/ACID/"/>
    
  </entry>
  
  <entry>
    <title>从一个功能设计聊聊策略模式的使用</title>
    <link href="https://dongzl.github.io/2019/11/06/09-design-pattern-strategy/"/>
    <id>https://dongzl.github.io/2019/11/06/09-design-pattern-strategy/</id>
    <published>2019-11-06T08:25:58.000Z</published>
    <updated>2020-03-10T01:11:40.249Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景描述"><a href="#背景描述" class="headerlink" title="背景描述"></a>背景描述</h2><p>线上业务销售一种 VIP 虚拟卡，对于已售出的 VIP 虚拟卡在给供应商结算时需要根据销售渠道不同进行区分，例如，Android 端销售的虚拟卡按实际销售金额结算；iOS端销售的虚拟卡按实际销售金额 70% 结算（做苹果开发的都知道，苹果公司雁过拔毛，要拔走 30%）；还有就是可能与其他商品捆绑销售，捆绑销售的金额根据合作不同部门、不同商品金额都不同。目前情况即是如此，虚拟卡销售渠道很多，不同渠道结算金额不同，而且还会扩展（最近就在经历扩展，华为属于 Android 渠道，但是也开始玩苹果那套规则，拔 30% 的毛）。</p><p><strong>PS. 一句话需求，销售商品结算，不同销售渠道销售金额不同，而且随时会扩展新的渠道。</strong></p><a id="more"></a><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>如果设计模式玩溜了，对于这种业务场景，很容易想到使用策略（Strategy）模式来完成功能，所以这里也直接上代码实现：</p><h3 id="策略接口定义"><a href="#策略接口定义" class="headerlink" title="策略接口定义"></a>策略接口定义</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CalculateStrategy</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算金额</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> param 参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 计算结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">calculate</span><span class="params">(StrategyParam param)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="策略实现类"><a href="#策略实现类" class="headerlink" title="策略实现类"></a>策略实现类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Android 渠道结算策略</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AndroidVipOrderStrategy</span> <span class="keyword">implements</span> <span class="title">CalculateStrategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">calculate</span><span class="params">(StrategyParam param)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Order order = queryOrder(param);</span><br><span class="line">        <span class="keyword">return</span> order.getOnlineAmount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// iOS 渠道结算策略</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IOSVipOrderStrategy</span> <span class="keyword">implements</span> <span class="title">CalculateStrategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">calculate</span><span class="params">(StrategyParam param)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Order order = queryOrder(param);</span><br><span class="line">        <span class="keyword">return</span> order.getOnlineAmount * <span class="number">0.7</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 捆绑组合渠道结算策略</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BindVipOrderStrategy</span> <span class="keyword">implements</span> <span class="title">CalculateStrategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">calculate</span><span class="params">(StrategyParam param)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">199</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="策略Context类"><a href="#策略Context类" class="headerlink" title="策略Context类"></a>策略Context类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrategyContext</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> StrategyParam param;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StrategyContext</span><span class="params">(StrategyParam param)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.param = param;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">calculate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CalculateStrategy result = getStrategy();</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.calculate(param);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CalculateStrategy <span class="title">getStrategy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CalculateStrategy result = <span class="keyword">null</span>;</span><br><span class="line">        SourceTypeEnum type = SourceTypeEnum.valueOf(param.getVipSourceType());</span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">            <span class="keyword">case</span> ANDROID:</span><br><span class="line">                result = <span class="keyword">new</span> AndroidVipOrderStrategy();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> IOS:</span><br><span class="line">                result = <span class="keyword">new</span> IOSVipOrderStrategy();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> BIND:</span><br><span class="line">                result = <span class="keyword">new</span> BindVipOrderStrategy();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="客户端调用"><a href="#客户端调用" class="headerlink" title="客户端调用"></a>客户端调用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        StrategyParam param = <span class="keyword">new</span> StrategyParam();</span><br><span class="line">        System.out.println(<span class="keyword">new</span> StrategyContext(param).calculate());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类图描述"><a href="#类图描述" class="headerlink" title="类图描述"></a>类图描述</h3><img src="https://gitee.com/dongzl/article-images/raw/master/2019/09-design-pattern-strategy/Design_Pattern_Strategy_01.png" width="600px"><h2 id="观察者模式的四要素"><a href="#观察者模式的四要素" class="headerlink" title="观察者模式的四要素"></a>观察者模式的四要素</h2><h3 id="定义与动机"><a href="#定义与动机" class="headerlink" title="定义与动机"></a>定义与动机</h3><p><strong>定义：</strong> </p><p>策略模式（Strategy Pattern）：定义<strong>一系列算法</strong>，将<strong>每一个算法封装起来</strong>，并让他们可以<strong>相互替换</strong>。策略模式<strong>让算法独立于使用它的客户端而变化</strong>，也称为<strong>政策模式</strong>（Policy）。策略模式是一种<strong>对象行为型</strong>模式。</p><p>Strategy Pattern: Define <strong>a family of algorithms</strong>, <strong>encapsulate each one</strong>, and <strong>make them interchangeable</strong>. Strategy lets the algorithm vary independently from clients that use it.</p><p><strong>动机：</strong></p><p>完成一项任务，往往可以有很多种不同的方式，<font color="red">每一种方式称为一个策略</font>，我们<font color="red">可以根据环境或者条件的不同选择不同的策略来完成任务</font>。</p><p>为了解决这些问题，<font color="red">可以定义一些独立的类来封装不同的算法，每一个类封装一个具体的算法</font>。在这里，<font color="red">每一个封装算法的类我们都可以称之为策略（Strategy）</font>，为了保证这些策略的一致性，一般会用一个<font color="red">抽象的策略类来做算法的定义，而具体每种算法则对应于一个具体策略类</font>。</p><h3 id="结构与分析"><a href="#结构与分析" class="headerlink" title="结构与分析"></a>结构与分析</h3><p><strong>模式结构：</strong></p><p>类图：</p><img src="https://gitee.com/dongzl/article-images/raw/master/2019/09-design-pattern-strategy/Design_Pattern_Strategy_02.png" width="600px"><ul><li>Context封装角色：上下文角色，起承上启下封装作用，屏蔽高层模块对策略、算法的直接访问，封装可能存在的变化。</li><li>Strategy抽象策略角色：策略、算法家族的抽象，通常为接口，定义每个策略或算法必须具有的方法和属性。</li><li>ConcreteStratrgy具体策略角色：实现抽象策略中的操作，该类含有具体的算法。</li></ul><h3 id="优点-amp-缺点"><a href="#优点-amp-缺点" class="headerlink" title="优点 &amp; 缺点"></a>优点 &amp; 缺点</h3><p><strong>优点：</strong></p><ul><li>对“<strong>开闭原则</strong>”的完美支持，可以在不修改原有系统的基础上灵活的增加新的算法和行为；</li><li>策略模式<strong>提供了管理相关算法族的办法</strong>；</li><li>策略模式<strong>提供了可以替换继承关系的办法</strong>；</li><li>策略模式<strong>可以避免使用多重条件转移语句</strong>。</li></ul><p><strong>缺点：</strong></p><ul><li>客户端<strong>必须知道所有的策略类</strong>；</li><li>策略模式<strong>将产生很多策略类</strong>。</li></ul><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>可以在以下情况中选择使用粗略模式：</p><ul><li>如果在一个系统里面有很多类，<strong>它们之间的区别仅在于它们的行为</strong>，那么使用策略模式可以动态的让一个对象在许多行为中选择一种行为。</li><li>一个系统<strong>需要动态地在几种算法中选择一种</strong>。</li><li>如果<strong>一个对象有很多的行为</strong>，如果不用恰当的模式，这些行为就只好使用<strong>多重的条件选择语句</strong>来实现。</li><li>不希望客户端知道复杂的、与算法相关的数据结构，<strong>在具体策略类中封装算法和相关的数据结构</strong>，提高算法的保密性与安全性。</li></ul><h2 id="策略模式的扩展-枚举策略"><a href="#策略模式的扩展-枚举策略" class="headerlink" title="策略模式的扩展-枚举策略"></a>策略模式的扩展-枚举策略</h2><h3 id="枚举类定义"><a href="#枚举类定义" class="headerlink" title="枚举类定义"></a>枚举类定义</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> CalculateStrategy &#123;</span><br><span class="line"></span><br><span class="line">    ANDROID_VIP_ORDER &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">calculate</span><span class="params">(StrategyParam param)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            Order order = queryOrder(param);</span><br><span class="line">            <span class="keyword">return</span> order.getOnlineAmount;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    IOS_VIP_ORDER &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">calculate</span><span class="params">(StrategyParam param)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            Order order = queryOrder(param);</span><br><span class="line">            <span class="keyword">return</span> order.getOnlineAmount * <span class="number">0.7</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    BINDVIPORDER &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">calculate</span><span class="params">(StrategyParam param)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">199</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算金额</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> param 参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 计算结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Integer <span class="title">calculate</span><span class="params">(StrategyParam param)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Client调用类"><a href="#Client调用类" class="headerlink" title="Client调用类"></a>Client调用类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Integer result = CalculateStrategy.ANDROID_VIP_ORDER.calculate(<span class="keyword">new</span> StrategyParam());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://mp.weixin.qq.com/s/VSjVx5kf-Rc7QifEs4xf6A" target="_blank" rel="noopener">业务复杂=if else？刚来的大神竟然用策略+工厂彻底干掉了他们！</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景描述&quot;&gt;&lt;a href=&quot;#背景描述&quot; class=&quot;headerlink&quot; title=&quot;背景描述&quot;&gt;&lt;/a&gt;背景描述&lt;/h2&gt;&lt;p&gt;线上业务销售一种 VIP 虚拟卡，对于已售出的 VIP 虚拟卡在给供应商结算时需要根据销售渠道不同进行区分，例如，Android 端销售的虚拟卡按实际销售金额结算；iOS端销售的虚拟卡按实际销售金额 70% 结算（做苹果开发的都知道，苹果公司雁过拔毛，要拔走 30%）；还有就是可能与其他商品捆绑销售，捆绑销售的金额根据合作不同部门、不同商品金额都不同。目前情况即是如此，虚拟卡销售渠道很多，不同渠道结算金额不同，而且还会扩展（最近就在经历扩展，华为属于 Android 渠道，但是也开始玩苹果那套规则，拔 30% 的毛）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;PS. 一句话需求，销售商品结算，不同销售渠道销售金额不同，而且随时会扩展新的渠道。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="https://dongzl.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://dongzl.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="策略模式" scheme="https://dongzl.github.io/tags/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>GRIT：一种微服务场景下分布式事务协议实现</title>
    <link href="https://dongzl.github.io/2019/10/29/08-GRIT-Microservices-Distributed-Transactions-Protocol/"/>
    <id>https://dongzl.github.io/2019/10/29/08-GRIT-Microservices-Distributed-Transactions-Protocol/</id>
    <published>2019-10-29T01:42:47.000Z</published>
    <updated>2020-03-10T02:16:01.100Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文链接：<a href="https://tech.ebayinc.com/engineering/grit-a-protocol-for-distributed-transactions-across-microservices/" target="_blank" rel="noopener">https://tech.ebayinc.com/engineering/grit-a-protocol-for-distributed-transactions-across-microservices/</a></p></blockquote><blockquote><p>eBay 技术人员最近发布了一种称为 <code>GRIT</code> 分布式事务协议，该协议是为了解决跨多个底层数据库的微服务场景下分布式 ACID（原子性，一致性，隔离性，持久性）事务问题。</p></blockquote><p>本文描述了在 <strong>IEEE国际数据工程会议(ICDE) 2019</strong> 上发布的 GRIT 协议的基本思想，<font color="red">并且提供了一个 JanusGraph 事务性存储后端的示例，该示例实现了 GRIT 协议的一部分功能</font>。这个示例关注的是仅有单一数据库的应用，但是正如我们所说，GRIT 可以支持由多个数据库组成的系统的 ACID 事务。</p><a id="more"></a><h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>在 <a href="https://en.wikipedia.org/wiki/Microservices" target="_blank" rel="noopener">微服务</a> 架构中，应用程序可能会调用很多个微服务，通常这些微服务是用不同编程语言实现并且由不同的团队来维护，而且可能会使用多个数据库来实现微服务的功能。这种目前流行的架构为跨多个微服务的一致性分布式事务带来了新的挑战。支持微服务场景下的 ACID 事务是有实际需要的，但是在现有技术下实现起来是非常困难的，因为被设计用于单个数据库的分布式事务机制无法通过微服务架构轻松扩展到具有多个数据库的情况。</p><p>在涉及多个独立数据库的运行环境中，传统的两阶段提交（2PC）协议[1]从本质上来说是唯一一种能够实现分布式事务功能而不会给应用系统带来额外工作量的方式。然而，由于可能存在多个协调参与者而导致的较长调用链路以及在各个阶段所需要的资源锁定，所以它在横向扩展平台中工作的并不好。另一方面，引入第三方框架[2]（例如：Saga）执行事务日志的方式将导致应用程序产生复杂的事务补偿逻辑；并且由于已经部分执行成功的事务有可能是不可逆的，所以会对业务逻辑产生影响。</p><p>为了解决这些问题，我们开发了 <a href="https://ieeexplore.ieee.org/abstract/document/8731442" target="_blank" rel="noopener">GRIT</a>，一种用于全局一致性分布式事务的新协议，这个协议巧妙地结合了乐观并发控制（OCC）[3]、2PC 和 确定性数据库[4,5]的思想，首次实现了高性能，跨多个基础数据库微服务的全局一致性事务。</p><h2 id="GRIT-一种分布式事务协议实现"><a href="#GRIT-一种分布式事务协议实现" class="headerlink" title="GRIT: 一种分布式事务协议实现"></a>GRIT: 一种分布式事务协议实现</h2><p>下图描述了 GRIT 协议在两个数据库的微服务环境中的使用。GRIT 组件中包含了在图中中间部分显示的 GTM、GPL、DBTM、DBTL 和 LogPlayer 等组件。</p><img src="https://gitee.com/dongzl/article-images/raw/master/2019/08-GRIT-Microservices-Distributed-Transactions-Protocol/GRIT-Protocol-for-Distributed-Transactions-across-Microservices6.png"><p>图中除去 GRIT 相关组件，剩余部分是一个横向扩展的两个数据库组成的微服务架构系统。它包括如下组成部分：</p><ol><li>应用程序：调用微服务来实现相关功能。</li><li>微服务（实体服务）：为应用程序提供面向业务的服务以实现业务逻辑的功能模块。每个数据库可能要支持多个微服务，并且每个微服务可能彼此都是独立的。</li><li>数据库服务：提供数据库 <code>读/写</code> 接口，可以直接访问数据库服务器。当支持事务时，它会缓存每次事务在执行阶段数据的 <code>读/写结果集</code>，并在提交时将其发送到 DBTM 用于解决冲突。</li><li>数据库分片服务：数据库后台的存储服务，通过复制机制实现数据库高可用。</li></ol><p>GRIT 包含的关键组件：</p><ol><li>全局事务管理器（GTM）：它用来协调跨多个数据库的全局事务。可以同时存在一个或多个 GTM。</li><li>全局事务日志（GTL）：对于 GTM 来说，GTL 表示事务的请求队列。GTL 中事务的请求顺序决定了全局事务之间的相对可串行化顺序。全局事务日志数据的持久化是可选的。</li><li>数据库事务管理器（DBTM）：DBTM 是每个数据库内部的事务管理器。它用来执行冲突检查并解决冲突问题，即本地事务提交就是在这里完成。</li><li>数据库事务日志（DBTL）：DBTL 是每个数据库内部的事务日志，它用于记录与此数据库相关逻辑事务提交（包括单个数据库事务和多个数据库事务）。在 DBTL 中事务的顺序决定了整个数据库应用的可串行化顺序，包括 GTM 所保证的全局顺序。需要为每个日志条目分配一个日志序列号（LSN）。</li><li>日志播放器（LogPlayer）：这个组件将用于更新数据的日志条目按顺序发送到后端存储服务器。每一个数据库服务按顺序使用日志条目数据进行逻辑事务提交。</li></ol><p>为了更好的理解 GRIT 协议的实现细节，我们用下图来演示分布式事务的主要步骤：</p><img src="https://gitee.com/dongzl/article-images/raw/master/2019/08-GRIT-Microservices-Distributed-Transactions-Protocol/GRIT-main-steps2.png"><p>在 GRIT 中，一个分布式事务要经历三个步骤：</p><ol><li>乐观执行（步骤 1-4）：应用程序通过调用微服务来执行业务逻辑，数据库服务捕捉事务的 <code>读/写结果集</code>。在这个环节没有实际的数据修改发生。</li><li>逻辑提交（步骤 5-11）：一旦应用程序发送提交事务请求，每一个数据库服务节点将 <code>读/写结果集</code> 提交到它对应的 DBTM。DBTM 使用 <code>读/写结果集</code> 进行冲突检查，以实现本地提交决策。GTM 在收集到所有 DBTM 对事务的本地决策之后，做出全局提交决策。一旦事务的 <code>写结果集</code> 被持久化到所对应的数据库的日志存储（DBTL）中，事务就会进行逻辑提交。这涉及到 GTM 和 DBTM 之间的最小协调。</li><li>物理应用（步骤 12-13）：日志播放器异步发送 DBTL 条目到后端存储服务器。数据修改发生在这个阶段。</li></ol><p>总体来说，我们的方案避免了执行和提交过程中的悲观锁定，同时避免了物理提交等待。我们采用乐观锁的方案，通过利用逻辑提交日志，并使用确定性数据库技术将物理数据库更新操作从提交决策过程中移出，使提交过程更加高效，这类似于复制中的日志播放。</p><p>GRIT 能够为调用微服务的应用程序实现一致性的高吞吐量和可串行化的分布式事务，并保证最小范围协调性。GRIT 非常适合冲突较少的事务，并为那些需要复杂机制以在具有多个底层数据库的微服务之间实现一致性事务的应用程序提供了关键功能。</p><h2 id="在单一数据库中应用-GRIT"><a href="#在单一数据库中应用-GRIT" class="headerlink" title="在单一数据库中应用 GRIT"></a>在单一数据库中应用 GRIT</h2><p>正如你所了解到的，GRIT 协议包含两部分：<font color="red">其中一部分是用于 DBTM、DBTL 和 LogPlayer 操作的，这是每个数据库（或是每个数据库内部，可以是数据库的一组分区）提供的；另外一部分是用于 GTM 和 DBTM 操作的跨数据库协调。</font>在下图中，我们演示了使用了单个数据库的 GRIT 部分协议为 <a href="https://janusgraph.org/" target="_blank" rel="noopener">JanusGraph</a> 设计的事务图形存储后端（称为 NuGraphStore）。</p><p>下图显示了如何使用两个可用区域（AZ1 和 AZ2）部署来实现 NuGraphStore。</p><img src="https://gitee.com/dongzl/article-images/raw/master/2019/08-GRIT-Microservices-Distributed-Transactions-Protocol/GRIT-Protocol-for-Distributed-Transactions-across-Microservices4.png"><p>JanusGraph 的 NuGraphStore 存储后端包含了以下几个组件：</p><ul><li>存储插件（Storage plugin）：一个自定义的存储接口插件，用于 JanusGraph 数据库层、后端存储引擎和事务协议组件之间的接口。</li><li>DBTM：为乐观并发控制提供关键地冲突检查。这是分布式事务协议 <a href="https://ieeexplore.ieee.org/abstract/document/8731442" target="_blank" rel="noopener">GRIT</a> 在单个数据库乐观并发控制中的组成部分。</li><li>日志存储：事务中的变更数据的复制日志存储。每个事务一个条目，由日志序列号（LSN）索引。它在传统数据系统中充当 WAL（预写日志）角色。LogStore 就是 GRIT 架构中的 DBTL 部分。</li><li>LogPlayer：在后端服务器中异步的执行日志条目。</li><li>存储引擎：用于存储 JanusGraph 中的KCV（键-列-值）数据的后端存储引擎。它执行读取和变更操作，并支持 LSN 定义的快照。</li></ul><p>当一个应用程序执行事务时，它可以从存储层读取数据，也可以向存储层写入数据。对于读取数据操作，存储插件直接和存储服务器进行交互（要读取的数据在事务的 <code>写结果集</code> 这种情况除外）。当应用程序在事务上下文环境中从存储层读取数据时，存储插件也会对 <code>读结果集</code> 进行追踪。每次读取中有用信息的是 &lt;key, lsn&gt; 键值对，其中 LSN 是反映读取键值时存储引擎状态的日志序列号。LSN 是一个事务中变更数据的日志索引条目。它由 LogStore 来分配，被设计用于后端数据库的快照。没有被查询到的 key 同样被记录成 <code>读结果集</code> 的一部分。和读操作不同，在写操作中，存储插件不会直接和存储服务器交互。相反，存储插件会为事务缓存它对应的 <code>写结果集</code> 中的写操作。</p><p>当事务提交之时，存储插件将提交请求以及为事务捕获的 <code>读/写结果集</code> 提交到 DBTM。DBTM 为 OCC 执行事务的标准冲突检查。如果没有冲突，它将把 <code>写结果集</code> 持久化到复制的日志存储（即它将 <code>写结果集</code> 发送到日志存储副本集，因此所有副本都保持完全相同的日志）此时，事务就完成了逻辑提交，DBTM 会向存储插件返回响应结果信息。日志播放器跟踪日志存储，并根据数据分布将日志条目播放到后端分片服务器。</p><p>值得指出的是，上面描述的内容只是一个基本设计，还有很多机会来提高它的性能和可用性。我们相信，在跨组件进行优化或使用 DBTM 的复制来实现更高的可靠性之前，使基础组件成熟稳定是更富有成效的。当然，还有很多不同的方式来捕捉 <code>读/写结果集</code>。对于一个键值存储，我们需要的最简单进行冲突检测的方式就是 &lt;key, lsn&gt; 键值对。然而，为了支持更复杂的系统应用，<code>读结果集</code> 可能是一定范围或者是限定条件的数据，正如这篇文章内描述的。[6]在本文撰稿时，NuGraphStore 也正在进行开源。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] C. Mohan, Bruce Lindsay and R. Obermarck, “Transaction management in the R* distributed database management system” ACM Transactions on Database Systems (TODS), Volume 11 Issue 4, Dec. 1986, Pages 378 - 396.</p><p>[2] Pat Helland, “Life beyond Distributed Transactions: an Apostate’s Opinion”, CIDR 2007. </p><p>[3] H.T. Kung, J.T. Robinson, “On Optimistic Methods for Concurrency Control”, ACM Transactions on Database Systems 6:2, June, 1981.</p><p>[4] Thomson, Alexander and Diamond, Thaddeus and Shao, Philip and Ren, Kun and Weng, Shu-Chun and Abadi, Daniel J, “Calvin: Fast distributed transactions for partitioned database systems”, SIGMOD 2012.</p><p>[5] Kun Ren, Alexander Thomson, Daniel Abadi, “An Evaluation of the Advantages and Disadvantages of Deterministic Database Systems”, VLDB 2014.</p><p>[6] Thomas Neumann, Tobias Mühlbauer, Alfons Kemper, “Fast Serializable Multi-Version Concurrency Control for Main-Memory Database Systems”, SIGMOD 2015</p><h2 id="GRIT-a-Protocol-for-Distributed-Transactions-across-Microservices"><a href="#GRIT-a-Protocol-for-Distributed-Transactions-across-Microservices" class="headerlink" title="GRIT: a Protocol for Distributed Transactions across Microservices"></a>GRIT: a Protocol for Distributed Transactions across Microservices</h2><blockquote><p>eBay technologists recently showed off a distributed transaction protocol called GRIT, for distributed ACID (atomicity, consistency, isolation, durability) transactions across microservices with multiple underlying databases.</p></blockquote><p>This article describes the basic ideas of the GRIT protocol, which was announced at the IEEE International Conference on Data Engineering (ICDE) 2019, and provides an example of using part of the protocol for implementing a transactional storage backend for JanusGraph. This example focuses on a system with only a single database, but as we said, GRIT can support ACID transactions for systems consisting of multiple databases.</p><h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><p>In a <a href="https://en.wikipedia.org/wiki/Microservices" target="_blank" rel="noopener">microservice</a> architecture, an application may invoke multiple microservices, which are usually implemented in different application languages by different teams and may use multiple underlying databases to achieve their functionality. This popular architecture brings new challenges for consistent distributed transactions across multiple microservices. It is a real requirement to support ACID transactions in the context of microservices, but is very hard to achieve using existing technologies, since distributed transaction mechanisms designed for a single database cannot be easily extended to the cases with multiple databases through microservices.</p><p>In environments that involve multiple independent databases, the traditional two-phase commit (2PC) protocol[1] was essentially the only option for distributed transactions by the system without additional application effort. However, it does not work well in a scale-out platform due to long paths of potentially many coordinating participants and the locking required over the phases. On the other hand, using a transaction log executed by a framework[2] such as Saga will incur complex compensating logic by applications and may have business implications due to irreversible partially successful transactions. </p><p>To address these issues, we developed <a href="https://ieeexplore.ieee.org/abstract/document/8731442" target="_blank" rel="noopener">GRIT</a>, a novel protocol for globally consistent distributed transactions that cleverly combines ideas from optimistic concurrency control (OCC)[3], 2PC, and deterministic databases[4,5] to achieve, for the first time, high-performance, globally consistent transactions across microservices with multiple underlying databases.</p><h2 id="GRIT-a-protocol-for-distributed-transactions"><a href="#GRIT-a-protocol-for-distributed-transactions" class="headerlink" title="GRIT: a protocol for distributed transactions"></a>GRIT: a protocol for distributed transactions</h2><p>The following diagram illustrates the GRIT protocol in a system of microservices with two databases. The GRIT components, including GTM, GTL, DBTM, DBTL, and LogPlayer, are shown in the center.</p><img src="https://tech.ebayinc.com/assets/Uploads/Editor/GRIT-Protocol-for-Distributed-Transactions-across-Microservices6.png"><p>Without the GRIT components, the diagram represents a system of plain microservice architecture with two scale-out databases. They consist of the following:</p><ol><li>Applications: invoke microservices to achieve their functionality.</li><li>Microservices (Entity Services): building blocks to provide business-oriented service for applications to implement business logic. Each DB may have support for multiple microservices, and each microservice is likely independent of the other.</li><li>DB Services: provide DB read/write interface and directly access DB servers. When supporting transactions, it also caches the read/write results of each transaction during the execution phase and sends them to its DBTM for conflict resolution at commit time.</li><li>DB shard servers: the backend storage servers for the database, usually replicated for high availability.</li></ol><p>The key components of GRIT include:</p><ol><li>Global Transaction Manager (GTM): It coordinates global transactions across multiple databases. There can be one or more GTMs.</li><li>Global Transaction Log (GTL): It represents the transaction request queue for a GTM. The order of transaction requests in a GTL determines the relative serializability order among global transactions. Persistence of GTLs is optional.</li><li>Database Transaction Manager (DBTM): The transaction manager at each database realm. It performs the conflict checking and resolution, i.e. local commit decision is located here.</li><li>Database Transaction Log (DBTL): The transaction log at each database realm that logs logically committed transactions that relate to this database (including single database transactions and multi-database transactions). The order of transactions in a DBTL determines the serializability order of the whole database system, including the global order dictated by the GTM. A log sequence number (LSN) is assigned to each log entry.</li><li>LogPlayer: This component sends log entries, in sequence, to the backend storage servers for them to apply the updates. Each DB server applies log entries of logically committed transactions in order.</li></ol><p>For the purpose of understanding the details of the protocol, we use the following diagram to show the main steps for a distributed transaction.</p><img src="https://tech.ebayinc.com/assets/Uploads/Editor/GRIT-main-steps2.png"><p>In GRIT, a distributed transaction goes through three phases:</p><ol><li>Optimistic execution (steps 1-4): As the application is executing the business logic via microservices, the database services capture the read-set and write-set of the transaction. No actual data modification occurs at this phase.</li><li>Logical commit (steps 5-11): Once the application requests the transaction commit, the read-set and write-set at each database service point are submitted to its DBTM. The DBTM uses the read-set and write-set for conflict checking to achieve local commit decision. The GTM will make the global commit decision after collecting all the local decisions of DBTMs for the transaction. A transaction is logically committed once its write-sets are persisted in log stores (DBTLs) for databases involved. This involves minimum coordination between the GTM and the DBTMs.</li><li>Physical apply (steps 12-13): The log players asynchronously sends DBTL entries to backend storage servers. The data modification occurs at this phase.</li></ol><p>Overall, our approach avoids pessimistic locking during both execution and commit process and avoids waiting for physical commit. We take the optimistic approach and also make the commit process very efficient by leveraging logical commit logs and moving the physical database changes out of the commit decision process with deterministic database technology, which is similar to log play in replication.</p><p>GRIT is able to achieve consistent high throughput and serializable distributed transactions for applications invoking microservices with minimum coordination. GRIT fits well for transactions with few conflicts and provides a critical capability for applications that otherwise need complex mechanisms to achieve consistent transactions across microservices with multiple underlying databases.</p><h2 id="Applying-GRIT-for-a-single-database"><a href="#Applying-GRIT-for-a-single-database" class="headerlink" title="Applying GRIT for a single database"></a>Applying GRIT for a single database</h2><p>As you can see, the GRIT protocol contains two parts: one for each database (or each database realm, which can be a set of partitions of a database) performed by DBTM, DBTL, and LogPlayer, and the other for cross-database coordination by GTM and DBTMs. In the following diagram, we illustrate the design of a transactional graph store backend (called NuGraphStore) for <a href="https://janusgraph.org/" target="_blank" rel="noopener">JanusGraph</a> using the part of GRIT protocol for a single database.</p><p>The following diagram shows how NuGraphStore is implemented with two availability zone (AZ1 and AZ2) deployment for illustration.</p><p>GRIT Protocol for Distributed Transactions across Microservices4</p><img src="https://tech.ebayinc.com/assets/Uploads/Editor/GRIT-Protocol-for-Distributed-Transactions-across-Microservices4.png"><p>There are a few components involved in the NuGraphStore backend for JanusGraph:</p><ul><li>Storage plugin: a custom storage interface plugin to interface between the JanusGraph DB Layer and the backend storage engine and transaction protocol components.</li><li>DBTM: performs the critical conflict checking for optimistic concurrency control. This is part of the <a href="https://ieeexplore.ieee.org/abstract/document/8731442" target="_blank" rel="noopener">GRIT</a> distributed transaction protocol on single databases performing OCC.</li><li>LogStore: replicated log store for mutations from transactions. One entry for each transaction, indexed by Log Sequence Number (LSN). It acts as a WAL (write-ahead-log) in traditional database systems. The LogStore is the DBTL in our GRIT architecture. </li><li>LogPlayer: applies log entries to the backend servers asynchronously.</li><li>Storage engine: backend storage engine to store KCV (Key-Column-Value) data from JanusGraph. It performs reads and mutations and supports snapshots defined by the LSN.</li></ul><p>As an application is performing a transaction, it can read from the store and write to the store. For the read operations, the storage plugin directly communicates with the storage servers (except for reads that are found in the write-set for the transaction). The storage plugin also keeps track of the read-set as the application is reading from the store in the context of a transaction. The useful information for each read is the &lt;key, lsn&gt; pair, where lsn is the log sequence number reflecting the storage engine state when the key-value is read. An LSN is the log index of the entry for the mutations of a transaction. It is assigned by the LogStore and used to define the snapshot of the backend databases. A key being not found is also recorded as part of the read-set. Unlike reads, the storage plugin for writes does not directly communicate with the storage servers. Instead, the storage plugin buffers the writes in the corresponding write-set for the transaction.</p><p>When a transaction commits, the storage plugin submits the commit request with the read-set and write-set it has captured for the transaction to the DBTM. The DBTM performs the standard conflict checking for OCC for the transaction. If there is no conflict, it will persist the write-set to the replicated LogStore (i.e., it sends the write-set to the LogStore replica set, so all the replicas keep the exact same log). At this point, the transaction commit completes logically, and the DBTM responds back to the storage plugin. The LogPlayers tail the LogStores and play the log entries to the backend shard servers based on the data distribution.</p><p>It’s worth pointing out that the above description is a basic design with many opportunities to enhance for performance and reliability. It’s our belief that it is more productive to make the basic components mature before optimizing across the components or using replication for DBTM to achieve higher reliability. Also, there are different ways that we can capture the read-set and write-set. For a KV store, the simplest form we need for conflict checking is &lt;key, lsn&gt; pairs. To support more complex systems, however, the read-set may include ranges, or predicates, as described in.[6] As of this writing, NuGraphStore is going through the open source process.</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p>[1] C. Mohan, Bruce Lindsay and R. Obermarck, “Transaction management in the R* distributed database management system” ACM Transactions on Database Systems (TODS), Volume 11 Issue 4, Dec. 1986, Pages 378 - 396.</p><p>[2] Pat Helland, “Life beyond Distributed Transactions: an Apostate’s Opinion”, CIDR 2007. </p><p>[3] H.T. Kung, J.T. Robinson, “On Optimistic Methods for Concurrency Control”, ACM Transactions on Database Systems 6:2, June, 1981.</p><p>[4] Thomson, Alexander and Diamond, Thaddeus and Shao, Philip and Ren, Kun and Weng, Shu-Chun and Abadi, Daniel J, “Calvin: Fast distributed transactions for partitioned database systems”, SIGMOD 2012.</p><p>[5] Kun Ren, Alexander Thomson, Daniel Abadi, “An Evaluation of the Advantages and Disadvantages of Deterministic Database Systems”, VLDB 2014.</p><p>[6] Thomas Neumann, Tobias Mühlbauer, Alfons Kemper, “Fast Serializable Multi-Version Concurrency Control for Main-Memory Database Systems”, SIGMOD 2015</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;https://tech.ebayinc.com/engineering/grit-a-protocol-for-distributed-transactions-across-microservices/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://tech.ebayinc.com/engineering/grit-a-protocol-for-distributed-transactions-across-microservices/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;eBay 技术人员最近发布了一种称为 &lt;code&gt;GRIT&lt;/code&gt; 分布式事务协议，该协议是为了解决跨多个底层数据库的微服务场景下分布式 ACID（原子性，一致性，隔离性，持久性）事务问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文描述了在 &lt;strong&gt;IEEE国际数据工程会议(ICDE) 2019&lt;/strong&gt; 上发布的 GRIT 协议的基本思想，&lt;font color=&quot;red&quot;&gt;并且提供了一个 JanusGraph 事务性存储后端的示例，该示例实现了 GRIT 协议的一部分功能&lt;/font&gt;。这个示例关注的是仅有单一数据库的应用，但是正如我们所说，GRIT 可以支持由多个数据库组成的系统的 ACID 事务。&lt;/p&gt;
    
    </summary>
    
    
      <category term="架构设计" scheme="https://dongzl.github.io/categories/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="GRIT" scheme="https://dongzl.github.io/tags/GRIT/"/>
    
      <category term="distributed transaction" scheme="https://dongzl.github.io/tags/distributed-transaction/"/>
    
  </entry>
  
  <entry>
    <title>记一次 Wireshark 抓包 Sharding-Proxy 过程</title>
    <link href="https://dongzl.github.io/2019/10/23/07-Wireshark-Sharding-Proxy/"/>
    <id>https://dongzl.github.io/2019/10/23/07-Wireshark-Sharding-Proxy/</id>
    <published>2019-10-23T09:39:35.000Z</published>
    <updated>2020-03-10T02:10:23.222Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景描述"><a href="#背景描述" class="headerlink" title="背景描述"></a>背景描述</h2><p>最近在在参与 <a href="http://shardingsphere.apache.org/" target="_blank" rel="noopener">Apache ShardingSphere</a> 开源项目的一些工作，在 Github 的 <a href="https://github.com/apache/incubator-shardingsphere/issues" target="_blank" rel="noopener">issue 列表</a> 认领了一个问题 <a href="https://github.com/apache/incubator-shardingsphere/issues/3005" target="_blank" rel="noopener">#3005</a>。</p><p>产品描述：首先简单介绍一下 ShardingSphere 中的一个产品 Sharding-Proxy，Sharding-Proxy 产品的功能是做一个透明的中间层代理，后面连接很多的 MySQL 数据库（可能是很多分库后 MySQL 数据库）。用户在使用中可以不用直接连到真实 MySQL 数据库上，而是连接到 Sharding-Proxy 上，通过这个工具再连接到真实的数据库上。</p><a id="more"></a><p>这个过程对于用户应该是无感知的（所以才叫透明的中间层代理），可以像使用 MySQL 一样使用 Sharding-Proxy，例如通过一些工具，像 MySQL JDBC 驱动或者是客户端工具（Navicat、MySQL Workbench）直接使用 Sharding-Proxy，所以 Sharding-Proxy 需要对 MySQL 协议进行解析和封装。对于客户端发送请求，Sharding-Proxy 解析后重新封装发送给 MySQL 服务器，对于 MySQL 服务器响应数据需要解析后重新封装发送给客户端，这个过程要做到精确，才能实现<code>透明的中间层代理</code>的效果。</p><p>认领的 issue 中的问题现象是，Navicat 直接连到 MySQL 服务器打开数据表没有问题，而通过 Sharding-Proxy 代理连接后再打开数据表，就会提示 <font color="#FF0000"> There is no primary key here. Update will only use exact matching of the old values of the columns here. Thus, it may update more than one record. </font> 这个错误，虽然对于使用是没有影响的，但是依然没有做到完全透明。</p><h2 id="Wireshark-软件使用"><a href="#Wireshark-软件使用" class="headerlink" title="Wireshark 软件使用"></a>Wireshark 软件使用</h2><p>对于 Navicat 这种客户端工具，其实是通过网络连接方式连接管理远端数据库，所以一定要走网络协议。所以对于这个问题，首先想到的办法就是通过网络抓包的方式对比一下两种连接方式返回的数据差别。网络抓包好像是有这么个工具 <strong>Wireshark</strong>，对于这个工具只闻名未曾谋面过，果断安装，百度了一下简单实用。</p><p>启动软件后，出现一堆网卡，可能是装虚拟机导致出现了好多虚拟网卡吧，不过大部分网卡没有数据流量。</p><img src="https://gitee.com/dongzl/article-images/raw/master/2019/07-Wireshark-Sharding-Proxy/Wireshark_Sharding-Proxy_01.png" width="600px"><p>首先是 <strong>Wi-Fi: en0</strong> 网卡，进去之后列表一堆数据，直接刷屏，根本看不出有效信息，毫无头绪。</p><p>这个时候发现还有一个 <strong>Loopback: lo0</strong> 网卡，应该是 <strong>环回地址（127.0.0.1）</strong>，这个可能有点意思，因为 MySQL、Sharding-Proxy 和 Navicat 都装在本地开发环境，正常情况不会有真正的网络通信，都是本地搞定。</p><p>进入 <strong>Loopback: lo0</strong> 网卡，看到的就是 <strong>Wireshark</strong> 抓取的网络请求的数据了，其实第一次用，现学现卖，使用不是很流畅，不过还是百度大概了解到了一些使用技巧，首先 <strong>Wireshark</strong> 可以使用很多过滤器，过滤出我们比较感兴趣的网络请求数据，比如根据协议抓取数据，根据请求端口抓取数据进行区分。</p><p>在这个首先想到的是 MySQL 数据库使用的端口是 3306，Sharing-Proxy 使用的端口是 3307，还有就是 MySQL 有自己的应用层协议，协议名字就是：MySQL。</p><h2 id="Wireshark-抓取-MySQL-协议数据"><a href="#Wireshark-抓取-MySQL-协议数据" class="headerlink" title="Wireshark 抓取 MySQL 协议数据"></a>Wireshark 抓取 MySQL 协议数据</h2><p>首先使用 Navicat 直接连到 MySQL 数据库上，在 Wireshark 软件中只过滤 MySQL 协议的网络数据请求：</p><img src="https://gitee.com/dongzl/article-images/raw/master/2019/07-Wireshark-Sharding-Proxy/Wireshark_Sharding-Proxy_02.png" width="600px"><p>Wireshark 还是很强大，很直观的。每一次的 Request 请求，紧跟着是是配对的 Response 响应数据。其中在 Request 请求中 <strong>MySQL Protocol</strong> 中显示了 Navicat 客户端发送给 MySQL 数据库的命令：<strong>SHOW VARIABLES LIKE ‘lower_case_%’</strong>；在 Response 相应的 <strong>MySQL Protocol</strong> 中显示了 MySQL 数据库发送给 Navicat 客户端的相应结果数据，通过上面的操作和观察，至少能大概明白简单的使用方式了。</p><h2 id="Wireshark-抓包数据对比"><a href="#Wireshark-抓包数据对比" class="headerlink" title="Wireshark 抓包数据对比"></a>Wireshark 抓包数据对比</h2><p>Wireshark 大概使用是明白了，现在需要看的就是 Navicat 直连 MySQL和 Navicat 通过 Sharing-Proxy 代理连接 MySQL 到底数据的请求响应过程到底有什么不同了。抓取同一个请求命令在两种不同情况下相应结果数据的差别，理论上来说这就应该是我们排查问题的方向，当然方向是否正确，还需要实操验证。</p><h3 id="Navicat-直连-MySQL-抓包"><a href="#Navicat-直连-MySQL-抓包" class="headerlink" title="Navicat 直连 MySQL 抓包"></a>Navicat 直连 MySQL 抓包</h3><p>根据 Navicat 的提示，只有在查询表数据表的时候会提示错误，所以问题大概应该出现在 select 查询语句的请求 &amp; 相应数据上，我们抓取了一张表的 select 语句数据：</p><img src="https://gitee.com/dongzl/article-images/raw/master/2019/07-Wireshark-Sharding-Proxy/Wireshark_Sharding-Proxy_04.png" width="600px"><p>对于查询的这张数据表，其实 id 字段就是主键，主键是一定存在的，我们看一下返回结果中有关 id 字段的描述信息：</p><img src="https://gitee.com/dongzl/article-images/raw/master/2019/07-Wireshark-Sharding-Proxy/Wireshark_Sharding-Proxy_05.png" width="600px"><p>其中有 <strong>Flags</strong> 属性展开后就是一串标志位，通过实际内容大概就能明白就是标识该字段的一些特殊属性信息：</p><img src="https://gitee.com/dongzl/article-images/raw/master/2019/07-Wireshark-Sharding-Proxy/Wireshark_Sharding-Proxy_06.png" width="600px"><h3 id="Navicat-连接-Sharding-Proxy-抓包"><a href="#Navicat-连接-Sharding-Proxy-抓包" class="headerlink" title="Navicat 连接 Sharding-Proxy 抓包"></a>Navicat 连接 Sharding-Proxy 抓包</h3><p>由于 Sharding-Proxy 底层是直接使用 Netty 实现网络连接，使用 TCP 协议，并且监听的端口号是 3307，所以我们在使用 Wireshark 抓包时可以采用端口号过滤的方式过滤网络请求数据：</p><blockquote><p>tcp.srcport==3307 || tcp.dstport==3307</p></blockquote><p>我们还是抓取了相同一条 select 语句的请求相应数据，由于是直接抓取 TCP 协议包数据，无法像抓取 MySQL 协议数据那样直观了，只能通过二进制数据看出大概样子：</p><p>select 请求数据：</p><img src="https://gitee.com/dongzl/article-images/raw/master/2019/07-Wireshark-Sharding-Proxy/Wireshark_Sharding-Proxy_07.png" width="600px"><p>Sharding-Proxy 相应结果：</p><img src="https://gitee.com/dongzl/article-images/raw/master/2019/07-Wireshark-Sharding-Proxy/Wireshark_Sharding-Proxy_08.png" width="600px"><h2 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h2><p>仔细分析抓取的数据结果，其实还是能看到一些差别的，不过 Sharding-Proxy 抓取到的结果不是很直观，还是给结果分析带来一定困难的，还是直接上结论吧：</p><img src="https://gitee.com/dongzl/article-images/raw/master/2019/07-Wireshark-Sharding-Proxy/Wireshark_Sharding-Proxy_09.png" width="600px"><img src="https://gitee.com/dongzl/article-images/raw/master/2019/07-Wireshark-Sharding-Proxy/Wireshark_Sharding-Proxy_10.png" width="600px"><p>分析的结果可以看出，Navicat 工具直连 MySQL 数据库时执行的 select 查询语句中返回的 <code>Flags</code> 信息标志位二进制数据为 <code>03 50</code>，标识该字段为 <code>Not null</code> 和 <code>Primary key</code>；但是 Navicat 连接 Sharding-Proxy 代理后返回的数据中该标志位二进制位 <code>00 00</code>，其实到这里，结果就很明显了，Sharding-Proxy 返回的数据中 <code>Flags</code> 信息缺失，而该数据正式判断该数据是否为主键、是否允许为null等等信息的一种标识。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>其实，现在记录整个内容过程感觉很简单，其实过程并不容易，有些分析其实就是 <strong>经验 + 运气</strong>，而且可能运气的成分还要多一些，不过整个过程下来还是给自己增长很多知识的，不过确实要说一句：<strong>Wireshark 是个很不错的软件，以后要多学习、常使用，应用好了事半功倍</strong>。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.cnblogs.com/lsdb/p/9254544.html" target="_blank" rel="noopener">Wireshark使用教程</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景描述&quot;&gt;&lt;a href=&quot;#背景描述&quot; class=&quot;headerlink&quot; title=&quot;背景描述&quot;&gt;&lt;/a&gt;背景描述&lt;/h2&gt;&lt;p&gt;最近在在参与 &lt;a href=&quot;http://shardingsphere.apache.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Apache ShardingSphere&lt;/a&gt; 开源项目的一些工作，在 Github 的 &lt;a href=&quot;https://github.com/apache/incubator-shardingsphere/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;issue 列表&lt;/a&gt; 认领了一个问题 &lt;a href=&quot;https://github.com/apache/incubator-shardingsphere/issues/3005&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;#3005&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;产品描述：首先简单介绍一下 ShardingSphere 中的一个产品 Sharding-Proxy，Sharding-Proxy 产品的功能是做一个透明的中间层代理，后面连接很多的 MySQL 数据库（可能是很多分库后 MySQL 数据库）。用户在使用中可以不用直接连到真实 MySQL 数据库上，而是连接到 Sharding-Proxy 上，通过这个工具再连接到真实的数据库上。&lt;/p&gt;
    
    </summary>
    
    
      <category term="架构设计" scheme="https://dongzl.github.io/categories/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="Wireshark" scheme="https://dongzl.github.io/tags/Wireshark/"/>
    
      <category term="ShardingSphere" scheme="https://dongzl.github.io/tags/ShardingSphere/"/>
    
  </entry>
  
  <entry>
    <title>从一个业务场景聊聊 ZooKeeper 队列使用</title>
    <link href="https://dongzl.github.io/2019/10/19/06-ZooKeeper-Distributed-Queue/"/>
    <id>https://dongzl.github.io/2019/10/19/06-ZooKeeper-Distributed-Queue/</id>
    <published>2019-10-19T09:03:49.000Z</published>
    <updated>2020-03-10T01:43:44.010Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景描述"><a href="#背景描述" class="headerlink" title="背景描述"></a>背景描述</h2><p>目前在做的 APP 客户端有个业务场景，对于登录的新用户需要做一些操作，例如初始化用户账户信息，给该新用户发放一些优惠，比如发放优惠券、赠送经验积分等等。对于这种场景一般很容易想到使用消息队列（MQ），但是考虑到目前的业务场景，每天新增的用户并不多，如果引入专门的消息队列框架（例如：RocketMQ、RabbitMQ）等感觉比较重，意义并不是很大。</p><p><strong>PS. 一句话需求，新增登录用户模块要实现功能解耦，用户登录与新用户业务逻辑功能分开，想到使用消息队列机制，但是不想引入重量级 MQ 框架。</strong></p><a id="more"></a><p>通过调研，发现利用 ZooKeeper + Curator 是可以实现分布式队列类似的效果的，同时预研使用 ZooKeepr + Curator 实现了该功能，这一篇文章对 ZooKeepr + Curator 实现队列机制的一个总结。</p><h2 id="ZooKeeper-队列实现原理"><a href="#ZooKeeper-队列实现原理" class="headerlink" title="ZooKeeper 队列实现原理"></a>ZooKeeper 队列实现原理</h2><h3 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h3><p>为了在 ZooKeeper 中实现分布式队列，需要设计一个 ZNode 节点来存放数据，这个节点是<code>队列节点</code>，例如：<code>/app_name/first_login_user</code>。生产者向队列中存放数据，每一个消息数据都是<code>队列节点</code>下的一个新节点，我们称作<code>消息节点</code>。消息节点的命名规则为：queue-xxxx，其中 xxxx 是一个单调递增序列，从 ZooKeeper 内部存储结构来说，其实就是创建<code>持久顺序（PERSISTENT_SEQUENTIAL）</code>类型节点来实现。这样，生产者不断的在队列节点下创建消息节点，消息节点数据存储为：queue-xxxx，这就是生产者端的实现原理。</p><h3 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h3><p>消费者从队列中获取数据是通过 <code>getChildren()</code> 方法获取到<code>队列节点</code>中的所有<code>消息节点</code>，然后获取消息节点中存储数据，处理业务逻辑，并删除<code>消息节点</code>。 如果 <code>getChildren()</code> 没有获取到节点数据，说明队列是空的，则消费者进入等待状态，同时调用 <code>getChildren()</code> 方法设置观察者监听队列节点，队列节点发生变化后（消息节点变更），触发监听事件，唤起消费者。</p><img src="https://gitee.com/dongzl/article-images/raw/master/2019/06-ZooKeeper-Distributed-Queue/ZooKeeper-Distributed-Queue.png" width="600px"><h2 id="Curator-框架队列实现"><a href="#Curator-框架队列实现" class="headerlink" title="Curator 框架队列实现"></a>Curator 框架队列实现</h2><h3 id="DistributedQueue"><a href="#DistributedQueue" class="headerlink" title="DistributedQueue"></a>DistributedQueue</h3><blockquote><p>Distributed Queue - An implementation of the Distributed Queue ZK recipe. Items put into the queue are guaranteed to be ordered (by means of ZK’s PERSISTENTSEQUENTIAL node). If a single consumer takes items out of the queue, they will be ordered FIFO. If ordering is important, use a LeaderSelector to nominate a single consumer.</p></blockquote><p><code>Distributed Queue - ZK 的 分布式队列实现。添加到队列中的元素是可以保证顺序性的（通过 ZK 的 PERSISTENT SEQUENTIAL 节点类型实现）。如果只有单一消费者从队列中获取元素，可以保证以 FIFO 顺序消费元素。如果顺序性是非常重要的，可以通过 LeaderSelector 方式只选举出一个消费者。</code></p><p>数据存储格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">queue-0000000001</span><br><span class="line">queue-0000000002</span><br><span class="line">queue-0000000003</span><br><span class="line">queue-0000000004</span><br><span class="line">... ...</span><br><span class="line">queue-0000000098</span><br><span class="line">queue-0000000099</span><br><span class="line">queue-0000000100</span><br></pre></td></tr></table></figure><p>使用方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 核心类</span></span><br><span class="line">org.apache.curator.framework.recipes.queue.DistributedQueue;</span><br><span class="line">org.apache.curator.framework.recipes.queue.QueueBuilder;</span><br><span class="line">org.apache.curator.framework.recipes.queue.QueueConsumer;</span><br><span class="line">org.apache.curator.framework.recipes.queue.QueueSerializer;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Builder 实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">QueueBuilder&lt;T&gt; <span class="title">builder</span><span class="params">(CuratorFramework client, QueueConsumer&lt;T&gt; consumer, QueueSerializer&lt;T&gt; serializer, String queuePath)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parameters:</span><br><span class="line">   client - Curator 客户端</span><br><span class="line">   consumer - 接收消息消费者</span><br><span class="line">   serializer - 元素序列化工具</span><br><span class="line">   queuePath - 存储队列数据路径</span><br><span class="line"></span><br><span class="line"><span class="comment">// DistributedQueue 实现</span></span><br><span class="line">DistributedQueue&lt;String&gt; queue = QueueBuilder.builder(client, consumer, createQueueSerializer(), PATH).buildQueue();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者</span></span><br><span class="line">queue.put(aMessage);</span><br></pre></td></tr></table></figure><h3 id="DistributedIdQueue"><a href="#DistributedIdQueue" class="headerlink" title="DistributedIdQueue"></a>DistributedIdQueue</h3><blockquote><p>Distributed Id Queue - A version of DistributedQueue that allows IDs to be associated with queue items. Items can then be removed from the queue if needed.</p></blockquote><p><code>Distributed Id Queue - 允许 ID 与队列元素关联的 DistributedQueue 版本实现。如果有需要可以根据 ID 删除元素。</code></p><p>数据存储格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">queue-|id-1|0000000001</span><br><span class="line">queue-|id-2|0000000002</span><br><span class="line">queue-|id-3|0000000003</span><br><span class="line">queue-|id-4|0000000004</span><br><span class="line">... ...</span><br><span class="line">queue-|id-98|0000000098</span><br><span class="line">queue-|id-99|0000000099</span><br><span class="line">queue-|id-100|0000000100</span><br><span class="line"></span><br><span class="line">数据格式：</span><br><span class="line">queue-|itemId|节点顺序</span><br></pre></td></tr></table></figure><p>使用方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 核心类</span></span><br><span class="line">org.apache.curator.framework.recipes.queue.DistributedIdQueue;</span><br><span class="line">org.apache.curator.framework.recipes.queue.QueueBuilder;</span><br><span class="line">org.apache.curator.framework.recipes.queue.QueueConsumer;</span><br><span class="line">org.apache.curator.framework.recipes.queue.QueueSerializer;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DistributedIdQueue 实现</span></span><br><span class="line">DistributedIdQueue&lt;String&gt; queue = QueueBuilder.builder(client, consumer, createQueueSerializer(), PATH).buildIdQueue();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者</span></span><br><span class="line">queue.put(aMessage, itemId);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以根据 itemId 移除元素</span></span><br><span class="line"><span class="keyword">int</span> numberRemoved = queue.remove(itemId);</span><br></pre></td></tr></table></figure><h3 id="DistributedPriorityQueue"><a href="#DistributedPriorityQueue" class="headerlink" title="DistributedPriorityQueue"></a>DistributedPriorityQueue</h3><blockquote><p>Distributed Priority Queue - An implementation of the Distributed Priority Queue ZK recipe.</p></blockquote><p><code>Distributed Priority Queue - 分布式优先级队列的 ZK 实现。</code></p><p>数据存储格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">queue-10000001F0000000001</span><br><span class="line">queue-1000000140000000002</span><br><span class="line">queue-10000004F0000000003</span><br><span class="line">queue-10000000F0000000004</span><br><span class="line">... ...</span><br><span class="line">queue-1000000570000000098</span><br><span class="line">queue-10000003C0000000099</span><br><span class="line">queue-10000003C0000000100</span><br><span class="line"></span><br><span class="line">数据格式：</span><br><span class="line">queue-(priority &gt;= 0 ? &quot;1&quot; : &quot;0&quot;) + [(priority &amp; 4294967295L) 16进制] + 节点顺序</span><br></pre></td></tr></table></figure><p>使用方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 核心类</span></span><br><span class="line">org.apache.curator.framework.recipes.queue.DistributedPriorityQueue;</span><br><span class="line">org.apache.curator.framework.recipes.queue.QueueBuilder;</span><br><span class="line">org.apache.curator.framework.recipes.queue.QueueConsumer;</span><br><span class="line">org.apache.curator.framework.recipes.queue.QueueSerializer;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DistributedPriorityQueue 实现</span></span><br><span class="line">DistributedPriorityQueue&lt;String&gt; queue = QueueBuilder.builder(client, consumer, createQueueSerializer(), PATH).buildPriorityQueue(minItemsBeforeRefresh);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者</span></span><br><span class="line">queue.put(aMessage, priority);</span><br></pre></td></tr></table></figure><h3 id="DistributedDelayQueue"><a href="#DistributedDelayQueue" class="headerlink" title="DistributedDelayQueue"></a>DistributedDelayQueue</h3><blockquote><p>Distributed Delay Queue - An implementation of a Distributed Delay Queue.</p></blockquote><p><code>Distributed Delay Queue - 分布式延迟队列实现。</code></p><p>数据存储格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">queue-|16DE33C4F8D|0000000001</span><br><span class="line">queue-|16DE33C4F8D|0000000002</span><br><span class="line">queue-|16DE33C4F8D|0000000003</span><br><span class="line">queue-|16DE33C4F8D|0000000004</span><br><span class="line">... ...</span><br><span class="line">queue-|16DE33C4F8E|0000000098</span><br><span class="line">queue-|16DE33C4F8E|0000000099</span><br><span class="line">queue-|16DE33C4F8E|0000000100</span><br><span class="line"></span><br><span class="line">数据格式：</span><br><span class="line">queue-|delayUntilEpoch 8位16进制|节点顺序</span><br></pre></td></tr></table></figure><p>使用方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 核心类</span></span><br><span class="line">org.apache.curator.framework.recipes.queue.DistributedPriorityQueue;</span><br><span class="line">org.apache.curator.framework.recipes.queue.QueueBuilder;</span><br><span class="line">org.apache.curator.framework.recipes.queue.QueueConsumer;</span><br><span class="line">org.apache.curator.framework.recipes.queue.QueueSerializer;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DistributedPriorityQueue 实现</span></span><br><span class="line">DistributedDelayQueue&lt;String&gt; queue = QueueBuilder.builder(client, consumer, createQueueSerializer(), PATH).buildDelayQueue();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者</span></span><br><span class="line">queue.put(aMessage, delayUntilEpoch);</span><br></pre></td></tr></table></figure><h3 id="SimpleDistributedQueue"><a href="#SimpleDistributedQueue" class="headerlink" title="SimpleDistributedQueue"></a>SimpleDistributedQueue</h3><blockquote><p>Simple Distributed Queue - A drop-in replacement for the DistributedQueue that comes with the ZK distribution.</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 核心类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SimpleDistributedQueue</span><span class="params">(CuratorFramework client, String path)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 入队</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(<span class="keyword">byte</span>[] data)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 出队，移除头部元素并返回该元素，会阻塞。</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">byte</span>[] <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span></span><br></pre></td></tr></table></figure><h2 id="系统实现"><a href="#系统实现" class="headerlink" title="系统实现"></a>系统实现</h2><p>业务系统中是采用 <code>DistributedQueue</code> 的实现，首先在用户登录成功后向 ZooKeeper 的固定节点下写入 <code>PERSISTENT_SEQUENTIAL</code> 数据，写入后直接返回，不阻塞用户登录操作；在另外的线程中消费 <code>DistributedQueue</code> 队列中数据，直接按顺序获取节点数据，开始进行业务逻辑处理。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>对于使用 ZooKeeper 实现的分布式消息队列，需要注意一些问题。首先，对于使用 ZooKeeper 实现的队列这件事情本身，Curator 的官方文档就是不推荐的：</p><p><strong>IMPORTANT - We recommend that you do NOT use ZooKeeper for Queues. Please see <a href="https://cwiki.apache.org/confluence/display/CURATOR/TN4" target="_blank" rel="noopener">Tech Note 4</a> for details.</strong></p><p>ZooKeeper 的使用手册页面列举了一些 ZooKeeper 作为队列的使用场景。Curator 包括了几种队列的实现方式，以我们的经验，使用 ZooKeeper 作为消息队列是一个糟糕的选择：</p><ul><li>ZooKeeper 有 1MB 的传输限制。 实践中 ZNode 必须相对较小，而队列包含成千上万的消息，可能非常的大；</li><li>如果有很多节点，ZooKeeper 启动时相当的慢。而使用队列需要创建很多 ZNode 节点，所以在使用中需要显著调大 initLimit 和 syncLimit 参数值；</li><li>当某个 ZNode 很大的时候会很难清理，同时调用这个节点的 <code>getChildren()</code> 方法会失败；</li><li>当出现大量的包含成千上万的子节点的 ZNode 时，ZooKeeper 的性能会急剧下降；</li><li>ZooKeeper 的数据完全存放在内存中，如果有大量的队列消息会占用很多的内存空间。</li></ul><p>虽然从官方文档上来看，并不推荐使用 ZooKeeper 作为消息队列载体，但这是在大量消息的队列使用场景下，对于小规模的队列场景，例如我们新登录用户场景，一天也就几百个消息，其实也是没有问题的，之所谓<code>一切脱离业务谈技术架构都是耍流氓</code>。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://ifeve.com/zookeeper%EF%BC%8Dcurator/" target="_blank" rel="noopener">跟着实例学习ZooKeeper的用法： 队列</a></li><li><a href="https://www.cnblogs.com/boboooo/p/9259306.html" target="_blank" rel="noopener">Zookeeper应用之——队列（Queue）</a></li><li><a href="http://curator.apache.org/curator-recipes/index.html" target="_blank" rel="noopener">Curator - Recipes</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景描述&quot;&gt;&lt;a href=&quot;#背景描述&quot; class=&quot;headerlink&quot; title=&quot;背景描述&quot;&gt;&lt;/a&gt;背景描述&lt;/h2&gt;&lt;p&gt;目前在做的 APP 客户端有个业务场景，对于登录的新用户需要做一些操作，例如初始化用户账户信息，给该新用户发放一些优惠，比如发放优惠券、赠送经验积分等等。对于这种场景一般很容易想到使用消息队列（MQ），但是考虑到目前的业务场景，每天新增的用户并不多，如果引入专门的消息队列框架（例如：RocketMQ、RabbitMQ）等感觉比较重，意义并不是很大。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;PS. 一句话需求，新增登录用户模块要实现功能解耦，用户登录与新用户业务逻辑功能分开，想到使用消息队列机制，但是不想引入重量级 MQ 框架。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="架构设计" scheme="https://dongzl.github.io/categories/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="ZooKeeper" scheme="https://dongzl.github.io/tags/ZooKeeper/"/>
    
      <category term="Curator" scheme="https://dongzl.github.io/tags/Curator/"/>
    
      <category term="Queue" scheme="https://dongzl.github.io/tags/Queue/"/>
    
  </entry>
  
</feed>
